Created by PLY version 3.4 (http://www.dabeaz.com/ply)

Unused terminals:

    COMMENT

Grammar

Rule 0     S' -> program
Rule 1     program -> block
Rule 2     program -> compound_statement
Rule 3     block -> unlabelled_block
Rule 4     block -> TLABEL COLON block
Rule 5     unlabelled_block -> block_head SEMICOLON compound_tail
Rule 6     block_head -> BEGIN declaration
Rule 7     block_head -> block_head SEMICOLON declaration
Rule 8     compound_statement -> unlabelled_compound
Rule 9     compound_statement -> label COLON compound_statement
Rule 10    unlabelled_compound -> BEGIN compound_tail
Rule 11    compound_tail -> statement END
Rule 12    compound_tail -> statement SEMICOLON compound_tail
Rule 13    declaration -> type_declaration
Rule 14    declaration -> array_declaration
Rule 15    declaration -> switch_declaration
Rule 16    declaration -> procedure_declaration
Rule 17    type_declaration -> local_or_own_type type_list
Rule 18    local_or_own_type -> type
Rule 19    local_or_own_type -> TOWN type
Rule 20    type -> TREAL
Rule 21    type -> TINTEGER
Rule 22    type -> TBOOLEAN
Rule 23    type_list -> simple_variable
Rule 24    type_list -> simple_variable COMMA type_list
Rule 25    array_declaration -> TARRAY array_list
Rule 26    array_declaration -> local_or_own_type TARRAY array_list
Rule 27    array_list -> array_segment
Rule 28    array_list -> array_list COMMA array_segment
Rule 29    array_segment -> array_identifier LBBRACKET bound_pair_list RBBRACKET
Rule 30    array_segment -> array_identifier COMMA array_segment
Rule 31    array_identifier -> IDENTIFIER
Rule 32    bound_pair_list -> bound_pair
Rule 33    bound_pair_list -> bound_pair_list COMMA bound_pair
Rule 34    bound_pair -> lower_bound COLON upper_bound
Rule 35    upper_bound -> arithmetic_expression
Rule 36    lower_bound -> arithmetic_expression
Rule 37    switch_declaration -> SWITCH switch_identifier ASSIGNMENT switch_list
Rule 38    switch_identifier -> IDENTIFIER
Rule 39    switch_list -> designational_expression
Rule 40    switch_list -> switch_list COMMA designational_expression
Rule 41    procedure_declaration -> PROCEDURE procedure_heading procedure_body
Rule 42    procedure_declaration -> type PROCEDURE procedure_heading procedure_body
Rule 43    procedure_heading -> procedure_identifier formal_parameter_part SEMICOLON value_part specification_part
Rule 44    procedure_identifier -> IDENTIFIER
Rule 45    formal_parameter_part -> <empty>
Rule 46    formal_parameter_part -> LCBRACKET formal_parameter_list RCBRACKET
Rule 47    formal_parameter_list -> formal_parameter
Rule 48    formal_parameter_list -> formal_parameter_list parameter_delimiter formal_parameter
Rule 49    formal_parameter -> IDENTIFIER
Rule 50    value_part -> <empty>
Rule 51    value_part -> TVALUE identifier_list SEMICOLON
Rule 52    specification_part -> <empty>
Rule 53    specification_part -> specifier identifier_list SEMICOLON
Rule 54    specification_part -> specification_part specifier identifier_list
Rule 55    specifier -> TSTRING
Rule 56    specifier -> type
Rule 57    specifier -> TARRAY
Rule 58    specifier -> type TARRAY
Rule 59    specifier -> TLABEL
Rule 60    specifier -> SWITCH
Rule 61    specifier -> PROCEDURE
Rule 62    specifier -> type PROCEDURE
Rule 63    identifier_list -> IDENTIFIER
Rule 64    identifier_list -> identifier_list COMMA IDENTIFIER
Rule 65    procedure_body -> statement
Rule 66    statement -> unconditional_statement
Rule 67    statement -> conditional_statement
Rule 68    statement -> for_statement
Rule 69    unconditional_statement -> basic_statement
Rule 70    unconditional_statement -> compound_statement
Rule 71    unconditional_statement -> block
Rule 72    basic_statement -> unlabelled_basic_statement
Rule 73    basic_statement -> label COLON basic_statement
Rule 74    label -> IDENTIFIER
Rule 75    label -> unsigned_integer
Rule 76    unlabelled_basic_statement -> assignment_statement
Rule 77    unlabelled_basic_statement -> go_to_statement
Rule 78    unlabelled_basic_statement -> procedure_statement
Rule 79    assignment_statement -> left_part_list arithmetic_expression
Rule 80    assignment_statement -> left_part_list boolean_expression
Rule 81    left_part_list -> left_part
Rule 82    left_part_list -> left_part_list left_part
Rule 83    left_part -> variable ASSIGNMENT
Rule 84    left_part -> procedure_identifier ASSIGNMENT
Rule 85    go_to_statement -> GOTO designational_expression
Rule 86    designational_expression -> simple_designational_expression
Rule 87    designational_expression -> if_clause simple_designational_expression ELSE designational_expression
Rule 88    simple_designational_expression -> label
Rule 89    simple_designational_expression -> switch_designator
Rule 90    simple_designational_expression -> LCBRACKET designational_expression RCBRACKET
Rule 91    switch_designator -> switch_identifier LBBRACKET subscript_expression RBBRACKET
Rule 92    procedure_statement -> procedure_identifier actual_parameter_part
Rule 93    actual_parameter_part -> LCBRACKET RCBRACKET
Rule 94    actual_parameter_part -> LCBRACKET actual_parameter_list RCBRACKET
Rule 95    actual_parameter_list -> actual_parameter
Rule 96    actual_parameter_list -> actual_parameter_list parameter_delimiter actual_parameter
Rule 97    parameter_delimiter -> COMMA
Rule 98    parameter_delimiter -> RCBRACKET letter_string COLON LCBRACKET
Rule 99    actual_parameter -> string
Rule 100   actual_parameter -> expression
Rule 101   actual_parameter -> array_identifier
Rule 102   actual_parameter -> switch_identifier
Rule 103   actual_parameter -> procedure_identifier
Rule 104   conditional_statement -> if_statement
Rule 105   conditional_statement -> if_statement ELSE statement
Rule 106   conditional_statement -> if_clause for_statement
Rule 107   conditional_statement -> label COLON conditional_statement
Rule 108   if_statement -> if_clause unconditional_statement
Rule 109   if_clause -> IF boolean_expression THEN
Rule 110   for_statement -> for_clause statement
Rule 111   for_statement -> label COLON for_statement
Rule 112   for_clause -> FOR variable ASSIGNMENT for_list DO
Rule 113   for_list -> for_list_element
Rule 114   for_list -> for_list COMMA for_list_element
Rule 115   for_list_element -> arithmetic_expression
Rule 116   for_list_element -> arithmetic_expression STEP arithmetic_expression UNTIL arithmetic_expression
Rule 117   for_list_element -> arithmetic_expression WHILE boolean_expression
Rule 118   expression -> arithmetic_expression
Rule 119   expression -> boolean_expression
Rule 120   expression -> designational_expression
Rule 121   arithmetic_expression -> simple_arithmetic_expression
Rule 122   arithmetic_expression -> if_clause simple_arithmetic_expression ELSE arithmetic_expression
Rule 123   simple_arithmetic_expression -> term
Rule 124   simple_arithmetic_expression -> adding_operator term
Rule 125   simple_arithmetic_expression -> simple_arithmetic_expression adding_operator term
Rule 126   adding_operator -> PLUS
Rule 127   adding_operator -> MINUS
Rule 128   term -> factor
Rule 129   term -> term multiplying_operator factor
Rule 130   multiplying_operator -> TIMES
Rule 131   multiplying_operator -> DIV
Rule 132   multiplying_operator -> MOD
Rule 133   factor -> primary
Rule 134   factor -> factor
Rule 135   factor -> factor POWER primary
Rule 136   primary -> unsigned_number
Rule 137   primary -> variable
Rule 138   primary -> function_designator
Rule 139   primary -> LCBRACKET arithmetic_expression RCBRACKET
Rule 140   unsigned_number -> decimal_number
Rule 141   unsigned_number -> exponential_part
Rule 142   unsigned_number -> decimal_number exponential_part
Rule 143   decimal_number -> unsigned_integer
Rule 144   decimal_number -> decimal_fraction
Rule 145   decimal_number -> unsigned_integer decimal_fraction
Rule 146   unsigned_integer -> DIGIT
Rule 147   unsigned_integer -> unsigned_integer DIGIT
Rule 148   decimal_fraction -> DOT unsigned_integer
Rule 149   exponential_part -> EREAL integer
Rule 150   integer -> unsigned_integer
Rule 151   integer -> PLUS unsigned_integer
Rule 152   integer -> MINUS unsigned_integer
Rule 153   boolean_expression -> simple_boolean
Rule 154   boolean_expression -> if_clause simple_boolean ELSE boolean_expression
Rule 155   simple_boolean -> implication
Rule 156   simple_boolean -> simple_boolean EQUIV implication
Rule 157   implication -> boolean_term
Rule 158   implication -> implication IMPL boolean_term
Rule 159   boolean_term -> boolean_factor
Rule 160   boolean_term -> boolean_term OR boolean_factor
Rule 161   boolean_factor -> boolean_secondary
Rule 162   boolean_factor -> boolean_factor AND boolean_secondary
Rule 163   boolean_secondary -> boolean_primary
Rule 164   boolean_secondary -> NOT boolean_primary
Rule 165   boolean_primary -> logical_value
Rule 166   boolean_primary -> variable
Rule 167   boolean_primary -> function_designator
Rule 168   boolean_primary -> relation
Rule 169   boolean_primary -> LCBRACKET boolean_expression RCBRACKET
Rule 170   relation -> simple_arithmetic_expression relational_operator simple_arithmetic_expression
Rule 171   function_designator -> procedure_identifier actual_parameter_part
Rule 172   variable -> simple_variable
Rule 173   variable -> subscripted_variable
Rule 174   simple_variable -> variable_identifier
Rule 175   variable_identifier -> IDENTIFIER
Rule 176   subscripted_variable -> array_identifier LBBRACKET subscript_list RBBRACKET
Rule 177   subscript_list -> subscript_expression
Rule 178   subscript_list -> subscript_list COMMA subscript_expression
Rule 179   subscript_expression -> arithmetic_expression
Rule 180   string -> STRING
Rule 181   letter_string -> LETTER
Rule 182   letter_string -> letter_string LETTER
Rule 183   logical_value -> TRUE
Rule 184   logical_value -> FALSE
Rule 185   relational_operator -> LESS
Rule 186   relational_operator -> NOTGREATER
Rule 187   relational_operator -> EQUAL
Rule 188   relational_operator -> NOTLESS
Rule 189   relational_operator -> GREATER
Rule 190   relational_operator -> NOTEQUAL

Terminals, with rules where they appear

AND                  : 162
ASSIGNMENT           : 37 83 84 112
BEGIN                : 6 10
COLON                : 4 9 34 73 98 107 111
COMMA                : 24 28 30 33 40 64 97 114 178
COMMENT              : 
DIGIT                : 146 147
DIV                  : 131
DO                   : 112
DOT                  : 148
ELSE                 : 87 105 122 154
END                  : 11
EQUAL                : 187
EQUIV                : 156
EREAL                : 149
FALSE                : 184
FOR                  : 112
GOTO                 : 85
GREATER              : 189
IDENTIFIER           : 31 38 44 49 63 64 74 175
IF                   : 109
IMPL                 : 158
LBBRACKET            : 29 91 176
LCBRACKET            : 46 90 93 94 98 139 169
LESS                 : 185
LETTER               : 181 182
MINUS                : 127 152
MOD                  : 132
NOT                  : 164
NOTEQUAL             : 190
NOTGREATER           : 186
NOTLESS              : 188
OR                   : 160
PLUS                 : 126 151
POWER                : 135
PROCEDURE            : 41 42 61 62
RBBRACKET            : 29 91 176
RCBRACKET            : 46 90 93 94 98 139 169
SEMICOLON            : 5 7 12 43 51 53
STEP                 : 116
STRING               : 180
SWITCH               : 37 60
TARRAY               : 25 26 57 58
TBOOLEAN             : 22
THEN                 : 109
TIMES                : 130
TINTEGER             : 21
TLABEL               : 4 59
TOWN                 : 19
TREAL                : 20
TRUE                 : 183
TSTRING              : 55
TVALUE               : 51
UNTIL                : 116
WHILE                : 117
error                : 

Nonterminals, with rules where they appear

actual_parameter     : 95 96
actual_parameter_list : 94 96
actual_parameter_part : 92 171
adding_operator      : 124 125
arithmetic_expression : 35 36 79 115 116 116 116 117 118 122 139 179
array_declaration    : 14
array_identifier     : 29 30 101 176
array_list           : 25 26 28
array_segment        : 27 28 30
assignment_statement : 76
basic_statement      : 69 73
block                : 1 4 71
block_head           : 5 7
boolean_expression   : 80 109 117 119 154 169
boolean_factor       : 159 160 162
boolean_primary      : 163 164
boolean_secondary    : 161 162
boolean_term         : 157 158 160
bound_pair           : 32 33
bound_pair_list      : 29 33
compound_statement   : 2 9 70
compound_tail        : 5 10 12
conditional_statement : 67 107
decimal_fraction     : 144 145
decimal_number       : 140 142
declaration          : 6 7
designational_expression : 39 40 85 87 90 120
exponential_part     : 141 142
expression           : 100
factor               : 128 129 134 135
for_clause           : 110
for_list             : 112 114
for_list_element     : 113 114
for_statement        : 68 106 111
formal_parameter     : 47 48
formal_parameter_list : 46 48
formal_parameter_part : 43
function_designator  : 138 167
go_to_statement      : 77
identifier_list      : 51 53 54 64
if_clause            : 87 106 108 122 154
if_statement         : 104 105
implication          : 155 156 158
integer              : 149
label                : 9 73 88 107 111
left_part            : 81 82
left_part_list       : 79 80 82
letter_string        : 98 182
local_or_own_type    : 17 26
logical_value        : 165
lower_bound          : 34
multiplying_operator : 129
parameter_delimiter  : 48 96
primary              : 133 135
procedure_body       : 41 42
procedure_declaration : 16
procedure_heading    : 41 42
procedure_identifier : 43 84 92 103 171
procedure_statement  : 78
program              : 0
relation             : 168
relational_operator  : 170
simple_arithmetic_expression : 121 122 125 170 170
simple_boolean       : 153 154 156
simple_designational_expression : 86 87
simple_variable      : 23 24 172
specification_part   : 43 54
specifier            : 53 54
statement            : 11 12 65 105 110
string               : 99
subscript_expression : 91 177 178
subscript_list       : 176 178
subscripted_variable : 173
switch_declaration   : 15
switch_designator    : 89
switch_identifier    : 37 91 102
switch_list          : 37 40
term                 : 123 124 125 129
type                 : 18 19 42 56 58 62
type_declaration     : 13
type_list            : 17 24
unconditional_statement : 66 108
unlabelled_basic_statement : 72
unlabelled_block     : 3
unlabelled_compound  : 8
unsigned_integer     : 75 143 145 147 148 150 151 152
unsigned_number      : 136
upper_bound          : 34
value_part           : 43
variable             : 83 112 137 166
variable_identifier  : 174

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . block
    (2) program -> . compound_statement
    (3) block -> . unlabelled_block
    (4) block -> . TLABEL COLON block
    (8) compound_statement -> . unlabelled_compound
    (9) compound_statement -> . label COLON compound_statement
    (5) unlabelled_block -> . block_head SEMICOLON compound_tail
    (10) unlabelled_compound -> . BEGIN compound_tail
    (74) label -> . IDENTIFIER
    (75) label -> . unsigned_integer
    (6) block_head -> . BEGIN declaration
    (7) block_head -> . block_head SEMICOLON declaration
    (146) unsigned_integer -> . DIGIT
    (147) unsigned_integer -> . unsigned_integer DIGIT

    TLABEL          shift and go to state 4
    BEGIN           shift and go to state 1
    IDENTIFIER      shift and go to state 11
    DIGIT           shift and go to state 6

    unlabelled_compound            shift and go to state 2
    compound_statement             shift and go to state 3
    unlabelled_block               shift and go to state 5
    label                          shift and go to state 7
    program                        shift and go to state 8
    unsigned_integer               shift and go to state 9
    block_head                     shift and go to state 10
    block                          shift and go to state 12

state 1

    (10) unlabelled_compound -> BEGIN . compound_tail
    (6) block_head -> BEGIN . declaration
    (11) compound_tail -> . statement END
    (12) compound_tail -> . statement SEMICOLON compound_tail
    (13) declaration -> . type_declaration
    (14) declaration -> . array_declaration
    (15) declaration -> . switch_declaration
    (16) declaration -> . procedure_declaration
    (66) statement -> . unconditional_statement
    (67) statement -> . conditional_statement
    (68) statement -> . for_statement
    (17) type_declaration -> . local_or_own_type type_list
    (25) array_declaration -> . TARRAY array_list
    (26) array_declaration -> . local_or_own_type TARRAY array_list
    (37) switch_declaration -> . SWITCH switch_identifier ASSIGNMENT switch_list
    (41) procedure_declaration -> . PROCEDURE procedure_heading procedure_body
    (42) procedure_declaration -> . type PROCEDURE procedure_heading procedure_body
    (69) unconditional_statement -> . basic_statement
    (70) unconditional_statement -> . compound_statement
    (71) unconditional_statement -> . block
    (104) conditional_statement -> . if_statement
    (105) conditional_statement -> . if_statement ELSE statement
    (106) conditional_statement -> . if_clause for_statement
    (107) conditional_statement -> . label COLON conditional_statement
    (110) for_statement -> . for_clause statement
    (111) for_statement -> . label COLON for_statement
    (18) local_or_own_type -> . type
    (19) local_or_own_type -> . TOWN type
    (20) type -> . TREAL
    (21) type -> . TINTEGER
    (22) type -> . TBOOLEAN
    (72) basic_statement -> . unlabelled_basic_statement
    (73) basic_statement -> . label COLON basic_statement
    (8) compound_statement -> . unlabelled_compound
    (9) compound_statement -> . label COLON compound_statement
    (3) block -> . unlabelled_block
    (4) block -> . TLABEL COLON block
    (108) if_statement -> . if_clause unconditional_statement
    (109) if_clause -> . IF boolean_expression THEN
    (74) label -> . IDENTIFIER
    (75) label -> . unsigned_integer
    (112) for_clause -> . FOR variable ASSIGNMENT for_list DO
    (76) unlabelled_basic_statement -> . assignment_statement
    (77) unlabelled_basic_statement -> . go_to_statement
    (78) unlabelled_basic_statement -> . procedure_statement
    (10) unlabelled_compound -> . BEGIN compound_tail
    (5) unlabelled_block -> . block_head SEMICOLON compound_tail
    (146) unsigned_integer -> . DIGIT
    (147) unsigned_integer -> . unsigned_integer DIGIT
    (79) assignment_statement -> . left_part_list arithmetic_expression
    (80) assignment_statement -> . left_part_list boolean_expression
    (85) go_to_statement -> . GOTO designational_expression
    (92) procedure_statement -> . procedure_identifier actual_parameter_part
    (6) block_head -> . BEGIN declaration
    (7) block_head -> . block_head SEMICOLON declaration
    (81) left_part_list -> . left_part
    (82) left_part_list -> . left_part_list left_part
    (44) procedure_identifier -> . IDENTIFIER
    (83) left_part -> . variable ASSIGNMENT
    (84) left_part -> . procedure_identifier ASSIGNMENT
    (172) variable -> . simple_variable
    (173) variable -> . subscripted_variable
    (174) simple_variable -> . variable_identifier
    (176) subscripted_variable -> . array_identifier LBBRACKET subscript_list RBBRACKET
    (175) variable_identifier -> . IDENTIFIER
    (31) array_identifier -> . IDENTIFIER

    TARRAY          shift and go to state 32
    SWITCH          shift and go to state 27
    PROCEDURE       shift and go to state 44
    TOWN            shift and go to state 46
    TREAL           shift and go to state 15
    TINTEGER        shift and go to state 18
    TBOOLEAN        shift and go to state 26
    TLABEL          shift and go to state 4
    IF              shift and go to state 45
    IDENTIFIER      shift and go to state 47
    FOR             shift and go to state 37
    BEGIN           shift and go to state 1
    DIGIT           shift and go to state 6
    GOTO            shift and go to state 20

    subscripted_variable           shift and go to state 13
    procedure_identifier           shift and go to state 21
    unlabelled_compound            shift and go to state 2
    array_identifier               shift and go to state 14
    unsigned_integer               shift and go to state 9
    if_clause                      shift and go to state 16
    type_declaration               shift and go to state 17
    block_head                     shift and go to state 10
    label                          shift and go to state 19
    left_part                      shift and go to state 34
    left_part_list                 shift and go to state 40
    compound_statement             shift and go to state 22
    assignment_statement           shift and go to state 23
    procedure_statement            shift and go to state 24
    conditional_statement          shift and go to state 25
    statement                      shift and go to state 29
    switch_declaration             shift and go to state 39
    if_statement                   shift and go to state 30
    type                           shift and go to state 31
    basic_statement                shift and go to state 33
    for_statement                  shift and go to state 35
    compound_tail                  shift and go to state 36
    go_to_statement                shift and go to state 38
    variable_identifier            shift and go to state 41
    declaration                    shift and go to state 42
    variable                       shift and go to state 43
    unconditional_statement        shift and go to state 28
    procedure_declaration          shift and go to state 48
    unlabelled_block               shift and go to state 5
    simple_variable                shift and go to state 49
    unlabelled_basic_statement     shift and go to state 50
    local_or_own_type              shift and go to state 51
    for_clause                     shift and go to state 52
    array_declaration              shift and go to state 53
    block                          shift and go to state 54

state 2

    (8) compound_statement -> unlabelled_compound .

    SEMICOLON       reduce using rule 8 (compound_statement -> unlabelled_compound .)
    END             reduce using rule 8 (compound_statement -> unlabelled_compound .)
    $end            reduce using rule 8 (compound_statement -> unlabelled_compound .)
    ELSE            reduce using rule 8 (compound_statement -> unlabelled_compound .)


state 3

    (2) program -> compound_statement .

    $end            reduce using rule 2 (program -> compound_statement .)


state 4

    (4) block -> TLABEL . COLON block

    COLON           shift and go to state 55


state 5

    (3) block -> unlabelled_block .

    END             reduce using rule 3 (block -> unlabelled_block .)
    SEMICOLON       reduce using rule 3 (block -> unlabelled_block .)
    $end            reduce using rule 3 (block -> unlabelled_block .)
    ELSE            reduce using rule 3 (block -> unlabelled_block .)


state 6

    (146) unsigned_integer -> DIGIT .

    DIGIT           reduce using rule 146 (unsigned_integer -> DIGIT .)
    DOT             reduce using rule 146 (unsigned_integer -> DIGIT .)
    EREAL           reduce using rule 146 (unsigned_integer -> DIGIT .)
    POWER           reduce using rule 146 (unsigned_integer -> DIGIT .)
    TIMES           reduce using rule 146 (unsigned_integer -> DIGIT .)
    DIV             reduce using rule 146 (unsigned_integer -> DIGIT .)
    MOD             reduce using rule 146 (unsigned_integer -> DIGIT .)
    PLUS            reduce using rule 146 (unsigned_integer -> DIGIT .)
    MINUS           reduce using rule 146 (unsigned_integer -> DIGIT .)
    COLON           reduce using rule 146 (unsigned_integer -> DIGIT .)
    UNTIL           reduce using rule 146 (unsigned_integer -> DIGIT .)
    LESS            reduce using rule 146 (unsigned_integer -> DIGIT .)
    NOTGREATER      reduce using rule 146 (unsigned_integer -> DIGIT .)
    EQUAL           reduce using rule 146 (unsigned_integer -> DIGIT .)
    NOTLESS         reduce using rule 146 (unsigned_integer -> DIGIT .)
    GREATER         reduce using rule 146 (unsigned_integer -> DIGIT .)
    NOTEQUAL        reduce using rule 146 (unsigned_integer -> DIGIT .)
    RCBRACKET       reduce using rule 146 (unsigned_integer -> DIGIT .)
    END             reduce using rule 146 (unsigned_integer -> DIGIT .)
    SEMICOLON       reduce using rule 146 (unsigned_integer -> DIGIT .)
    ELSE            reduce using rule 146 (unsigned_integer -> DIGIT .)
    RBBRACKET       reduce using rule 146 (unsigned_integer -> DIGIT .)
    COMMA           reduce using rule 146 (unsigned_integer -> DIGIT .)
    STEP            reduce using rule 146 (unsigned_integer -> DIGIT .)
    WHILE           reduce using rule 146 (unsigned_integer -> DIGIT .)
    DO              reduce using rule 146 (unsigned_integer -> DIGIT .)
    AND             reduce using rule 146 (unsigned_integer -> DIGIT .)
    OR              reduce using rule 146 (unsigned_integer -> DIGIT .)
    IMPL            reduce using rule 146 (unsigned_integer -> DIGIT .)
    EQUIV           reduce using rule 146 (unsigned_integer -> DIGIT .)
    THEN            reduce using rule 146 (unsigned_integer -> DIGIT .)


state 7

    (9) compound_statement -> label . COLON compound_statement

    COLON           shift and go to state 56


state 8

    (0) S' -> program .



state 9

    (75) label -> unsigned_integer .
    (147) unsigned_integer -> unsigned_integer . DIGIT

    COLON           reduce using rule 75 (label -> unsigned_integer .)
    COMMA           reduce using rule 75 (label -> unsigned_integer .)
    SEMICOLON       reduce using rule 75 (label -> unsigned_integer .)
    END             reduce using rule 75 (label -> unsigned_integer .)
    ELSE            reduce using rule 75 (label -> unsigned_integer .)
    RCBRACKET       reduce using rule 75 (label -> unsigned_integer .)
    DIGIT           shift and go to state 57


state 10

    (5) unlabelled_block -> block_head . SEMICOLON compound_tail
    (7) block_head -> block_head . SEMICOLON declaration

    SEMICOLON       shift and go to state 58


state 11

    (74) label -> IDENTIFIER .

    COLON           reduce using rule 74 (label -> IDENTIFIER .)


state 12

    (1) program -> block .

    $end            reduce using rule 1 (program -> block .)


state 13

    (173) variable -> subscripted_variable .

    POWER           reduce using rule 173 (variable -> subscripted_variable .)
    TIMES           reduce using rule 173 (variable -> subscripted_variable .)
    DIV             reduce using rule 173 (variable -> subscripted_variable .)
    MOD             reduce using rule 173 (variable -> subscripted_variable .)
    ELSE            reduce using rule 173 (variable -> subscripted_variable .)
    PLUS            reduce using rule 173 (variable -> subscripted_variable .)
    MINUS           reduce using rule 173 (variable -> subscripted_variable .)
    LESS            reduce using rule 173 (variable -> subscripted_variable .)
    NOTGREATER      reduce using rule 173 (variable -> subscripted_variable .)
    EQUAL           reduce using rule 173 (variable -> subscripted_variable .)
    NOTLESS         reduce using rule 173 (variable -> subscripted_variable .)
    GREATER         reduce using rule 173 (variable -> subscripted_variable .)
    NOTEQUAL        reduce using rule 173 (variable -> subscripted_variable .)
    AND             reduce using rule 173 (variable -> subscripted_variable .)
    OR              reduce using rule 173 (variable -> subscripted_variable .)
    IMPL            reduce using rule 173 (variable -> subscripted_variable .)
    EQUIV           reduce using rule 173 (variable -> subscripted_variable .)
    COLON           reduce using rule 173 (variable -> subscripted_variable .)
    ASSIGNMENT      reduce using rule 173 (variable -> subscripted_variable .)
    END             reduce using rule 173 (variable -> subscripted_variable .)
    SEMICOLON       reduce using rule 173 (variable -> subscripted_variable .)
    THEN            reduce using rule 173 (variable -> subscripted_variable .)
    RCBRACKET       reduce using rule 173 (variable -> subscripted_variable .)
    COMMA           reduce using rule 173 (variable -> subscripted_variable .)
    DO              reduce using rule 173 (variable -> subscripted_variable .)
    RBBRACKET       reduce using rule 173 (variable -> subscripted_variable .)
    STEP            reduce using rule 173 (variable -> subscripted_variable .)
    WHILE           reduce using rule 173 (variable -> subscripted_variable .)
    UNTIL           reduce using rule 173 (variable -> subscripted_variable .)


state 14

    (176) subscripted_variable -> array_identifier . LBBRACKET subscript_list RBBRACKET

    LBBRACKET       shift and go to state 59


state 15

    (20) type -> TREAL .

    TARRAY          reduce using rule 20 (type -> TREAL .)
    PROCEDURE       reduce using rule 20 (type -> TREAL .)
    IDENTIFIER      reduce using rule 20 (type -> TREAL .)


state 16

    (106) conditional_statement -> if_clause . for_statement
    (108) if_statement -> if_clause . unconditional_statement
    (110) for_statement -> . for_clause statement
    (111) for_statement -> . label COLON for_statement
    (69) unconditional_statement -> . basic_statement
    (70) unconditional_statement -> . compound_statement
    (71) unconditional_statement -> . block
    (112) for_clause -> . FOR variable ASSIGNMENT for_list DO
    (74) label -> . IDENTIFIER
    (75) label -> . unsigned_integer
    (72) basic_statement -> . unlabelled_basic_statement
    (73) basic_statement -> . label COLON basic_statement
    (8) compound_statement -> . unlabelled_compound
    (9) compound_statement -> . label COLON compound_statement
    (3) block -> . unlabelled_block
    (4) block -> . TLABEL COLON block
    (146) unsigned_integer -> . DIGIT
    (147) unsigned_integer -> . unsigned_integer DIGIT
    (76) unlabelled_basic_statement -> . assignment_statement
    (77) unlabelled_basic_statement -> . go_to_statement
    (78) unlabelled_basic_statement -> . procedure_statement
    (10) unlabelled_compound -> . BEGIN compound_tail
    (5) unlabelled_block -> . block_head SEMICOLON compound_tail
    (79) assignment_statement -> . left_part_list arithmetic_expression
    (80) assignment_statement -> . left_part_list boolean_expression
    (85) go_to_statement -> . GOTO designational_expression
    (92) procedure_statement -> . procedure_identifier actual_parameter_part
    (6) block_head -> . BEGIN declaration
    (7) block_head -> . block_head SEMICOLON declaration
    (81) left_part_list -> . left_part
    (82) left_part_list -> . left_part_list left_part
    (44) procedure_identifier -> . IDENTIFIER
    (83) left_part -> . variable ASSIGNMENT
    (84) left_part -> . procedure_identifier ASSIGNMENT
    (172) variable -> . simple_variable
    (173) variable -> . subscripted_variable
    (174) simple_variable -> . variable_identifier
    (176) subscripted_variable -> . array_identifier LBBRACKET subscript_list RBBRACKET
    (175) variable_identifier -> . IDENTIFIER
    (31) array_identifier -> . IDENTIFIER

    FOR             shift and go to state 37
    IDENTIFIER      shift and go to state 47
    TLABEL          shift and go to state 4
    DIGIT           shift and go to state 6
    BEGIN           shift and go to state 1
    GOTO            shift and go to state 20

    subscripted_variable           shift and go to state 13
    unlabelled_compound            shift and go to state 2
    array_identifier               shift and go to state 14
    block_head                     shift and go to state 10
    left_part                      shift and go to state 34
    left_part_list                 shift and go to state 40
    compound_statement             shift and go to state 22
    assignment_statement           shift and go to state 23
    procedure_statement            shift and go to state 24
    label                          shift and go to state 60
    for_clause                     shift and go to state 52
    for_statement                  shift and go to state 61
    go_to_statement                shift and go to state 38
    variable_identifier            shift and go to state 41
    variable                       shift and go to state 43
    unconditional_statement        shift and go to state 62
    unlabelled_block               shift and go to state 5
    procedure_identifier           shift and go to state 21
    simple_variable                shift and go to state 49
    unlabelled_basic_statement     shift and go to state 50
    unsigned_integer               shift and go to state 9
    basic_statement                shift and go to state 33
    block                          shift and go to state 54

state 17

    (13) declaration -> type_declaration .

    SEMICOLON       reduce using rule 13 (declaration -> type_declaration .)


state 18

    (21) type -> TINTEGER .

    TARRAY          reduce using rule 21 (type -> TINTEGER .)
    PROCEDURE       reduce using rule 21 (type -> TINTEGER .)
    IDENTIFIER      reduce using rule 21 (type -> TINTEGER .)


state 19

    (107) conditional_statement -> label . COLON conditional_statement
    (111) for_statement -> label . COLON for_statement
    (73) basic_statement -> label . COLON basic_statement
    (9) compound_statement -> label . COLON compound_statement

    COLON           shift and go to state 63


state 20

    (85) go_to_statement -> GOTO . designational_expression
    (86) designational_expression -> . simple_designational_expression
    (87) designational_expression -> . if_clause simple_designational_expression ELSE designational_expression
    (88) simple_designational_expression -> . label
    (89) simple_designational_expression -> . switch_designator
    (90) simple_designational_expression -> . LCBRACKET designational_expression RCBRACKET
    (109) if_clause -> . IF boolean_expression THEN
    (74) label -> . IDENTIFIER
    (75) label -> . unsigned_integer
    (91) switch_designator -> . switch_identifier LBBRACKET subscript_expression RBBRACKET
    (146) unsigned_integer -> . DIGIT
    (147) unsigned_integer -> . unsigned_integer DIGIT
    (38) switch_identifier -> . IDENTIFIER

    LCBRACKET       shift and go to state 69
    IF              shift and go to state 45
    IDENTIFIER      shift and go to state 70
    DIGIT           shift and go to state 6

    designational_expression       shift and go to state 64
    simple_designational_expression shift and go to state 71
    switch_designator              shift and go to state 65
    if_clause                      shift and go to state 66
    label                          shift and go to state 67
    switch_identifier              shift and go to state 68
    unsigned_integer               shift and go to state 9

state 21

    (92) procedure_statement -> procedure_identifier . actual_parameter_part
    (84) left_part -> procedure_identifier . ASSIGNMENT
    (93) actual_parameter_part -> . LCBRACKET RCBRACKET
    (94) actual_parameter_part -> . LCBRACKET actual_parameter_list RCBRACKET

    ASSIGNMENT      shift and go to state 72
    LCBRACKET       shift and go to state 73

    actual_parameter_part          shift and go to state 74

state 22

    (70) unconditional_statement -> compound_statement .

    SEMICOLON       reduce using rule 70 (unconditional_statement -> compound_statement .)
    END             reduce using rule 70 (unconditional_statement -> compound_statement .)
    ELSE            reduce using rule 70 (unconditional_statement -> compound_statement .)


state 23

    (76) unlabelled_basic_statement -> assignment_statement .

    END             reduce using rule 76 (unlabelled_basic_statement -> assignment_statement .)
    SEMICOLON       reduce using rule 76 (unlabelled_basic_statement -> assignment_statement .)
    ELSE            reduce using rule 76 (unlabelled_basic_statement -> assignment_statement .)


state 24

    (78) unlabelled_basic_statement -> procedure_statement .

    END             reduce using rule 78 (unlabelled_basic_statement -> procedure_statement .)
    SEMICOLON       reduce using rule 78 (unlabelled_basic_statement -> procedure_statement .)
    ELSE            reduce using rule 78 (unlabelled_basic_statement -> procedure_statement .)


state 25

    (67) statement -> conditional_statement .

    END             reduce using rule 67 (statement -> conditional_statement .)
    SEMICOLON       reduce using rule 67 (statement -> conditional_statement .)


state 26

    (22) type -> TBOOLEAN .

    TARRAY          reduce using rule 22 (type -> TBOOLEAN .)
    PROCEDURE       reduce using rule 22 (type -> TBOOLEAN .)
    IDENTIFIER      reduce using rule 22 (type -> TBOOLEAN .)


state 27

    (37) switch_declaration -> SWITCH . switch_identifier ASSIGNMENT switch_list
    (38) switch_identifier -> . IDENTIFIER

    IDENTIFIER      shift and go to state 75

    switch_identifier              shift and go to state 76

state 28

    (66) statement -> unconditional_statement .

    END             reduce using rule 66 (statement -> unconditional_statement .)
    SEMICOLON       reduce using rule 66 (statement -> unconditional_statement .)


state 29

    (11) compound_tail -> statement . END
    (12) compound_tail -> statement . SEMICOLON compound_tail

    END             shift and go to state 77
    SEMICOLON       shift and go to state 78


state 30

    (104) conditional_statement -> if_statement .
    (105) conditional_statement -> if_statement . ELSE statement

    END             reduce using rule 104 (conditional_statement -> if_statement .)
    SEMICOLON       reduce using rule 104 (conditional_statement -> if_statement .)
    ELSE            shift and go to state 79


state 31

    (42) procedure_declaration -> type . PROCEDURE procedure_heading procedure_body
    (18) local_or_own_type -> type .

    PROCEDURE       shift and go to state 80
    TARRAY          reduce using rule 18 (local_or_own_type -> type .)
    IDENTIFIER      reduce using rule 18 (local_or_own_type -> type .)


state 32

    (25) array_declaration -> TARRAY . array_list
    (27) array_list -> . array_segment
    (28) array_list -> . array_list COMMA array_segment
    (29) array_segment -> . array_identifier LBBRACKET bound_pair_list RBBRACKET
    (30) array_segment -> . array_identifier COMMA array_segment
    (31) array_identifier -> . IDENTIFIER

    IDENTIFIER      shift and go to state 83

    array_segment                  shift and go to state 81
    array_list                     shift and go to state 84
    array_identifier               shift and go to state 82

state 33

    (69) unconditional_statement -> basic_statement .

    SEMICOLON       reduce using rule 69 (unconditional_statement -> basic_statement .)
    END             reduce using rule 69 (unconditional_statement -> basic_statement .)
    ELSE            reduce using rule 69 (unconditional_statement -> basic_statement .)


state 34

    (81) left_part_list -> left_part .

    IF              reduce using rule 81 (left_part_list -> left_part .)
    IDENTIFIER      reduce using rule 81 (left_part_list -> left_part .)
    PLUS            reduce using rule 81 (left_part_list -> left_part .)
    MINUS           reduce using rule 81 (left_part_list -> left_part .)
    LCBRACKET       reduce using rule 81 (left_part_list -> left_part .)
    NOT             reduce using rule 81 (left_part_list -> left_part .)
    EREAL           reduce using rule 81 (left_part_list -> left_part .)
    DIGIT           reduce using rule 81 (left_part_list -> left_part .)
    DOT             reduce using rule 81 (left_part_list -> left_part .)
    TRUE            reduce using rule 81 (left_part_list -> left_part .)
    FALSE           reduce using rule 81 (left_part_list -> left_part .)


state 35

    (68) statement -> for_statement .

    END             reduce using rule 68 (statement -> for_statement .)
    SEMICOLON       reduce using rule 68 (statement -> for_statement .)


state 36

    (10) unlabelled_compound -> BEGIN compound_tail .

    SEMICOLON       reduce using rule 10 (unlabelled_compound -> BEGIN compound_tail .)
    $end            reduce using rule 10 (unlabelled_compound -> BEGIN compound_tail .)
    END             reduce using rule 10 (unlabelled_compound -> BEGIN compound_tail .)
    ELSE            reduce using rule 10 (unlabelled_compound -> BEGIN compound_tail .)


state 37

    (112) for_clause -> FOR . variable ASSIGNMENT for_list DO
    (172) variable -> . simple_variable
    (173) variable -> . subscripted_variable
    (174) simple_variable -> . variable_identifier
    (176) subscripted_variable -> . array_identifier LBBRACKET subscript_list RBBRACKET
    (175) variable_identifier -> . IDENTIFIER
    (31) array_identifier -> . IDENTIFIER

    IDENTIFIER      shift and go to state 86

    subscripted_variable           shift and go to state 13
    simple_variable                shift and go to state 49
    variable_identifier            shift and go to state 41
    array_identifier               shift and go to state 14
    variable                       shift and go to state 85

state 38

    (77) unlabelled_basic_statement -> go_to_statement .

    END             reduce using rule 77 (unlabelled_basic_statement -> go_to_statement .)
    SEMICOLON       reduce using rule 77 (unlabelled_basic_statement -> go_to_statement .)
    ELSE            reduce using rule 77 (unlabelled_basic_statement -> go_to_statement .)


state 39

    (15) declaration -> switch_declaration .

    SEMICOLON       reduce using rule 15 (declaration -> switch_declaration .)


state 40

    (79) assignment_statement -> left_part_list . arithmetic_expression
    (80) assignment_statement -> left_part_list . boolean_expression
    (82) left_part_list -> left_part_list . left_part
    (121) arithmetic_expression -> . simple_arithmetic_expression
    (122) arithmetic_expression -> . if_clause simple_arithmetic_expression ELSE arithmetic_expression
    (153) boolean_expression -> . simple_boolean
    (154) boolean_expression -> . if_clause simple_boolean ELSE boolean_expression
    (83) left_part -> . variable ASSIGNMENT
    (84) left_part -> . procedure_identifier ASSIGNMENT
    (123) simple_arithmetic_expression -> . term
    (124) simple_arithmetic_expression -> . adding_operator term
    (125) simple_arithmetic_expression -> . simple_arithmetic_expression adding_operator term
    (109) if_clause -> . IF boolean_expression THEN
    (155) simple_boolean -> . implication
    (156) simple_boolean -> . simple_boolean EQUIV implication
    (172) variable -> . simple_variable
    (173) variable -> . subscripted_variable
    (44) procedure_identifier -> . IDENTIFIER
    (128) term -> . factor
    (129) term -> . term multiplying_operator factor
    (126) adding_operator -> . PLUS
    (127) adding_operator -> . MINUS
    (157) implication -> . boolean_term
    (158) implication -> . implication IMPL boolean_term
    (174) simple_variable -> . variable_identifier
    (176) subscripted_variable -> . array_identifier LBBRACKET subscript_list RBBRACKET
    (133) factor -> . primary
    (134) factor -> . factor
    (135) factor -> . factor POWER primary
    (159) boolean_term -> . boolean_factor
    (160) boolean_term -> . boolean_term OR boolean_factor
    (175) variable_identifier -> . IDENTIFIER
    (31) array_identifier -> . IDENTIFIER
    (136) primary -> . unsigned_number
    (137) primary -> . variable
    (138) primary -> . function_designator
    (139) primary -> . LCBRACKET arithmetic_expression RCBRACKET
    (161) boolean_factor -> . boolean_secondary
    (162) boolean_factor -> . boolean_factor AND boolean_secondary
    (140) unsigned_number -> . decimal_number
    (141) unsigned_number -> . exponential_part
    (142) unsigned_number -> . decimal_number exponential_part
    (171) function_designator -> . procedure_identifier actual_parameter_part
    (163) boolean_secondary -> . boolean_primary
    (164) boolean_secondary -> . NOT boolean_primary
    (143) decimal_number -> . unsigned_integer
    (144) decimal_number -> . decimal_fraction
    (145) decimal_number -> . unsigned_integer decimal_fraction
    (149) exponential_part -> . EREAL integer
    (165) boolean_primary -> . logical_value
    (166) boolean_primary -> . variable
    (167) boolean_primary -> . function_designator
    (168) boolean_primary -> . relation
    (169) boolean_primary -> . LCBRACKET boolean_expression RCBRACKET
    (146) unsigned_integer -> . DIGIT
    (147) unsigned_integer -> . unsigned_integer DIGIT
    (148) decimal_fraction -> . DOT unsigned_integer
    (183) logical_value -> . TRUE
    (184) logical_value -> . FALSE
    (170) relation -> . simple_arithmetic_expression relational_operator simple_arithmetic_expression

    IF              shift and go to state 45
    IDENTIFIER      shift and go to state 106
    PLUS            shift and go to state 102
    MINUS           shift and go to state 94
    LCBRACKET       shift and go to state 116
    NOT             shift and go to state 118
    EREAL           shift and go to state 115
    DIGIT           shift and go to state 6
    DOT             shift and go to state 95
    TRUE            shift and go to state 93
    FALSE           shift and go to state 100

    boolean_primary                shift and go to state 99
    procedure_identifier           shift and go to state 87
    primary                        shift and go to state 98
    if_clause                      shift and go to state 89
    variable                       shift and go to state 111
    relation                       shift and go to state 91
    left_part                      shift and go to state 96
    simple_boolean                 shift and go to state 97
    boolean_secondary              shift and go to state 101
    unsigned_number                shift and go to state 105
    decimal_fraction               shift and go to state 103
    factor                         shift and go to state 104
    simple_arithmetic_expression   shift and go to state 107
    arithmetic_expression          shift and go to state 108
    logical_value                  shift and go to state 109
    decimal_number                 shift and go to state 112
    boolean_term                   shift and go to state 88
    variable_identifier            shift and go to state 41
    function_designator            shift and go to state 110
    array_identifier               shift and go to state 14
    boolean_factor                 shift and go to state 90
    exponential_part               shift and go to state 92
    term                           shift and go to state 113
    boolean_expression             shift and go to state 114
    subscripted_variable           shift and go to state 13
    simple_variable                shift and go to state 49
    adding_operator                shift and go to state 117
    implication                    shift and go to state 119
    unsigned_integer               shift and go to state 120

state 41

    (174) simple_variable -> variable_identifier .

    ASSIGNMENT      reduce using rule 174 (simple_variable -> variable_identifier .)
    POWER           reduce using rule 174 (simple_variable -> variable_identifier .)
    TIMES           reduce using rule 174 (simple_variable -> variable_identifier .)
    DIV             reduce using rule 174 (simple_variable -> variable_identifier .)
    MOD             reduce using rule 174 (simple_variable -> variable_identifier .)
    PLUS            reduce using rule 174 (simple_variable -> variable_identifier .)
    MINUS           reduce using rule 174 (simple_variable -> variable_identifier .)
    LESS            reduce using rule 174 (simple_variable -> variable_identifier .)
    NOTGREATER      reduce using rule 174 (simple_variable -> variable_identifier .)
    EQUAL           reduce using rule 174 (simple_variable -> variable_identifier .)
    NOTLESS         reduce using rule 174 (simple_variable -> variable_identifier .)
    GREATER         reduce using rule 174 (simple_variable -> variable_identifier .)
    NOTEQUAL        reduce using rule 174 (simple_variable -> variable_identifier .)
    END             reduce using rule 174 (simple_variable -> variable_identifier .)
    SEMICOLON       reduce using rule 174 (simple_variable -> variable_identifier .)
    ELSE            reduce using rule 174 (simple_variable -> variable_identifier .)
    RBBRACKET       reduce using rule 174 (simple_variable -> variable_identifier .)
    COMMA           reduce using rule 174 (simple_variable -> variable_identifier .)
    RCBRACKET       reduce using rule 174 (simple_variable -> variable_identifier .)
    COLON           reduce using rule 174 (simple_variable -> variable_identifier .)
    STEP            reduce using rule 174 (simple_variable -> variable_identifier .)
    WHILE           reduce using rule 174 (simple_variable -> variable_identifier .)
    DO              reduce using rule 174 (simple_variable -> variable_identifier .)
    AND             reduce using rule 174 (simple_variable -> variable_identifier .)
    OR              reduce using rule 174 (simple_variable -> variable_identifier .)
    IMPL            reduce using rule 174 (simple_variable -> variable_identifier .)
    EQUIV           reduce using rule 174 (simple_variable -> variable_identifier .)
    THEN            reduce using rule 174 (simple_variable -> variable_identifier .)
    UNTIL           reduce using rule 174 (simple_variable -> variable_identifier .)


state 42

    (6) block_head -> BEGIN declaration .

    SEMICOLON       reduce using rule 6 (block_head -> BEGIN declaration .)


state 43

    (83) left_part -> variable . ASSIGNMENT

    ASSIGNMENT      shift and go to state 121


state 44

    (41) procedure_declaration -> PROCEDURE . procedure_heading procedure_body
    (43) procedure_heading -> . procedure_identifier formal_parameter_part SEMICOLON value_part specification_part
    (44) procedure_identifier -> . IDENTIFIER

    IDENTIFIER      shift and go to state 124

    procedure_heading              shift and go to state 122
    procedure_identifier           shift and go to state 123

state 45

    (109) if_clause -> IF . boolean_expression THEN
    (153) boolean_expression -> . simple_boolean
    (154) boolean_expression -> . if_clause simple_boolean ELSE boolean_expression
    (155) simple_boolean -> . implication
    (156) simple_boolean -> . simple_boolean EQUIV implication
    (109) if_clause -> . IF boolean_expression THEN
    (157) implication -> . boolean_term
    (158) implication -> . implication IMPL boolean_term
    (159) boolean_term -> . boolean_factor
    (160) boolean_term -> . boolean_term OR boolean_factor
    (161) boolean_factor -> . boolean_secondary
    (162) boolean_factor -> . boolean_factor AND boolean_secondary
    (163) boolean_secondary -> . boolean_primary
    (164) boolean_secondary -> . NOT boolean_primary
    (165) boolean_primary -> . logical_value
    (166) boolean_primary -> . variable
    (167) boolean_primary -> . function_designator
    (168) boolean_primary -> . relation
    (169) boolean_primary -> . LCBRACKET boolean_expression RCBRACKET
    (183) logical_value -> . TRUE
    (184) logical_value -> . FALSE
    (172) variable -> . simple_variable
    (173) variable -> . subscripted_variable
    (171) function_designator -> . procedure_identifier actual_parameter_part
    (170) relation -> . simple_arithmetic_expression relational_operator simple_arithmetic_expression
    (174) simple_variable -> . variable_identifier
    (176) subscripted_variable -> . array_identifier LBBRACKET subscript_list RBBRACKET
    (44) procedure_identifier -> . IDENTIFIER
    (123) simple_arithmetic_expression -> . term
    (124) simple_arithmetic_expression -> . adding_operator term
    (125) simple_arithmetic_expression -> . simple_arithmetic_expression adding_operator term
    (175) variable_identifier -> . IDENTIFIER
    (31) array_identifier -> . IDENTIFIER
    (128) term -> . factor
    (129) term -> . term multiplying_operator factor
    (126) adding_operator -> . PLUS
    (127) adding_operator -> . MINUS
    (133) factor -> . primary
    (134) factor -> . factor
    (135) factor -> . factor POWER primary
    (136) primary -> . unsigned_number
    (137) primary -> . variable
    (138) primary -> . function_designator
    (139) primary -> . LCBRACKET arithmetic_expression RCBRACKET
    (140) unsigned_number -> . decimal_number
    (141) unsigned_number -> . exponential_part
    (142) unsigned_number -> . decimal_number exponential_part
    (143) decimal_number -> . unsigned_integer
    (144) decimal_number -> . decimal_fraction
    (145) decimal_number -> . unsigned_integer decimal_fraction
    (149) exponential_part -> . EREAL integer
    (146) unsigned_integer -> . DIGIT
    (147) unsigned_integer -> . unsigned_integer DIGIT
    (148) decimal_fraction -> . DOT unsigned_integer

    IF              shift and go to state 45
    NOT             shift and go to state 118
    LCBRACKET       shift and go to state 127
    TRUE            shift and go to state 93
    FALSE           shift and go to state 100
    IDENTIFIER      shift and go to state 106
    PLUS            shift and go to state 102
    MINUS           shift and go to state 94
    EREAL           shift and go to state 115
    DIGIT           shift and go to state 6
    DOT             shift and go to state 95

    subscripted_variable           shift and go to state 13
    boolean_term                   shift and go to state 88
    if_clause                      shift and go to state 126
    boolean_factor                 shift and go to state 90
    relation                       shift and go to state 91
    simple_boolean                 shift and go to state 97
    boolean_secondary              shift and go to state 101
    unsigned_number                shift and go to state 105
    decimal_fraction               shift and go to state 103
    factor                         shift and go to state 104
    simple_arithmetic_expression   shift and go to state 131
    boolean_primary                shift and go to state 99
    logical_value                  shift and go to state 109
    decimal_number                 shift and go to state 112
    primary                        shift and go to state 98
    variable_identifier            shift and go to state 41
    function_designator            shift and go to state 128
    array_identifier               shift and go to state 14
    variable                       shift and go to state 129
    exponential_part               shift and go to state 92
    term                           shift and go to state 113
    boolean_expression             shift and go to state 130
    procedure_identifier           shift and go to state 125
    simple_variable                shift and go to state 49
    adding_operator                shift and go to state 117
    implication                    shift and go to state 119
    unsigned_integer               shift and go to state 120

state 46

    (19) local_or_own_type -> TOWN . type
    (20) type -> . TREAL
    (21) type -> . TINTEGER
    (22) type -> . TBOOLEAN

    TREAL           shift and go to state 15
    TINTEGER        shift and go to state 18
    TBOOLEAN        shift and go to state 26

    type                           shift and go to state 132

state 47

    (74) label -> IDENTIFIER .
    (44) procedure_identifier -> IDENTIFIER .
    (175) variable_identifier -> IDENTIFIER .
    (31) array_identifier -> IDENTIFIER .

  ! reduce/reduce conflict for ASSIGNMENT resolved using rule 44 (procedure_identifier -> IDENTIFIER .)
    COLON           reduce using rule 74 (label -> IDENTIFIER .)
    ASSIGNMENT      reduce using rule 44 (procedure_identifier -> IDENTIFIER .)
    LCBRACKET       reduce using rule 44 (procedure_identifier -> IDENTIFIER .)
    LBBRACKET       reduce using rule 31 (array_identifier -> IDENTIFIER .)

  ! ASSIGNMENT      [ reduce using rule 175 (variable_identifier -> IDENTIFIER .) ]


state 48

    (16) declaration -> procedure_declaration .

    SEMICOLON       reduce using rule 16 (declaration -> procedure_declaration .)


state 49

    (172) variable -> simple_variable .

    POWER           reduce using rule 172 (variable -> simple_variable .)
    TIMES           reduce using rule 172 (variable -> simple_variable .)
    DIV             reduce using rule 172 (variable -> simple_variable .)
    MOD             reduce using rule 172 (variable -> simple_variable .)
    ELSE            reduce using rule 172 (variable -> simple_variable .)
    PLUS            reduce using rule 172 (variable -> simple_variable .)
    MINUS           reduce using rule 172 (variable -> simple_variable .)
    LESS            reduce using rule 172 (variable -> simple_variable .)
    NOTGREATER      reduce using rule 172 (variable -> simple_variable .)
    EQUAL           reduce using rule 172 (variable -> simple_variable .)
    NOTLESS         reduce using rule 172 (variable -> simple_variable .)
    GREATER         reduce using rule 172 (variable -> simple_variable .)
    NOTEQUAL        reduce using rule 172 (variable -> simple_variable .)
    AND             reduce using rule 172 (variable -> simple_variable .)
    OR              reduce using rule 172 (variable -> simple_variable .)
    IMPL            reduce using rule 172 (variable -> simple_variable .)
    EQUIV           reduce using rule 172 (variable -> simple_variable .)
    COLON           reduce using rule 172 (variable -> simple_variable .)
    ASSIGNMENT      reduce using rule 172 (variable -> simple_variable .)
    END             reduce using rule 172 (variable -> simple_variable .)
    SEMICOLON       reduce using rule 172 (variable -> simple_variable .)
    THEN            reduce using rule 172 (variable -> simple_variable .)
    RCBRACKET       reduce using rule 172 (variable -> simple_variable .)
    COMMA           reduce using rule 172 (variable -> simple_variable .)
    DO              reduce using rule 172 (variable -> simple_variable .)
    RBBRACKET       reduce using rule 172 (variable -> simple_variable .)
    STEP            reduce using rule 172 (variable -> simple_variable .)
    WHILE           reduce using rule 172 (variable -> simple_variable .)
    UNTIL           reduce using rule 172 (variable -> simple_variable .)


state 50

    (72) basic_statement -> unlabelled_basic_statement .

    END             reduce using rule 72 (basic_statement -> unlabelled_basic_statement .)
    SEMICOLON       reduce using rule 72 (basic_statement -> unlabelled_basic_statement .)
    ELSE            reduce using rule 72 (basic_statement -> unlabelled_basic_statement .)


state 51

    (17) type_declaration -> local_or_own_type . type_list
    (26) array_declaration -> local_or_own_type . TARRAY array_list
    (23) type_list -> . simple_variable
    (24) type_list -> . simple_variable COMMA type_list
    (174) simple_variable -> . variable_identifier
    (175) variable_identifier -> . IDENTIFIER

    TARRAY          shift and go to state 136
    IDENTIFIER      shift and go to state 135

    type_list                      shift and go to state 134
    simple_variable                shift and go to state 133
    variable_identifier            shift and go to state 41

state 52

    (110) for_statement -> for_clause . statement
    (66) statement -> . unconditional_statement
    (67) statement -> . conditional_statement
    (68) statement -> . for_statement
    (69) unconditional_statement -> . basic_statement
    (70) unconditional_statement -> . compound_statement
    (71) unconditional_statement -> . block
    (104) conditional_statement -> . if_statement
    (105) conditional_statement -> . if_statement ELSE statement
    (106) conditional_statement -> . if_clause for_statement
    (107) conditional_statement -> . label COLON conditional_statement
    (110) for_statement -> . for_clause statement
    (111) for_statement -> . label COLON for_statement
    (72) basic_statement -> . unlabelled_basic_statement
    (73) basic_statement -> . label COLON basic_statement
    (8) compound_statement -> . unlabelled_compound
    (9) compound_statement -> . label COLON compound_statement
    (3) block -> . unlabelled_block
    (4) block -> . TLABEL COLON block
    (108) if_statement -> . if_clause unconditional_statement
    (109) if_clause -> . IF boolean_expression THEN
    (74) label -> . IDENTIFIER
    (75) label -> . unsigned_integer
    (112) for_clause -> . FOR variable ASSIGNMENT for_list DO
    (76) unlabelled_basic_statement -> . assignment_statement
    (77) unlabelled_basic_statement -> . go_to_statement
    (78) unlabelled_basic_statement -> . procedure_statement
    (10) unlabelled_compound -> . BEGIN compound_tail
    (5) unlabelled_block -> . block_head SEMICOLON compound_tail
    (146) unsigned_integer -> . DIGIT
    (147) unsigned_integer -> . unsigned_integer DIGIT
    (79) assignment_statement -> . left_part_list arithmetic_expression
    (80) assignment_statement -> . left_part_list boolean_expression
    (85) go_to_statement -> . GOTO designational_expression
    (92) procedure_statement -> . procedure_identifier actual_parameter_part
    (6) block_head -> . BEGIN declaration
    (7) block_head -> . block_head SEMICOLON declaration
    (81) left_part_list -> . left_part
    (82) left_part_list -> . left_part_list left_part
    (44) procedure_identifier -> . IDENTIFIER
    (83) left_part -> . variable ASSIGNMENT
    (84) left_part -> . procedure_identifier ASSIGNMENT
    (172) variable -> . simple_variable
    (173) variable -> . subscripted_variable
    (174) simple_variable -> . variable_identifier
    (176) subscripted_variable -> . array_identifier LBBRACKET subscript_list RBBRACKET
    (175) variable_identifier -> . IDENTIFIER
    (31) array_identifier -> . IDENTIFIER

    TLABEL          shift and go to state 4
    IF              shift and go to state 45
    IDENTIFIER      shift and go to state 47
    FOR             shift and go to state 37
    BEGIN           shift and go to state 1
    DIGIT           shift and go to state 6
    GOTO            shift and go to state 20

    subscripted_variable           shift and go to state 13
    unlabelled_compound            shift and go to state 2
    array_identifier               shift and go to state 14
    if_clause                      shift and go to state 16
    block_head                     shift and go to state 10
    conditional_statement          shift and go to state 25
    left_part                      shift and go to state 34
    left_part_list                 shift and go to state 40
    compound_statement             shift and go to state 22
    assignment_statement           shift and go to state 23
    procedure_statement            shift and go to state 24
    label                          shift and go to state 19
    statement                      shift and go to state 137
    if_statement                   shift and go to state 30
    for_clause                     shift and go to state 52
    for_statement                  shift and go to state 35
    go_to_statement                shift and go to state 38
    variable_identifier            shift and go to state 41
    variable                       shift and go to state 43
    unconditional_statement        shift and go to state 28
    unlabelled_block               shift and go to state 5
    procedure_identifier           shift and go to state 21
    simple_variable                shift and go to state 49
    unlabelled_basic_statement     shift and go to state 50
    unsigned_integer               shift and go to state 9
    basic_statement                shift and go to state 33
    block                          shift and go to state 54

state 53

    (14) declaration -> array_declaration .

    SEMICOLON       reduce using rule 14 (declaration -> array_declaration .)


state 54

    (71) unconditional_statement -> block .

    SEMICOLON       reduce using rule 71 (unconditional_statement -> block .)
    END             reduce using rule 71 (unconditional_statement -> block .)
    ELSE            reduce using rule 71 (unconditional_statement -> block .)


state 55

    (4) block -> TLABEL COLON . block
    (3) block -> . unlabelled_block
    (4) block -> . TLABEL COLON block
    (5) unlabelled_block -> . block_head SEMICOLON compound_tail
    (6) block_head -> . BEGIN declaration
    (7) block_head -> . block_head SEMICOLON declaration

    TLABEL          shift and go to state 4
    BEGIN           shift and go to state 138

    unlabelled_block               shift and go to state 5
    block_head                     shift and go to state 10
    block                          shift and go to state 139

state 56

    (9) compound_statement -> label COLON . compound_statement
    (8) compound_statement -> . unlabelled_compound
    (9) compound_statement -> . label COLON compound_statement
    (10) unlabelled_compound -> . BEGIN compound_tail
    (74) label -> . IDENTIFIER
    (75) label -> . unsigned_integer
    (146) unsigned_integer -> . DIGIT
    (147) unsigned_integer -> . unsigned_integer DIGIT

    BEGIN           shift and go to state 140
    IDENTIFIER      shift and go to state 11
    DIGIT           shift and go to state 6

    compound_statement             shift and go to state 141
    unlabelled_compound            shift and go to state 2
    unsigned_integer               shift and go to state 9
    label                          shift and go to state 7

state 57

    (147) unsigned_integer -> unsigned_integer DIGIT .

    DIGIT           reduce using rule 147 (unsigned_integer -> unsigned_integer DIGIT .)
    DOT             reduce using rule 147 (unsigned_integer -> unsigned_integer DIGIT .)
    EREAL           reduce using rule 147 (unsigned_integer -> unsigned_integer DIGIT .)
    POWER           reduce using rule 147 (unsigned_integer -> unsigned_integer DIGIT .)
    TIMES           reduce using rule 147 (unsigned_integer -> unsigned_integer DIGIT .)
    DIV             reduce using rule 147 (unsigned_integer -> unsigned_integer DIGIT .)
    MOD             reduce using rule 147 (unsigned_integer -> unsigned_integer DIGIT .)
    PLUS            reduce using rule 147 (unsigned_integer -> unsigned_integer DIGIT .)
    MINUS           reduce using rule 147 (unsigned_integer -> unsigned_integer DIGIT .)
    COLON           reduce using rule 147 (unsigned_integer -> unsigned_integer DIGIT .)
    UNTIL           reduce using rule 147 (unsigned_integer -> unsigned_integer DIGIT .)
    LESS            reduce using rule 147 (unsigned_integer -> unsigned_integer DIGIT .)
    NOTGREATER      reduce using rule 147 (unsigned_integer -> unsigned_integer DIGIT .)
    EQUAL           reduce using rule 147 (unsigned_integer -> unsigned_integer DIGIT .)
    NOTLESS         reduce using rule 147 (unsigned_integer -> unsigned_integer DIGIT .)
    GREATER         reduce using rule 147 (unsigned_integer -> unsigned_integer DIGIT .)
    NOTEQUAL        reduce using rule 147 (unsigned_integer -> unsigned_integer DIGIT .)
    RCBRACKET       reduce using rule 147 (unsigned_integer -> unsigned_integer DIGIT .)
    END             reduce using rule 147 (unsigned_integer -> unsigned_integer DIGIT .)
    SEMICOLON       reduce using rule 147 (unsigned_integer -> unsigned_integer DIGIT .)
    ELSE            reduce using rule 147 (unsigned_integer -> unsigned_integer DIGIT .)
    RBBRACKET       reduce using rule 147 (unsigned_integer -> unsigned_integer DIGIT .)
    COMMA           reduce using rule 147 (unsigned_integer -> unsigned_integer DIGIT .)
    STEP            reduce using rule 147 (unsigned_integer -> unsigned_integer DIGIT .)
    WHILE           reduce using rule 147 (unsigned_integer -> unsigned_integer DIGIT .)
    DO              reduce using rule 147 (unsigned_integer -> unsigned_integer DIGIT .)
    AND             reduce using rule 147 (unsigned_integer -> unsigned_integer DIGIT .)
    OR              reduce using rule 147 (unsigned_integer -> unsigned_integer DIGIT .)
    IMPL            reduce using rule 147 (unsigned_integer -> unsigned_integer DIGIT .)
    EQUIV           reduce using rule 147 (unsigned_integer -> unsigned_integer DIGIT .)
    THEN            reduce using rule 147 (unsigned_integer -> unsigned_integer DIGIT .)


state 58

    (5) unlabelled_block -> block_head SEMICOLON . compound_tail
    (7) block_head -> block_head SEMICOLON . declaration
    (11) compound_tail -> . statement END
    (12) compound_tail -> . statement SEMICOLON compound_tail
    (13) declaration -> . type_declaration
    (14) declaration -> . array_declaration
    (15) declaration -> . switch_declaration
    (16) declaration -> . procedure_declaration
    (66) statement -> . unconditional_statement
    (67) statement -> . conditional_statement
    (68) statement -> . for_statement
    (17) type_declaration -> . local_or_own_type type_list
    (25) array_declaration -> . TARRAY array_list
    (26) array_declaration -> . local_or_own_type TARRAY array_list
    (37) switch_declaration -> . SWITCH switch_identifier ASSIGNMENT switch_list
    (41) procedure_declaration -> . PROCEDURE procedure_heading procedure_body
    (42) procedure_declaration -> . type PROCEDURE procedure_heading procedure_body
    (69) unconditional_statement -> . basic_statement
    (70) unconditional_statement -> . compound_statement
    (71) unconditional_statement -> . block
    (104) conditional_statement -> . if_statement
    (105) conditional_statement -> . if_statement ELSE statement
    (106) conditional_statement -> . if_clause for_statement
    (107) conditional_statement -> . label COLON conditional_statement
    (110) for_statement -> . for_clause statement
    (111) for_statement -> . label COLON for_statement
    (18) local_or_own_type -> . type
    (19) local_or_own_type -> . TOWN type
    (20) type -> . TREAL
    (21) type -> . TINTEGER
    (22) type -> . TBOOLEAN
    (72) basic_statement -> . unlabelled_basic_statement
    (73) basic_statement -> . label COLON basic_statement
    (8) compound_statement -> . unlabelled_compound
    (9) compound_statement -> . label COLON compound_statement
    (3) block -> . unlabelled_block
    (4) block -> . TLABEL COLON block
    (108) if_statement -> . if_clause unconditional_statement
    (109) if_clause -> . IF boolean_expression THEN
    (74) label -> . IDENTIFIER
    (75) label -> . unsigned_integer
    (112) for_clause -> . FOR variable ASSIGNMENT for_list DO
    (76) unlabelled_basic_statement -> . assignment_statement
    (77) unlabelled_basic_statement -> . go_to_statement
    (78) unlabelled_basic_statement -> . procedure_statement
    (10) unlabelled_compound -> . BEGIN compound_tail
    (5) unlabelled_block -> . block_head SEMICOLON compound_tail
    (146) unsigned_integer -> . DIGIT
    (147) unsigned_integer -> . unsigned_integer DIGIT
    (79) assignment_statement -> . left_part_list arithmetic_expression
    (80) assignment_statement -> . left_part_list boolean_expression
    (85) go_to_statement -> . GOTO designational_expression
    (92) procedure_statement -> . procedure_identifier actual_parameter_part
    (6) block_head -> . BEGIN declaration
    (7) block_head -> . block_head SEMICOLON declaration
    (81) left_part_list -> . left_part
    (82) left_part_list -> . left_part_list left_part
    (44) procedure_identifier -> . IDENTIFIER
    (83) left_part -> . variable ASSIGNMENT
    (84) left_part -> . procedure_identifier ASSIGNMENT
    (172) variable -> . simple_variable
    (173) variable -> . subscripted_variable
    (174) simple_variable -> . variable_identifier
    (176) subscripted_variable -> . array_identifier LBBRACKET subscript_list RBBRACKET
    (175) variable_identifier -> . IDENTIFIER
    (31) array_identifier -> . IDENTIFIER

    TARRAY          shift and go to state 32
    SWITCH          shift and go to state 27
    PROCEDURE       shift and go to state 44
    TOWN            shift and go to state 46
    TREAL           shift and go to state 15
    TINTEGER        shift and go to state 18
    TBOOLEAN        shift and go to state 26
    TLABEL          shift and go to state 4
    IF              shift and go to state 45
    IDENTIFIER      shift and go to state 47
    FOR             shift and go to state 37
    BEGIN           shift and go to state 1
    DIGIT           shift and go to state 6
    GOTO            shift and go to state 20

    subscripted_variable           shift and go to state 13
    procedure_identifier           shift and go to state 21
    unlabelled_compound            shift and go to state 2
    array_identifier               shift and go to state 14
    unsigned_integer               shift and go to state 9
    if_clause                      shift and go to state 16
    type_declaration               shift and go to state 17
    block_head                     shift and go to state 10
    label                          shift and go to state 19
    left_part                      shift and go to state 34
    left_part_list                 shift and go to state 40
    compound_statement             shift and go to state 22
    assignment_statement           shift and go to state 23
    procedure_statement            shift and go to state 24
    conditional_statement          shift and go to state 25
    statement                      shift and go to state 29
    switch_declaration             shift and go to state 39
    if_statement                   shift and go to state 30
    type                           shift and go to state 31
    basic_statement                shift and go to state 33
    for_statement                  shift and go to state 35
    compound_tail                  shift and go to state 142
    go_to_statement                shift and go to state 38
    variable_identifier            shift and go to state 41
    declaration                    shift and go to state 143
    variable                       shift and go to state 43
    unconditional_statement        shift and go to state 28
    procedure_declaration          shift and go to state 48
    unlabelled_block               shift and go to state 5
    simple_variable                shift and go to state 49
    unlabelled_basic_statement     shift and go to state 50
    local_or_own_type              shift and go to state 51
    for_clause                     shift and go to state 52
    array_declaration              shift and go to state 53
    block                          shift and go to state 54

state 59

    (176) subscripted_variable -> array_identifier LBBRACKET . subscript_list RBBRACKET
    (177) subscript_list -> . subscript_expression
    (178) subscript_list -> . subscript_list COMMA subscript_expression
    (179) subscript_expression -> . arithmetic_expression
    (121) arithmetic_expression -> . simple_arithmetic_expression
    (122) arithmetic_expression -> . if_clause simple_arithmetic_expression ELSE arithmetic_expression
    (123) simple_arithmetic_expression -> . term
    (124) simple_arithmetic_expression -> . adding_operator term
    (125) simple_arithmetic_expression -> . simple_arithmetic_expression adding_operator term
    (109) if_clause -> . IF boolean_expression THEN
    (128) term -> . factor
    (129) term -> . term multiplying_operator factor
    (126) adding_operator -> . PLUS
    (127) adding_operator -> . MINUS
    (133) factor -> . primary
    (134) factor -> . factor
    (135) factor -> . factor POWER primary
    (136) primary -> . unsigned_number
    (137) primary -> . variable
    (138) primary -> . function_designator
    (139) primary -> . LCBRACKET arithmetic_expression RCBRACKET
    (140) unsigned_number -> . decimal_number
    (141) unsigned_number -> . exponential_part
    (142) unsigned_number -> . decimal_number exponential_part
    (172) variable -> . simple_variable
    (173) variable -> . subscripted_variable
    (171) function_designator -> . procedure_identifier actual_parameter_part
    (143) decimal_number -> . unsigned_integer
    (144) decimal_number -> . decimal_fraction
    (145) decimal_number -> . unsigned_integer decimal_fraction
    (149) exponential_part -> . EREAL integer
    (174) simple_variable -> . variable_identifier
    (176) subscripted_variable -> . array_identifier LBBRACKET subscript_list RBBRACKET
    (44) procedure_identifier -> . IDENTIFIER
    (146) unsigned_integer -> . DIGIT
    (147) unsigned_integer -> . unsigned_integer DIGIT
    (148) decimal_fraction -> . DOT unsigned_integer
    (175) variable_identifier -> . IDENTIFIER
    (31) array_identifier -> . IDENTIFIER

    IF              shift and go to state 45
    PLUS            shift and go to state 102
    MINUS           shift and go to state 94
    LCBRACKET       shift and go to state 145
    EREAL           shift and go to state 115
    IDENTIFIER      shift and go to state 106
    DIGIT           shift and go to state 6
    DOT             shift and go to state 95

    subscripted_variable           shift and go to state 13
    primary                        shift and go to state 98
    if_clause                      shift and go to state 144
    subscript_expression           shift and go to state 146
    decimal_fraction               shift and go to state 103
    factor                         shift and go to state 104
    unsigned_number                shift and go to state 105
    simple_arithmetic_expression   shift and go to state 147
    arithmetic_expression          shift and go to state 148
    decimal_number                 shift and go to state 112
    variable_identifier            shift and go to state 41
    function_designator            shift and go to state 149
    array_identifier               shift and go to state 14
    variable                       shift and go to state 150
    exponential_part               shift and go to state 92
    term                           shift and go to state 113
    subscript_list                 shift and go to state 151
    procedure_identifier           shift and go to state 125
    simple_variable                shift and go to state 49
    adding_operator                shift and go to state 117
    unsigned_integer               shift and go to state 120

state 60

    (111) for_statement -> label . COLON for_statement
    (73) basic_statement -> label . COLON basic_statement
    (9) compound_statement -> label . COLON compound_statement

    COLON           shift and go to state 152


state 61

    (106) conditional_statement -> if_clause for_statement .

    END             reduce using rule 106 (conditional_statement -> if_clause for_statement .)
    SEMICOLON       reduce using rule 106 (conditional_statement -> if_clause for_statement .)


state 62

    (108) if_statement -> if_clause unconditional_statement .

    ELSE            reduce using rule 108 (if_statement -> if_clause unconditional_statement .)
    END             reduce using rule 108 (if_statement -> if_clause unconditional_statement .)
    SEMICOLON       reduce using rule 108 (if_statement -> if_clause unconditional_statement .)


state 63

    (107) conditional_statement -> label COLON . conditional_statement
    (111) for_statement -> label COLON . for_statement
    (73) basic_statement -> label COLON . basic_statement
    (9) compound_statement -> label COLON . compound_statement
    (104) conditional_statement -> . if_statement
    (105) conditional_statement -> . if_statement ELSE statement
    (106) conditional_statement -> . if_clause for_statement
    (107) conditional_statement -> . label COLON conditional_statement
    (110) for_statement -> . for_clause statement
    (111) for_statement -> . label COLON for_statement
    (72) basic_statement -> . unlabelled_basic_statement
    (73) basic_statement -> . label COLON basic_statement
    (8) compound_statement -> . unlabelled_compound
    (9) compound_statement -> . label COLON compound_statement
    (108) if_statement -> . if_clause unconditional_statement
    (109) if_clause -> . IF boolean_expression THEN
    (74) label -> . IDENTIFIER
    (75) label -> . unsigned_integer
    (112) for_clause -> . FOR variable ASSIGNMENT for_list DO
    (76) unlabelled_basic_statement -> . assignment_statement
    (77) unlabelled_basic_statement -> . go_to_statement
    (78) unlabelled_basic_statement -> . procedure_statement
    (10) unlabelled_compound -> . BEGIN compound_tail
    (146) unsigned_integer -> . DIGIT
    (147) unsigned_integer -> . unsigned_integer DIGIT
    (79) assignment_statement -> . left_part_list arithmetic_expression
    (80) assignment_statement -> . left_part_list boolean_expression
    (85) go_to_statement -> . GOTO designational_expression
    (92) procedure_statement -> . procedure_identifier actual_parameter_part
    (81) left_part_list -> . left_part
    (82) left_part_list -> . left_part_list left_part
    (44) procedure_identifier -> . IDENTIFIER
    (83) left_part -> . variable ASSIGNMENT
    (84) left_part -> . procedure_identifier ASSIGNMENT
    (172) variable -> . simple_variable
    (173) variable -> . subscripted_variable
    (174) simple_variable -> . variable_identifier
    (176) subscripted_variable -> . array_identifier LBBRACKET subscript_list RBBRACKET
    (175) variable_identifier -> . IDENTIFIER
    (31) array_identifier -> . IDENTIFIER

    IF              shift and go to state 45
    IDENTIFIER      shift and go to state 47
    FOR             shift and go to state 37
    BEGIN           shift and go to state 140
    DIGIT           shift and go to state 6
    GOTO            shift and go to state 20

    subscripted_variable           shift and go to state 13
    unlabelled_compound            shift and go to state 2
    if_clause                      shift and go to state 16
    conditional_statement          shift and go to state 153
    left_part                      shift and go to state 34
    left_part_list                 shift and go to state 40
    compound_statement             shift and go to state 141
    assignment_statement           shift and go to state 23
    procedure_statement            shift and go to state 24
    label                          shift and go to state 19
    if_statement                   shift and go to state 30
    basic_statement                shift and go to state 154
    for_statement                  shift and go to state 155
    go_to_statement                shift and go to state 38
    variable_identifier            shift and go to state 41
    array_identifier               shift and go to state 14
    variable                       shift and go to state 43
    procedure_identifier           shift and go to state 21
    simple_variable                shift and go to state 49
    unlabelled_basic_statement     shift and go to state 50
    for_clause                     shift and go to state 52
    unsigned_integer               shift and go to state 9

state 64

    (85) go_to_statement -> GOTO designational_expression .

    ELSE            reduce using rule 85 (go_to_statement -> GOTO designational_expression .)
    END             reduce using rule 85 (go_to_statement -> GOTO designational_expression .)
    SEMICOLON       reduce using rule 85 (go_to_statement -> GOTO designational_expression .)


state 65

    (89) simple_designational_expression -> switch_designator .

    RCBRACKET       reduce using rule 89 (simple_designational_expression -> switch_designator .)
    COMMA           reduce using rule 89 (simple_designational_expression -> switch_designator .)
    ELSE            reduce using rule 89 (simple_designational_expression -> switch_designator .)
    SEMICOLON       reduce using rule 89 (simple_designational_expression -> switch_designator .)
    END             reduce using rule 89 (simple_designational_expression -> switch_designator .)


state 66

    (87) designational_expression -> if_clause . simple_designational_expression ELSE designational_expression
    (88) simple_designational_expression -> . label
    (89) simple_designational_expression -> . switch_designator
    (90) simple_designational_expression -> . LCBRACKET designational_expression RCBRACKET
    (74) label -> . IDENTIFIER
    (75) label -> . unsigned_integer
    (91) switch_designator -> . switch_identifier LBBRACKET subscript_expression RBBRACKET
    (146) unsigned_integer -> . DIGIT
    (147) unsigned_integer -> . unsigned_integer DIGIT
    (38) switch_identifier -> . IDENTIFIER

    LCBRACKET       shift and go to state 69
    IDENTIFIER      shift and go to state 70
    DIGIT           shift and go to state 6

    simple_designational_expression shift and go to state 156
    switch_designator              shift and go to state 65
    label                          shift and go to state 67
    switch_identifier              shift and go to state 68
    unsigned_integer               shift and go to state 9

state 67

    (88) simple_designational_expression -> label .

    RCBRACKET       reduce using rule 88 (simple_designational_expression -> label .)
    COMMA           reduce using rule 88 (simple_designational_expression -> label .)
    ELSE            reduce using rule 88 (simple_designational_expression -> label .)
    SEMICOLON       reduce using rule 88 (simple_designational_expression -> label .)
    END             reduce using rule 88 (simple_designational_expression -> label .)


state 68

    (91) switch_designator -> switch_identifier . LBBRACKET subscript_expression RBBRACKET

    LBBRACKET       shift and go to state 157


state 69

    (90) simple_designational_expression -> LCBRACKET . designational_expression RCBRACKET
    (86) designational_expression -> . simple_designational_expression
    (87) designational_expression -> . if_clause simple_designational_expression ELSE designational_expression
    (88) simple_designational_expression -> . label
    (89) simple_designational_expression -> . switch_designator
    (90) simple_designational_expression -> . LCBRACKET designational_expression RCBRACKET
    (109) if_clause -> . IF boolean_expression THEN
    (74) label -> . IDENTIFIER
    (75) label -> . unsigned_integer
    (91) switch_designator -> . switch_identifier LBBRACKET subscript_expression RBBRACKET
    (146) unsigned_integer -> . DIGIT
    (147) unsigned_integer -> . unsigned_integer DIGIT
    (38) switch_identifier -> . IDENTIFIER

    LCBRACKET       shift and go to state 69
    IF              shift and go to state 45
    IDENTIFIER      shift and go to state 70
    DIGIT           shift and go to state 6

    designational_expression       shift and go to state 158
    simple_designational_expression shift and go to state 71
    switch_designator              shift and go to state 65
    if_clause                      shift and go to state 66
    label                          shift and go to state 67
    switch_identifier              shift and go to state 68
    unsigned_integer               shift and go to state 9

state 70

    (74) label -> IDENTIFIER .
    (38) switch_identifier -> IDENTIFIER .

    COMMA           reduce using rule 74 (label -> IDENTIFIER .)
    SEMICOLON       reduce using rule 74 (label -> IDENTIFIER .)
    END             reduce using rule 74 (label -> IDENTIFIER .)
    ELSE            reduce using rule 74 (label -> IDENTIFIER .)
    RCBRACKET       reduce using rule 74 (label -> IDENTIFIER .)
    LBBRACKET       reduce using rule 38 (switch_identifier -> IDENTIFIER .)


state 71

    (86) designational_expression -> simple_designational_expression .

    END             reduce using rule 86 (designational_expression -> simple_designational_expression .)
    SEMICOLON       reduce using rule 86 (designational_expression -> simple_designational_expression .)
    ELSE            reduce using rule 86 (designational_expression -> simple_designational_expression .)
    RCBRACKET       reduce using rule 86 (designational_expression -> simple_designational_expression .)
    COMMA           reduce using rule 86 (designational_expression -> simple_designational_expression .)


state 72

    (84) left_part -> procedure_identifier ASSIGNMENT .

    IF              reduce using rule 84 (left_part -> procedure_identifier ASSIGNMENT .)
    IDENTIFIER      reduce using rule 84 (left_part -> procedure_identifier ASSIGNMENT .)
    PLUS            reduce using rule 84 (left_part -> procedure_identifier ASSIGNMENT .)
    MINUS           reduce using rule 84 (left_part -> procedure_identifier ASSIGNMENT .)
    LCBRACKET       reduce using rule 84 (left_part -> procedure_identifier ASSIGNMENT .)
    NOT             reduce using rule 84 (left_part -> procedure_identifier ASSIGNMENT .)
    EREAL           reduce using rule 84 (left_part -> procedure_identifier ASSIGNMENT .)
    DIGIT           reduce using rule 84 (left_part -> procedure_identifier ASSIGNMENT .)
    DOT             reduce using rule 84 (left_part -> procedure_identifier ASSIGNMENT .)
    TRUE            reduce using rule 84 (left_part -> procedure_identifier ASSIGNMENT .)
    FALSE           reduce using rule 84 (left_part -> procedure_identifier ASSIGNMENT .)


state 73

    (93) actual_parameter_part -> LCBRACKET . RCBRACKET
    (94) actual_parameter_part -> LCBRACKET . actual_parameter_list RCBRACKET
    (95) actual_parameter_list -> . actual_parameter
    (96) actual_parameter_list -> . actual_parameter_list parameter_delimiter actual_parameter
    (99) actual_parameter -> . string
    (100) actual_parameter -> . expression
    (101) actual_parameter -> . array_identifier
    (102) actual_parameter -> . switch_identifier
    (103) actual_parameter -> . procedure_identifier
    (180) string -> . STRING
    (118) expression -> . arithmetic_expression
    (119) expression -> . boolean_expression
    (120) expression -> . designational_expression
    (31) array_identifier -> . IDENTIFIER
    (38) switch_identifier -> . IDENTIFIER
    (44) procedure_identifier -> . IDENTIFIER
    (121) arithmetic_expression -> . simple_arithmetic_expression
    (122) arithmetic_expression -> . if_clause simple_arithmetic_expression ELSE arithmetic_expression
    (153) boolean_expression -> . simple_boolean
    (154) boolean_expression -> . if_clause simple_boolean ELSE boolean_expression
    (86) designational_expression -> . simple_designational_expression
    (87) designational_expression -> . if_clause simple_designational_expression ELSE designational_expression
    (123) simple_arithmetic_expression -> . term
    (124) simple_arithmetic_expression -> . adding_operator term
    (125) simple_arithmetic_expression -> . simple_arithmetic_expression adding_operator term
    (109) if_clause -> . IF boolean_expression THEN
    (155) simple_boolean -> . implication
    (156) simple_boolean -> . simple_boolean EQUIV implication
    (88) simple_designational_expression -> . label
    (89) simple_designational_expression -> . switch_designator
    (90) simple_designational_expression -> . LCBRACKET designational_expression RCBRACKET
    (128) term -> . factor
    (129) term -> . term multiplying_operator factor
    (126) adding_operator -> . PLUS
    (127) adding_operator -> . MINUS
    (157) implication -> . boolean_term
    (158) implication -> . implication IMPL boolean_term
    (74) label -> . IDENTIFIER
    (75) label -> . unsigned_integer
    (91) switch_designator -> . switch_identifier LBBRACKET subscript_expression RBBRACKET
    (133) factor -> . primary
    (134) factor -> . factor
    (135) factor -> . factor POWER primary
    (159) boolean_term -> . boolean_factor
    (160) boolean_term -> . boolean_term OR boolean_factor
    (146) unsigned_integer -> . DIGIT
    (147) unsigned_integer -> . unsigned_integer DIGIT
    (136) primary -> . unsigned_number
    (137) primary -> . variable
    (138) primary -> . function_designator
    (139) primary -> . LCBRACKET arithmetic_expression RCBRACKET
    (161) boolean_factor -> . boolean_secondary
    (162) boolean_factor -> . boolean_factor AND boolean_secondary
    (140) unsigned_number -> . decimal_number
    (141) unsigned_number -> . exponential_part
    (142) unsigned_number -> . decimal_number exponential_part
    (172) variable -> . simple_variable
    (173) variable -> . subscripted_variable
    (171) function_designator -> . procedure_identifier actual_parameter_part
    (163) boolean_secondary -> . boolean_primary
    (164) boolean_secondary -> . NOT boolean_primary
    (143) decimal_number -> . unsigned_integer
    (144) decimal_number -> . decimal_fraction
    (145) decimal_number -> . unsigned_integer decimal_fraction
    (149) exponential_part -> . EREAL integer
    (174) simple_variable -> . variable_identifier
    (176) subscripted_variable -> . array_identifier LBBRACKET subscript_list RBBRACKET
    (165) boolean_primary -> . logical_value
    (166) boolean_primary -> . variable
    (167) boolean_primary -> . function_designator
    (168) boolean_primary -> . relation
    (169) boolean_primary -> . LCBRACKET boolean_expression RCBRACKET
    (148) decimal_fraction -> . DOT unsigned_integer
    (175) variable_identifier -> . IDENTIFIER
    (183) logical_value -> . TRUE
    (184) logical_value -> . FALSE
    (170) relation -> . simple_arithmetic_expression relational_operator simple_arithmetic_expression

    RCBRACKET       shift and go to state 162
    STRING          shift and go to state 165
    IDENTIFIER      shift and go to state 166
    IF              shift and go to state 45
    LCBRACKET       shift and go to state 170
    PLUS            shift and go to state 102
    MINUS           shift and go to state 94
    DIGIT           shift and go to state 6
    NOT             shift and go to state 118
    EREAL           shift and go to state 115
    DOT             shift and go to state 95
    TRUE            shift and go to state 93
    FALSE           shift and go to state 100

    actual_parameter_list          shift and go to state 159
    boolean_primary                shift and go to state 99
    subscripted_variable           shift and go to state 13
    boolean_term                   shift and go to state 88
    if_clause                      shift and go to state 160
    variable                       shift and go to state 161
    relation                       shift and go to state 91
    simple_designational_expression shift and go to state 71
    simple_boolean                 shift and go to state 97
    boolean_secondary              shift and go to state 101
    label                          shift and go to state 67
    actual_parameter               shift and go to state 163
    switch_identifier              shift and go to state 164
    unsigned_number                shift and go to state 105
    decimal_fraction               shift and go to state 103
    simple_arithmetic_expression   shift and go to state 107
    arithmetic_expression          shift and go to state 167
    string                         shift and go to state 168
    logical_value                  shift and go to state 109
    factor                         shift and go to state 104
    decimal_number                 shift and go to state 112
    primary                        shift and go to state 98
    variable_identifier            shift and go to state 41
    function_designator            shift and go to state 110
    array_identifier               shift and go to state 169
    boolean_factor                 shift and go to state 90
    exponential_part               shift and go to state 92
    term                           shift and go to state 113
    designational_expression       shift and go to state 171
    boolean_expression             shift and go to state 172
    procedure_identifier           shift and go to state 173
    simple_variable                shift and go to state 49
    switch_designator              shift and go to state 65
    adding_operator                shift and go to state 117
    implication                    shift and go to state 119
    expression                     shift and go to state 174
    unsigned_integer               shift and go to state 175

state 74

    (92) procedure_statement -> procedure_identifier actual_parameter_part .

    ELSE            reduce using rule 92 (procedure_statement -> procedure_identifier actual_parameter_part .)
    END             reduce using rule 92 (procedure_statement -> procedure_identifier actual_parameter_part .)
    SEMICOLON       reduce using rule 92 (procedure_statement -> procedure_identifier actual_parameter_part .)


state 75

    (38) switch_identifier -> IDENTIFIER .

    ASSIGNMENT      reduce using rule 38 (switch_identifier -> IDENTIFIER .)


state 76

    (37) switch_declaration -> SWITCH switch_identifier . ASSIGNMENT switch_list

    ASSIGNMENT      shift and go to state 176


state 77

    (11) compound_tail -> statement END .

    $end            reduce using rule 11 (compound_tail -> statement END .)
    END             reduce using rule 11 (compound_tail -> statement END .)
    SEMICOLON       reduce using rule 11 (compound_tail -> statement END .)
    ELSE            reduce using rule 11 (compound_tail -> statement END .)


state 78

    (12) compound_tail -> statement SEMICOLON . compound_tail
    (11) compound_tail -> . statement END
    (12) compound_tail -> . statement SEMICOLON compound_tail
    (66) statement -> . unconditional_statement
    (67) statement -> . conditional_statement
    (68) statement -> . for_statement
    (69) unconditional_statement -> . basic_statement
    (70) unconditional_statement -> . compound_statement
    (71) unconditional_statement -> . block
    (104) conditional_statement -> . if_statement
    (105) conditional_statement -> . if_statement ELSE statement
    (106) conditional_statement -> . if_clause for_statement
    (107) conditional_statement -> . label COLON conditional_statement
    (110) for_statement -> . for_clause statement
    (111) for_statement -> . label COLON for_statement
    (72) basic_statement -> . unlabelled_basic_statement
    (73) basic_statement -> . label COLON basic_statement
    (8) compound_statement -> . unlabelled_compound
    (9) compound_statement -> . label COLON compound_statement
    (3) block -> . unlabelled_block
    (4) block -> . TLABEL COLON block
    (108) if_statement -> . if_clause unconditional_statement
    (109) if_clause -> . IF boolean_expression THEN
    (74) label -> . IDENTIFIER
    (75) label -> . unsigned_integer
    (112) for_clause -> . FOR variable ASSIGNMENT for_list DO
    (76) unlabelled_basic_statement -> . assignment_statement
    (77) unlabelled_basic_statement -> . go_to_statement
    (78) unlabelled_basic_statement -> . procedure_statement
    (10) unlabelled_compound -> . BEGIN compound_tail
    (5) unlabelled_block -> . block_head SEMICOLON compound_tail
    (146) unsigned_integer -> . DIGIT
    (147) unsigned_integer -> . unsigned_integer DIGIT
    (79) assignment_statement -> . left_part_list arithmetic_expression
    (80) assignment_statement -> . left_part_list boolean_expression
    (85) go_to_statement -> . GOTO designational_expression
    (92) procedure_statement -> . procedure_identifier actual_parameter_part
    (6) block_head -> . BEGIN declaration
    (7) block_head -> . block_head SEMICOLON declaration
    (81) left_part_list -> . left_part
    (82) left_part_list -> . left_part_list left_part
    (44) procedure_identifier -> . IDENTIFIER
    (83) left_part -> . variable ASSIGNMENT
    (84) left_part -> . procedure_identifier ASSIGNMENT
    (172) variable -> . simple_variable
    (173) variable -> . subscripted_variable
    (174) simple_variable -> . variable_identifier
    (176) subscripted_variable -> . array_identifier LBBRACKET subscript_list RBBRACKET
    (175) variable_identifier -> . IDENTIFIER
    (31) array_identifier -> . IDENTIFIER

    TLABEL          shift and go to state 4
    IF              shift and go to state 45
    IDENTIFIER      shift and go to state 47
    FOR             shift and go to state 37
    BEGIN           shift and go to state 1
    DIGIT           shift and go to state 6
    GOTO            shift and go to state 20

    subscripted_variable           shift and go to state 13
    block                          shift and go to state 54
    unlabelled_compound            shift and go to state 2
    array_identifier               shift and go to state 14
    if_clause                      shift and go to state 16
    block_head                     shift and go to state 10
    conditional_statement          shift and go to state 25
    left_part                      shift and go to state 34
    left_part_list                 shift and go to state 40
    compound_statement             shift and go to state 22
    assignment_statement           shift and go to state 23
    procedure_statement            shift and go to state 24
    label                          shift and go to state 19
    statement                      shift and go to state 29
    if_statement                   shift and go to state 30
    basic_statement                shift and go to state 33
    for_statement                  shift and go to state 35
    compound_tail                  shift and go to state 177
    go_to_statement                shift and go to state 38
    variable_identifier            shift and go to state 41
    variable                       shift and go to state 43
    unconditional_statement        shift and go to state 28
    unlabelled_block               shift and go to state 5
    procedure_identifier           shift and go to state 21
    simple_variable                shift and go to state 49
    unlabelled_basic_statement     shift and go to state 50
    for_clause                     shift and go to state 52
    unsigned_integer               shift and go to state 9

state 79

    (105) conditional_statement -> if_statement ELSE . statement
    (66) statement -> . unconditional_statement
    (67) statement -> . conditional_statement
    (68) statement -> . for_statement
    (69) unconditional_statement -> . basic_statement
    (70) unconditional_statement -> . compound_statement
    (71) unconditional_statement -> . block
    (104) conditional_statement -> . if_statement
    (105) conditional_statement -> . if_statement ELSE statement
    (106) conditional_statement -> . if_clause for_statement
    (107) conditional_statement -> . label COLON conditional_statement
    (110) for_statement -> . for_clause statement
    (111) for_statement -> . label COLON for_statement
    (72) basic_statement -> . unlabelled_basic_statement
    (73) basic_statement -> . label COLON basic_statement
    (8) compound_statement -> . unlabelled_compound
    (9) compound_statement -> . label COLON compound_statement
    (3) block -> . unlabelled_block
    (4) block -> . TLABEL COLON block
    (108) if_statement -> . if_clause unconditional_statement
    (109) if_clause -> . IF boolean_expression THEN
    (74) label -> . IDENTIFIER
    (75) label -> . unsigned_integer
    (112) for_clause -> . FOR variable ASSIGNMENT for_list DO
    (76) unlabelled_basic_statement -> . assignment_statement
    (77) unlabelled_basic_statement -> . go_to_statement
    (78) unlabelled_basic_statement -> . procedure_statement
    (10) unlabelled_compound -> . BEGIN compound_tail
    (5) unlabelled_block -> . block_head SEMICOLON compound_tail
    (146) unsigned_integer -> . DIGIT
    (147) unsigned_integer -> . unsigned_integer DIGIT
    (79) assignment_statement -> . left_part_list arithmetic_expression
    (80) assignment_statement -> . left_part_list boolean_expression
    (85) go_to_statement -> . GOTO designational_expression
    (92) procedure_statement -> . procedure_identifier actual_parameter_part
    (6) block_head -> . BEGIN declaration
    (7) block_head -> . block_head SEMICOLON declaration
    (81) left_part_list -> . left_part
    (82) left_part_list -> . left_part_list left_part
    (44) procedure_identifier -> . IDENTIFIER
    (83) left_part -> . variable ASSIGNMENT
    (84) left_part -> . procedure_identifier ASSIGNMENT
    (172) variable -> . simple_variable
    (173) variable -> . subscripted_variable
    (174) simple_variable -> . variable_identifier
    (176) subscripted_variable -> . array_identifier LBBRACKET subscript_list RBBRACKET
    (175) variable_identifier -> . IDENTIFIER
    (31) array_identifier -> . IDENTIFIER

    TLABEL          shift and go to state 4
    IF              shift and go to state 45
    IDENTIFIER      shift and go to state 47
    FOR             shift and go to state 37
    BEGIN           shift and go to state 1
    DIGIT           shift and go to state 6
    GOTO            shift and go to state 20

    subscripted_variable           shift and go to state 13
    block                          shift and go to state 54
    unlabelled_compound            shift and go to state 2
    array_identifier               shift and go to state 14
    if_clause                      shift and go to state 16
    block_head                     shift and go to state 10
    conditional_statement          shift and go to state 25
    left_part                      shift and go to state 34
    left_part_list                 shift and go to state 40
    compound_statement             shift and go to state 22
    assignment_statement           shift and go to state 23
    procedure_statement            shift and go to state 24
    label                          shift and go to state 19
    statement                      shift and go to state 178
    if_statement                   shift and go to state 30
    basic_statement                shift and go to state 33
    for_statement                  shift and go to state 35
    go_to_statement                shift and go to state 38
    variable_identifier            shift and go to state 41
    variable                       shift and go to state 43
    unconditional_statement        shift and go to state 28
    unlabelled_block               shift and go to state 5
    procedure_identifier           shift and go to state 21
    simple_variable                shift and go to state 49
    unlabelled_basic_statement     shift and go to state 50
    for_clause                     shift and go to state 52
    unsigned_integer               shift and go to state 9

state 80

    (42) procedure_declaration -> type PROCEDURE . procedure_heading procedure_body
    (43) procedure_heading -> . procedure_identifier formal_parameter_part SEMICOLON value_part specification_part
    (44) procedure_identifier -> . IDENTIFIER

    IDENTIFIER      shift and go to state 124

    procedure_heading              shift and go to state 179
    procedure_identifier           shift and go to state 123

state 81

    (27) array_list -> array_segment .

    COMMA           reduce using rule 27 (array_list -> array_segment .)
    SEMICOLON       reduce using rule 27 (array_list -> array_segment .)


state 82

    (29) array_segment -> array_identifier . LBBRACKET bound_pair_list RBBRACKET
    (30) array_segment -> array_identifier . COMMA array_segment

    LBBRACKET       shift and go to state 180
    COMMA           shift and go to state 181


state 83

    (31) array_identifier -> IDENTIFIER .

    LBBRACKET       reduce using rule 31 (array_identifier -> IDENTIFIER .)
    COMMA           reduce using rule 31 (array_identifier -> IDENTIFIER .)


state 84

    (25) array_declaration -> TARRAY array_list .
    (28) array_list -> array_list . COMMA array_segment

    SEMICOLON       reduce using rule 25 (array_declaration -> TARRAY array_list .)
    COMMA           shift and go to state 182


state 85

    (112) for_clause -> FOR variable . ASSIGNMENT for_list DO

    ASSIGNMENT      shift and go to state 183


state 86

    (175) variable_identifier -> IDENTIFIER .
    (31) array_identifier -> IDENTIFIER .

    ASSIGNMENT      reduce using rule 175 (variable_identifier -> IDENTIFIER .)
    LBBRACKET       reduce using rule 31 (array_identifier -> IDENTIFIER .)


state 87

    (84) left_part -> procedure_identifier . ASSIGNMENT
    (171) function_designator -> procedure_identifier . actual_parameter_part
    (93) actual_parameter_part -> . LCBRACKET RCBRACKET
    (94) actual_parameter_part -> . LCBRACKET actual_parameter_list RCBRACKET

    ASSIGNMENT      shift and go to state 72
    LCBRACKET       shift and go to state 73

    actual_parameter_part          shift and go to state 184

state 88

    (157) implication -> boolean_term .
    (160) boolean_term -> boolean_term . OR boolean_factor

    IMPL            reduce using rule 157 (implication -> boolean_term .)
    EQUIV           reduce using rule 157 (implication -> boolean_term .)
    DO              reduce using rule 157 (implication -> boolean_term .)
    COMMA           reduce using rule 157 (implication -> boolean_term .)
    ELSE            reduce using rule 157 (implication -> boolean_term .)
    THEN            reduce using rule 157 (implication -> boolean_term .)
    RCBRACKET       reduce using rule 157 (implication -> boolean_term .)
    END             reduce using rule 157 (implication -> boolean_term .)
    SEMICOLON       reduce using rule 157 (implication -> boolean_term .)
    OR              shift and go to state 185


state 89

    (122) arithmetic_expression -> if_clause . simple_arithmetic_expression ELSE arithmetic_expression
    (154) boolean_expression -> if_clause . simple_boolean ELSE boolean_expression
    (123) simple_arithmetic_expression -> . term
    (124) simple_arithmetic_expression -> . adding_operator term
    (125) simple_arithmetic_expression -> . simple_arithmetic_expression adding_operator term
    (155) simple_boolean -> . implication
    (156) simple_boolean -> . simple_boolean EQUIV implication
    (128) term -> . factor
    (129) term -> . term multiplying_operator factor
    (126) adding_operator -> . PLUS
    (127) adding_operator -> . MINUS
    (157) implication -> . boolean_term
    (158) implication -> . implication IMPL boolean_term
    (133) factor -> . primary
    (134) factor -> . factor
    (135) factor -> . factor POWER primary
    (159) boolean_term -> . boolean_factor
    (160) boolean_term -> . boolean_term OR boolean_factor
    (136) primary -> . unsigned_number
    (137) primary -> . variable
    (138) primary -> . function_designator
    (139) primary -> . LCBRACKET arithmetic_expression RCBRACKET
    (161) boolean_factor -> . boolean_secondary
    (162) boolean_factor -> . boolean_factor AND boolean_secondary
    (140) unsigned_number -> . decimal_number
    (141) unsigned_number -> . exponential_part
    (142) unsigned_number -> . decimal_number exponential_part
    (172) variable -> . simple_variable
    (173) variable -> . subscripted_variable
    (171) function_designator -> . procedure_identifier actual_parameter_part
    (163) boolean_secondary -> . boolean_primary
    (164) boolean_secondary -> . NOT boolean_primary
    (143) decimal_number -> . unsigned_integer
    (144) decimal_number -> . decimal_fraction
    (145) decimal_number -> . unsigned_integer decimal_fraction
    (149) exponential_part -> . EREAL integer
    (174) simple_variable -> . variable_identifier
    (176) subscripted_variable -> . array_identifier LBBRACKET subscript_list RBBRACKET
    (44) procedure_identifier -> . IDENTIFIER
    (165) boolean_primary -> . logical_value
    (166) boolean_primary -> . variable
    (167) boolean_primary -> . function_designator
    (168) boolean_primary -> . relation
    (169) boolean_primary -> . LCBRACKET boolean_expression RCBRACKET
    (146) unsigned_integer -> . DIGIT
    (147) unsigned_integer -> . unsigned_integer DIGIT
    (148) decimal_fraction -> . DOT unsigned_integer
    (175) variable_identifier -> . IDENTIFIER
    (31) array_identifier -> . IDENTIFIER
    (183) logical_value -> . TRUE
    (184) logical_value -> . FALSE
    (170) relation -> . simple_arithmetic_expression relational_operator simple_arithmetic_expression

    PLUS            shift and go to state 102
    MINUS           shift and go to state 94
    LCBRACKET       shift and go to state 116
    NOT             shift and go to state 118
    EREAL           shift and go to state 115
    IDENTIFIER      shift and go to state 106
    DIGIT           shift and go to state 6
    DOT             shift and go to state 95
    TRUE            shift and go to state 93
    FALSE           shift and go to state 100

    boolean_primary                shift and go to state 99
    procedure_identifier           shift and go to state 125
    boolean_term                   shift and go to state 88
    boolean_factor                 shift and go to state 90
    relation                       shift and go to state 91
    simple_boolean                 shift and go to state 187
    boolean_secondary              shift and go to state 101
    unsigned_number                shift and go to state 105
    decimal_fraction               shift and go to state 103
    factor                         shift and go to state 104
    simple_arithmetic_expression   shift and go to state 186
    logical_value                  shift and go to state 109
    decimal_number                 shift and go to state 112
    primary                        shift and go to state 98
    variable_identifier            shift and go to state 41
    function_designator            shift and go to state 110
    array_identifier               shift and go to state 14
    variable                       shift and go to state 161
    exponential_part               shift and go to state 92
    term                           shift and go to state 113
    subscripted_variable           shift and go to state 13
    simple_variable                shift and go to state 49
    adding_operator                shift and go to state 117
    implication                    shift and go to state 119
    unsigned_integer               shift and go to state 120

state 90

    (159) boolean_term -> boolean_factor .
    (162) boolean_factor -> boolean_factor . AND boolean_secondary

    OR              reduce using rule 159 (boolean_term -> boolean_factor .)
    IMPL            reduce using rule 159 (boolean_term -> boolean_factor .)
    EQUIV           reduce using rule 159 (boolean_term -> boolean_factor .)
    RCBRACKET       reduce using rule 159 (boolean_term -> boolean_factor .)
    COMMA           reduce using rule 159 (boolean_term -> boolean_factor .)
    ELSE            reduce using rule 159 (boolean_term -> boolean_factor .)
    END             reduce using rule 159 (boolean_term -> boolean_factor .)
    SEMICOLON       reduce using rule 159 (boolean_term -> boolean_factor .)
    THEN            reduce using rule 159 (boolean_term -> boolean_factor .)
    DO              reduce using rule 159 (boolean_term -> boolean_factor .)
    AND             shift and go to state 188


state 91

    (168) boolean_primary -> relation .

    AND             reduce using rule 168 (boolean_primary -> relation .)
    OR              reduce using rule 168 (boolean_primary -> relation .)
    IMPL            reduce using rule 168 (boolean_primary -> relation .)
    ELSE            reduce using rule 168 (boolean_primary -> relation .)
    EQUIV           reduce using rule 168 (boolean_primary -> relation .)
    END             reduce using rule 168 (boolean_primary -> relation .)
    SEMICOLON       reduce using rule 168 (boolean_primary -> relation .)
    THEN            reduce using rule 168 (boolean_primary -> relation .)
    RCBRACKET       reduce using rule 168 (boolean_primary -> relation .)
    COMMA           reduce using rule 168 (boolean_primary -> relation .)
    DO              reduce using rule 168 (boolean_primary -> relation .)


state 92

    (141) unsigned_number -> exponential_part .

    POWER           reduce using rule 141 (unsigned_number -> exponential_part .)
    TIMES           reduce using rule 141 (unsigned_number -> exponential_part .)
    DIV             reduce using rule 141 (unsigned_number -> exponential_part .)
    MOD             reduce using rule 141 (unsigned_number -> exponential_part .)
    PLUS            reduce using rule 141 (unsigned_number -> exponential_part .)
    MINUS           reduce using rule 141 (unsigned_number -> exponential_part .)
    LESS            reduce using rule 141 (unsigned_number -> exponential_part .)
    NOTGREATER      reduce using rule 141 (unsigned_number -> exponential_part .)
    EQUAL           reduce using rule 141 (unsigned_number -> exponential_part .)
    NOTLESS         reduce using rule 141 (unsigned_number -> exponential_part .)
    GREATER         reduce using rule 141 (unsigned_number -> exponential_part .)
    NOTEQUAL        reduce using rule 141 (unsigned_number -> exponential_part .)
    RCBRACKET       reduce using rule 141 (unsigned_number -> exponential_part .)
    COMMA           reduce using rule 141 (unsigned_number -> exponential_part .)
    RBBRACKET       reduce using rule 141 (unsigned_number -> exponential_part .)
    ELSE            reduce using rule 141 (unsigned_number -> exponential_part .)
    END             reduce using rule 141 (unsigned_number -> exponential_part .)
    SEMICOLON       reduce using rule 141 (unsigned_number -> exponential_part .)
    COLON           reduce using rule 141 (unsigned_number -> exponential_part .)
    STEP            reduce using rule 141 (unsigned_number -> exponential_part .)
    WHILE           reduce using rule 141 (unsigned_number -> exponential_part .)
    DO              reduce using rule 141 (unsigned_number -> exponential_part .)
    AND             reduce using rule 141 (unsigned_number -> exponential_part .)
    OR              reduce using rule 141 (unsigned_number -> exponential_part .)
    IMPL            reduce using rule 141 (unsigned_number -> exponential_part .)
    EQUIV           reduce using rule 141 (unsigned_number -> exponential_part .)
    THEN            reduce using rule 141 (unsigned_number -> exponential_part .)
    UNTIL           reduce using rule 141 (unsigned_number -> exponential_part .)


state 93

    (183) logical_value -> TRUE .

    AND             reduce using rule 183 (logical_value -> TRUE .)
    OR              reduce using rule 183 (logical_value -> TRUE .)
    IMPL            reduce using rule 183 (logical_value -> TRUE .)
    EQUIV           reduce using rule 183 (logical_value -> TRUE .)
    END             reduce using rule 183 (logical_value -> TRUE .)
    SEMICOLON       reduce using rule 183 (logical_value -> TRUE .)
    ELSE            reduce using rule 183 (logical_value -> TRUE .)
    THEN            reduce using rule 183 (logical_value -> TRUE .)
    RCBRACKET       reduce using rule 183 (logical_value -> TRUE .)
    COMMA           reduce using rule 183 (logical_value -> TRUE .)
    DO              reduce using rule 183 (logical_value -> TRUE .)


state 94

    (127) adding_operator -> MINUS .

    LCBRACKET       reduce using rule 127 (adding_operator -> MINUS .)
    EREAL           reduce using rule 127 (adding_operator -> MINUS .)
    IDENTIFIER      reduce using rule 127 (adding_operator -> MINUS .)
    DIGIT           reduce using rule 127 (adding_operator -> MINUS .)
    DOT             reduce using rule 127 (adding_operator -> MINUS .)


state 95

    (148) decimal_fraction -> DOT . unsigned_integer
    (146) unsigned_integer -> . DIGIT
    (147) unsigned_integer -> . unsigned_integer DIGIT

    DIGIT           shift and go to state 6

    unsigned_integer               shift and go to state 189

state 96

    (82) left_part_list -> left_part_list left_part .

    IF              reduce using rule 82 (left_part_list -> left_part_list left_part .)
    IDENTIFIER      reduce using rule 82 (left_part_list -> left_part_list left_part .)
    PLUS            reduce using rule 82 (left_part_list -> left_part_list left_part .)
    MINUS           reduce using rule 82 (left_part_list -> left_part_list left_part .)
    LCBRACKET       reduce using rule 82 (left_part_list -> left_part_list left_part .)
    NOT             reduce using rule 82 (left_part_list -> left_part_list left_part .)
    EREAL           reduce using rule 82 (left_part_list -> left_part_list left_part .)
    DIGIT           reduce using rule 82 (left_part_list -> left_part_list left_part .)
    DOT             reduce using rule 82 (left_part_list -> left_part_list left_part .)
    TRUE            reduce using rule 82 (left_part_list -> left_part_list left_part .)
    FALSE           reduce using rule 82 (left_part_list -> left_part_list left_part .)


state 97

    (153) boolean_expression -> simple_boolean .
    (156) simple_boolean -> simple_boolean . EQUIV implication

    END             reduce using rule 153 (boolean_expression -> simple_boolean .)
    SEMICOLON       reduce using rule 153 (boolean_expression -> simple_boolean .)
    ELSE            reduce using rule 153 (boolean_expression -> simple_boolean .)
    THEN            reduce using rule 153 (boolean_expression -> simple_boolean .)
    RCBRACKET       reduce using rule 153 (boolean_expression -> simple_boolean .)
    COMMA           reduce using rule 153 (boolean_expression -> simple_boolean .)
    DO              reduce using rule 153 (boolean_expression -> simple_boolean .)
    EQUIV           shift and go to state 190


state 98

    (133) factor -> primary .

    POWER           reduce using rule 133 (factor -> primary .)
    TIMES           reduce using rule 133 (factor -> primary .)
    DIV             reduce using rule 133 (factor -> primary .)
    MOD             reduce using rule 133 (factor -> primary .)
    LESS            reduce using rule 133 (factor -> primary .)
    NOTGREATER      reduce using rule 133 (factor -> primary .)
    EQUAL           reduce using rule 133 (factor -> primary .)
    NOTLESS         reduce using rule 133 (factor -> primary .)
    GREATER         reduce using rule 133 (factor -> primary .)
    NOTEQUAL        reduce using rule 133 (factor -> primary .)
    PLUS            reduce using rule 133 (factor -> primary .)
    MINUS           reduce using rule 133 (factor -> primary .)
    STEP            reduce using rule 133 (factor -> primary .)
    WHILE           reduce using rule 133 (factor -> primary .)
    DO              reduce using rule 133 (factor -> primary .)
    COMMA           reduce using rule 133 (factor -> primary .)
    RCBRACKET       reduce using rule 133 (factor -> primary .)
    END             reduce using rule 133 (factor -> primary .)
    SEMICOLON       reduce using rule 133 (factor -> primary .)
    ELSE            reduce using rule 133 (factor -> primary .)
    RBBRACKET       reduce using rule 133 (factor -> primary .)
    COLON           reduce using rule 133 (factor -> primary .)
    AND             reduce using rule 133 (factor -> primary .)
    OR              reduce using rule 133 (factor -> primary .)
    IMPL            reduce using rule 133 (factor -> primary .)
    EQUIV           reduce using rule 133 (factor -> primary .)
    THEN            reduce using rule 133 (factor -> primary .)
    UNTIL           reduce using rule 133 (factor -> primary .)


state 99

    (163) boolean_secondary -> boolean_primary .

    AND             reduce using rule 163 (boolean_secondary -> boolean_primary .)
    OR              reduce using rule 163 (boolean_secondary -> boolean_primary .)
    IMPL            reduce using rule 163 (boolean_secondary -> boolean_primary .)
    EQUIV           reduce using rule 163 (boolean_secondary -> boolean_primary .)
    END             reduce using rule 163 (boolean_secondary -> boolean_primary .)
    SEMICOLON       reduce using rule 163 (boolean_secondary -> boolean_primary .)
    ELSE            reduce using rule 163 (boolean_secondary -> boolean_primary .)
    THEN            reduce using rule 163 (boolean_secondary -> boolean_primary .)
    RCBRACKET       reduce using rule 163 (boolean_secondary -> boolean_primary .)
    COMMA           reduce using rule 163 (boolean_secondary -> boolean_primary .)
    DO              reduce using rule 163 (boolean_secondary -> boolean_primary .)


state 100

    (184) logical_value -> FALSE .

    AND             reduce using rule 184 (logical_value -> FALSE .)
    OR              reduce using rule 184 (logical_value -> FALSE .)
    IMPL            reduce using rule 184 (logical_value -> FALSE .)
    EQUIV           reduce using rule 184 (logical_value -> FALSE .)
    END             reduce using rule 184 (logical_value -> FALSE .)
    SEMICOLON       reduce using rule 184 (logical_value -> FALSE .)
    ELSE            reduce using rule 184 (logical_value -> FALSE .)
    THEN            reduce using rule 184 (logical_value -> FALSE .)
    RCBRACKET       reduce using rule 184 (logical_value -> FALSE .)
    COMMA           reduce using rule 184 (logical_value -> FALSE .)
    DO              reduce using rule 184 (logical_value -> FALSE .)


state 101

    (161) boolean_factor -> boolean_secondary .

    AND             reduce using rule 161 (boolean_factor -> boolean_secondary .)
    OR              reduce using rule 161 (boolean_factor -> boolean_secondary .)
    IMPL            reduce using rule 161 (boolean_factor -> boolean_secondary .)
    ELSE            reduce using rule 161 (boolean_factor -> boolean_secondary .)
    EQUIV           reduce using rule 161 (boolean_factor -> boolean_secondary .)
    END             reduce using rule 161 (boolean_factor -> boolean_secondary .)
    SEMICOLON       reduce using rule 161 (boolean_factor -> boolean_secondary .)
    THEN            reduce using rule 161 (boolean_factor -> boolean_secondary .)
    RCBRACKET       reduce using rule 161 (boolean_factor -> boolean_secondary .)
    COMMA           reduce using rule 161 (boolean_factor -> boolean_secondary .)
    DO              reduce using rule 161 (boolean_factor -> boolean_secondary .)


state 102

    (126) adding_operator -> PLUS .

    LCBRACKET       reduce using rule 126 (adding_operator -> PLUS .)
    EREAL           reduce using rule 126 (adding_operator -> PLUS .)
    IDENTIFIER      reduce using rule 126 (adding_operator -> PLUS .)
    DIGIT           reduce using rule 126 (adding_operator -> PLUS .)
    DOT             reduce using rule 126 (adding_operator -> PLUS .)


state 103

    (144) decimal_number -> decimal_fraction .

    EREAL           reduce using rule 144 (decimal_number -> decimal_fraction .)
    POWER           reduce using rule 144 (decimal_number -> decimal_fraction .)
    TIMES           reduce using rule 144 (decimal_number -> decimal_fraction .)
    DIV             reduce using rule 144 (decimal_number -> decimal_fraction .)
    MOD             reduce using rule 144 (decimal_number -> decimal_fraction .)
    PLUS            reduce using rule 144 (decimal_number -> decimal_fraction .)
    MINUS           reduce using rule 144 (decimal_number -> decimal_fraction .)
    COLON           reduce using rule 144 (decimal_number -> decimal_fraction .)
    LESS            reduce using rule 144 (decimal_number -> decimal_fraction .)
    NOTGREATER      reduce using rule 144 (decimal_number -> decimal_fraction .)
    EQUAL           reduce using rule 144 (decimal_number -> decimal_fraction .)
    NOTLESS         reduce using rule 144 (decimal_number -> decimal_fraction .)
    GREATER         reduce using rule 144 (decimal_number -> decimal_fraction .)
    NOTEQUAL        reduce using rule 144 (decimal_number -> decimal_fraction .)
    END             reduce using rule 144 (decimal_number -> decimal_fraction .)
    SEMICOLON       reduce using rule 144 (decimal_number -> decimal_fraction .)
    ELSE            reduce using rule 144 (decimal_number -> decimal_fraction .)
    RBBRACKET       reduce using rule 144 (decimal_number -> decimal_fraction .)
    COMMA           reduce using rule 144 (decimal_number -> decimal_fraction .)
    RCBRACKET       reduce using rule 144 (decimal_number -> decimal_fraction .)
    STEP            reduce using rule 144 (decimal_number -> decimal_fraction .)
    WHILE           reduce using rule 144 (decimal_number -> decimal_fraction .)
    DO              reduce using rule 144 (decimal_number -> decimal_fraction .)
    AND             reduce using rule 144 (decimal_number -> decimal_fraction .)
    OR              reduce using rule 144 (decimal_number -> decimal_fraction .)
    IMPL            reduce using rule 144 (decimal_number -> decimal_fraction .)
    EQUIV           reduce using rule 144 (decimal_number -> decimal_fraction .)
    THEN            reduce using rule 144 (decimal_number -> decimal_fraction .)
    UNTIL           reduce using rule 144 (decimal_number -> decimal_fraction .)


state 104

    (128) term -> factor .
    (134) factor -> factor .
    (135) factor -> factor . POWER primary

  ! reduce/reduce conflict for TIMES resolved using rule 128 (term -> factor .)
  ! reduce/reduce conflict for DIV resolved using rule 128 (term -> factor .)
  ! reduce/reduce conflict for MOD resolved using rule 128 (term -> factor .)
  ! reduce/reduce conflict for LESS resolved using rule 128 (term -> factor .)
  ! reduce/reduce conflict for NOTGREATER resolved using rule 128 (term -> factor .)
  ! reduce/reduce conflict for EQUAL resolved using rule 128 (term -> factor .)
  ! reduce/reduce conflict for NOTLESS resolved using rule 128 (term -> factor .)
  ! reduce/reduce conflict for GREATER resolved using rule 128 (term -> factor .)
  ! reduce/reduce conflict for NOTEQUAL resolved using rule 128 (term -> factor .)
  ! reduce/reduce conflict for PLUS resolved using rule 128 (term -> factor .)
  ! reduce/reduce conflict for MINUS resolved using rule 128 (term -> factor .)
  ! reduce/reduce conflict for STEP resolved using rule 128 (term -> factor .)
  ! reduce/reduce conflict for WHILE resolved using rule 128 (term -> factor .)
  ! reduce/reduce conflict for DO resolved using rule 128 (term -> factor .)
  ! reduce/reduce conflict for COMMA resolved using rule 128 (term -> factor .)
  ! reduce/reduce conflict for RCBRACKET resolved using rule 128 (term -> factor .)
  ! reduce/reduce conflict for ELSE resolved using rule 128 (term -> factor .)
  ! reduce/reduce conflict for COLON resolved using rule 128 (term -> factor .)
  ! reduce/reduce conflict for RBBRACKET resolved using rule 128 (term -> factor .)
  ! reduce/reduce conflict for UNTIL resolved using rule 128 (term -> factor .)
  ! reduce/reduce conflict for END resolved using rule 128 (term -> factor .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 128 (term -> factor .)
  ! reduce/reduce conflict for AND resolved using rule 128 (term -> factor .)
  ! reduce/reduce conflict for OR resolved using rule 128 (term -> factor .)
  ! reduce/reduce conflict for IMPL resolved using rule 128 (term -> factor .)
  ! reduce/reduce conflict for EQUIV resolved using rule 128 (term -> factor .)
  ! reduce/reduce conflict for THEN resolved using rule 128 (term -> factor .)
  ! shift/reduce conflict for POWER resolved as shift
    TIMES           reduce using rule 128 (term -> factor .)
    DIV             reduce using rule 128 (term -> factor .)
    MOD             reduce using rule 128 (term -> factor .)
    ELSE            reduce using rule 128 (term -> factor .)
    PLUS            reduce using rule 128 (term -> factor .)
    MINUS           reduce using rule 128 (term -> factor .)
    LESS            reduce using rule 128 (term -> factor .)
    NOTGREATER      reduce using rule 128 (term -> factor .)
    EQUAL           reduce using rule 128 (term -> factor .)
    NOTLESS         reduce using rule 128 (term -> factor .)
    GREATER         reduce using rule 128 (term -> factor .)
    NOTEQUAL        reduce using rule 128 (term -> factor .)
    RCBRACKET       reduce using rule 128 (term -> factor .)
    END             reduce using rule 128 (term -> factor .)
    SEMICOLON       reduce using rule 128 (term -> factor .)
    RBBRACKET       reduce using rule 128 (term -> factor .)
    COMMA           reduce using rule 128 (term -> factor .)
    COLON           reduce using rule 128 (term -> factor .)
    STEP            reduce using rule 128 (term -> factor .)
    WHILE           reduce using rule 128 (term -> factor .)
    DO              reduce using rule 128 (term -> factor .)
    AND             reduce using rule 128 (term -> factor .)
    OR              reduce using rule 128 (term -> factor .)
    IMPL            reduce using rule 128 (term -> factor .)
    EQUIV           reduce using rule 128 (term -> factor .)
    THEN            reduce using rule 128 (term -> factor .)
    UNTIL           reduce using rule 128 (term -> factor .)
    POWER           shift and go to state 191

  ! POWER           [ reduce using rule 134 (factor -> factor .) ]
  ! TIMES           [ reduce using rule 134 (factor -> factor .) ]
  ! DIV             [ reduce using rule 134 (factor -> factor .) ]
  ! MOD             [ reduce using rule 134 (factor -> factor .) ]
  ! LESS            [ reduce using rule 134 (factor -> factor .) ]
  ! NOTGREATER      [ reduce using rule 134 (factor -> factor .) ]
  ! EQUAL           [ reduce using rule 134 (factor -> factor .) ]
  ! NOTLESS         [ reduce using rule 134 (factor -> factor .) ]
  ! GREATER         [ reduce using rule 134 (factor -> factor .) ]
  ! NOTEQUAL        [ reduce using rule 134 (factor -> factor .) ]
  ! PLUS            [ reduce using rule 134 (factor -> factor .) ]
  ! MINUS           [ reduce using rule 134 (factor -> factor .) ]
  ! STEP            [ reduce using rule 134 (factor -> factor .) ]
  ! WHILE           [ reduce using rule 134 (factor -> factor .) ]
  ! DO              [ reduce using rule 134 (factor -> factor .) ]
  ! COMMA           [ reduce using rule 134 (factor -> factor .) ]
  ! RCBRACKET       [ reduce using rule 134 (factor -> factor .) ]
  ! ELSE            [ reduce using rule 134 (factor -> factor .) ]
  ! COLON           [ reduce using rule 134 (factor -> factor .) ]
  ! RBBRACKET       [ reduce using rule 134 (factor -> factor .) ]
  ! UNTIL           [ reduce using rule 134 (factor -> factor .) ]
  ! END             [ reduce using rule 134 (factor -> factor .) ]
  ! SEMICOLON       [ reduce using rule 134 (factor -> factor .) ]
  ! AND             [ reduce using rule 134 (factor -> factor .) ]
  ! OR              [ reduce using rule 134 (factor -> factor .) ]
  ! IMPL            [ reduce using rule 134 (factor -> factor .) ]
  ! EQUIV           [ reduce using rule 134 (factor -> factor .) ]
  ! THEN            [ reduce using rule 134 (factor -> factor .) ]


state 105

    (136) primary -> unsigned_number .

    POWER           reduce using rule 136 (primary -> unsigned_number .)
    TIMES           reduce using rule 136 (primary -> unsigned_number .)
    DIV             reduce using rule 136 (primary -> unsigned_number .)
    MOD             reduce using rule 136 (primary -> unsigned_number .)
    PLUS            reduce using rule 136 (primary -> unsigned_number .)
    MINUS           reduce using rule 136 (primary -> unsigned_number .)
    LESS            reduce using rule 136 (primary -> unsigned_number .)
    NOTGREATER      reduce using rule 136 (primary -> unsigned_number .)
    EQUAL           reduce using rule 136 (primary -> unsigned_number .)
    NOTLESS         reduce using rule 136 (primary -> unsigned_number .)
    GREATER         reduce using rule 136 (primary -> unsigned_number .)
    NOTEQUAL        reduce using rule 136 (primary -> unsigned_number .)
    RCBRACKET       reduce using rule 136 (primary -> unsigned_number .)
    ELSE            reduce using rule 136 (primary -> unsigned_number .)
    RBBRACKET       reduce using rule 136 (primary -> unsigned_number .)
    COMMA           reduce using rule 136 (primary -> unsigned_number .)
    STEP            reduce using rule 136 (primary -> unsigned_number .)
    WHILE           reduce using rule 136 (primary -> unsigned_number .)
    DO              reduce using rule 136 (primary -> unsigned_number .)
    UNTIL           reduce using rule 136 (primary -> unsigned_number .)
    COLON           reduce using rule 136 (primary -> unsigned_number .)
    END             reduce using rule 136 (primary -> unsigned_number .)
    SEMICOLON       reduce using rule 136 (primary -> unsigned_number .)
    AND             reduce using rule 136 (primary -> unsigned_number .)
    OR              reduce using rule 136 (primary -> unsigned_number .)
    IMPL            reduce using rule 136 (primary -> unsigned_number .)
    EQUIV           reduce using rule 136 (primary -> unsigned_number .)
    THEN            reduce using rule 136 (primary -> unsigned_number .)


state 106

    (44) procedure_identifier -> IDENTIFIER .
    (175) variable_identifier -> IDENTIFIER .
    (31) array_identifier -> IDENTIFIER .

  ! reduce/reduce conflict for ASSIGNMENT resolved using rule 44 (procedure_identifier -> IDENTIFIER .)
    LCBRACKET       reduce using rule 44 (procedure_identifier -> IDENTIFIER .)
    ASSIGNMENT      reduce using rule 44 (procedure_identifier -> IDENTIFIER .)
    POWER           reduce using rule 175 (variable_identifier -> IDENTIFIER .)
    TIMES           reduce using rule 175 (variable_identifier -> IDENTIFIER .)
    DIV             reduce using rule 175 (variable_identifier -> IDENTIFIER .)
    MOD             reduce using rule 175 (variable_identifier -> IDENTIFIER .)
    PLUS            reduce using rule 175 (variable_identifier -> IDENTIFIER .)
    MINUS           reduce using rule 175 (variable_identifier -> IDENTIFIER .)
    COLON           reduce using rule 175 (variable_identifier -> IDENTIFIER .)
    STEP            reduce using rule 175 (variable_identifier -> IDENTIFIER .)
    WHILE           reduce using rule 175 (variable_identifier -> IDENTIFIER .)
    DO              reduce using rule 175 (variable_identifier -> IDENTIFIER .)
    COMMA           reduce using rule 175 (variable_identifier -> IDENTIFIER .)
    LESS            reduce using rule 175 (variable_identifier -> IDENTIFIER .)
    NOTGREATER      reduce using rule 175 (variable_identifier -> IDENTIFIER .)
    EQUAL           reduce using rule 175 (variable_identifier -> IDENTIFIER .)
    NOTLESS         reduce using rule 175 (variable_identifier -> IDENTIFIER .)
    GREATER         reduce using rule 175 (variable_identifier -> IDENTIFIER .)
    NOTEQUAL        reduce using rule 175 (variable_identifier -> IDENTIFIER .)
    END             reduce using rule 175 (variable_identifier -> IDENTIFIER .)
    SEMICOLON       reduce using rule 175 (variable_identifier -> IDENTIFIER .)
    ELSE            reduce using rule 175 (variable_identifier -> IDENTIFIER .)
    RBBRACKET       reduce using rule 175 (variable_identifier -> IDENTIFIER .)
    RCBRACKET       reduce using rule 175 (variable_identifier -> IDENTIFIER .)
    AND             reduce using rule 175 (variable_identifier -> IDENTIFIER .)
    OR              reduce using rule 175 (variable_identifier -> IDENTIFIER .)
    IMPL            reduce using rule 175 (variable_identifier -> IDENTIFIER .)
    EQUIV           reduce using rule 175 (variable_identifier -> IDENTIFIER .)
    THEN            reduce using rule 175 (variable_identifier -> IDENTIFIER .)
    UNTIL           reduce using rule 175 (variable_identifier -> IDENTIFIER .)
    LBBRACKET       reduce using rule 31 (array_identifier -> IDENTIFIER .)

  ! ASSIGNMENT      [ reduce using rule 175 (variable_identifier -> IDENTIFIER .) ]


state 107

    (121) arithmetic_expression -> simple_arithmetic_expression .
    (125) simple_arithmetic_expression -> simple_arithmetic_expression . adding_operator term
    (170) relation -> simple_arithmetic_expression . relational_operator simple_arithmetic_expression
    (126) adding_operator -> . PLUS
    (127) adding_operator -> . MINUS
    (185) relational_operator -> . LESS
    (186) relational_operator -> . NOTGREATER
    (187) relational_operator -> . EQUAL
    (188) relational_operator -> . NOTLESS
    (189) relational_operator -> . GREATER
    (190) relational_operator -> . NOTEQUAL

    RCBRACKET       reduce using rule 121 (arithmetic_expression -> simple_arithmetic_expression .)
    END             reduce using rule 121 (arithmetic_expression -> simple_arithmetic_expression .)
    SEMICOLON       reduce using rule 121 (arithmetic_expression -> simple_arithmetic_expression .)
    ELSE            reduce using rule 121 (arithmetic_expression -> simple_arithmetic_expression .)
    COMMA           reduce using rule 121 (arithmetic_expression -> simple_arithmetic_expression .)
    PLUS            shift and go to state 102
    MINUS           shift and go to state 94
    LESS            shift and go to state 194
    NOTGREATER      shift and go to state 199
    EQUAL           shift and go to state 195
    NOTLESS         shift and go to state 198
    GREATER         shift and go to state 197
    NOTEQUAL        shift and go to state 192

    adding_operator                shift and go to state 196
    relational_operator            shift and go to state 193

state 108

    (79) assignment_statement -> left_part_list arithmetic_expression .

    END             reduce using rule 79 (assignment_statement -> left_part_list arithmetic_expression .)
    SEMICOLON       reduce using rule 79 (assignment_statement -> left_part_list arithmetic_expression .)
    ELSE            reduce using rule 79 (assignment_statement -> left_part_list arithmetic_expression .)


state 109

    (165) boolean_primary -> logical_value .

    AND             reduce using rule 165 (boolean_primary -> logical_value .)
    OR              reduce using rule 165 (boolean_primary -> logical_value .)
    IMPL            reduce using rule 165 (boolean_primary -> logical_value .)
    ELSE            reduce using rule 165 (boolean_primary -> logical_value .)
    EQUIV           reduce using rule 165 (boolean_primary -> logical_value .)
    END             reduce using rule 165 (boolean_primary -> logical_value .)
    SEMICOLON       reduce using rule 165 (boolean_primary -> logical_value .)
    THEN            reduce using rule 165 (boolean_primary -> logical_value .)
    RCBRACKET       reduce using rule 165 (boolean_primary -> logical_value .)
    COMMA           reduce using rule 165 (boolean_primary -> logical_value .)
    DO              reduce using rule 165 (boolean_primary -> logical_value .)


state 110

    (138) primary -> function_designator .
    (167) boolean_primary -> function_designator .

  ! reduce/reduce conflict for ELSE resolved using rule 138 (primary -> function_designator .)
  ! reduce/reduce conflict for RCBRACKET resolved using rule 138 (primary -> function_designator .)
  ! reduce/reduce conflict for COMMA resolved using rule 138 (primary -> function_designator .)
  ! reduce/reduce conflict for END resolved using rule 138 (primary -> function_designator .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 138 (primary -> function_designator .)
    POWER           reduce using rule 138 (primary -> function_designator .)
    TIMES           reduce using rule 138 (primary -> function_designator .)
    DIV             reduce using rule 138 (primary -> function_designator .)
    MOD             reduce using rule 138 (primary -> function_designator .)
    PLUS            reduce using rule 138 (primary -> function_designator .)
    MINUS           reduce using rule 138 (primary -> function_designator .)
    LESS            reduce using rule 138 (primary -> function_designator .)
    NOTGREATER      reduce using rule 138 (primary -> function_designator .)
    EQUAL           reduce using rule 138 (primary -> function_designator .)
    NOTLESS         reduce using rule 138 (primary -> function_designator .)
    GREATER         reduce using rule 138 (primary -> function_designator .)
    NOTEQUAL        reduce using rule 138 (primary -> function_designator .)
    RCBRACKET       reduce using rule 138 (primary -> function_designator .)
    COMMA           reduce using rule 138 (primary -> function_designator .)
    ELSE            reduce using rule 138 (primary -> function_designator .)
    END             reduce using rule 138 (primary -> function_designator .)
    SEMICOLON       reduce using rule 138 (primary -> function_designator .)
    AND             reduce using rule 167 (boolean_primary -> function_designator .)
    OR              reduce using rule 167 (boolean_primary -> function_designator .)
    IMPL            reduce using rule 167 (boolean_primary -> function_designator .)
    EQUIV           reduce using rule 167 (boolean_primary -> function_designator .)

  ! ELSE            [ reduce using rule 167 (boolean_primary -> function_designator .) ]
  ! RCBRACKET       [ reduce using rule 167 (boolean_primary -> function_designator .) ]
  ! COMMA           [ reduce using rule 167 (boolean_primary -> function_designator .) ]
  ! END             [ reduce using rule 167 (boolean_primary -> function_designator .) ]
  ! SEMICOLON       [ reduce using rule 167 (boolean_primary -> function_designator .) ]


state 111

    (83) left_part -> variable . ASSIGNMENT
    (137) primary -> variable .
    (166) boolean_primary -> variable .

  ! reduce/reduce conflict for END resolved using rule 137 (primary -> variable .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 137 (primary -> variable .)
  ! reduce/reduce conflict for ELSE resolved using rule 137 (primary -> variable .)
    ASSIGNMENT      shift and go to state 121
    POWER           reduce using rule 137 (primary -> variable .)
    TIMES           reduce using rule 137 (primary -> variable .)
    DIV             reduce using rule 137 (primary -> variable .)
    MOD             reduce using rule 137 (primary -> variable .)
    PLUS            reduce using rule 137 (primary -> variable .)
    MINUS           reduce using rule 137 (primary -> variable .)
    LESS            reduce using rule 137 (primary -> variable .)
    NOTGREATER      reduce using rule 137 (primary -> variable .)
    EQUAL           reduce using rule 137 (primary -> variable .)
    NOTLESS         reduce using rule 137 (primary -> variable .)
    GREATER         reduce using rule 137 (primary -> variable .)
    NOTEQUAL        reduce using rule 137 (primary -> variable .)
    END             reduce using rule 137 (primary -> variable .)
    SEMICOLON       reduce using rule 137 (primary -> variable .)
    ELSE            reduce using rule 137 (primary -> variable .)
    AND             reduce using rule 166 (boolean_primary -> variable .)
    OR              reduce using rule 166 (boolean_primary -> variable .)
    IMPL            reduce using rule 166 (boolean_primary -> variable .)
    EQUIV           reduce using rule 166 (boolean_primary -> variable .)

  ! END             [ reduce using rule 166 (boolean_primary -> variable .) ]
  ! SEMICOLON       [ reduce using rule 166 (boolean_primary -> variable .) ]
  ! ELSE            [ reduce using rule 166 (boolean_primary -> variable .) ]


state 112

    (140) unsigned_number -> decimal_number .
    (142) unsigned_number -> decimal_number . exponential_part
    (149) exponential_part -> . EREAL integer

    POWER           reduce using rule 140 (unsigned_number -> decimal_number .)
    TIMES           reduce using rule 140 (unsigned_number -> decimal_number .)
    DIV             reduce using rule 140 (unsigned_number -> decimal_number .)
    MOD             reduce using rule 140 (unsigned_number -> decimal_number .)
    PLUS            reduce using rule 140 (unsigned_number -> decimal_number .)
    MINUS           reduce using rule 140 (unsigned_number -> decimal_number .)
    LESS            reduce using rule 140 (unsigned_number -> decimal_number .)
    NOTGREATER      reduce using rule 140 (unsigned_number -> decimal_number .)
    EQUAL           reduce using rule 140 (unsigned_number -> decimal_number .)
    NOTLESS         reduce using rule 140 (unsigned_number -> decimal_number .)
    GREATER         reduce using rule 140 (unsigned_number -> decimal_number .)
    NOTEQUAL        reduce using rule 140 (unsigned_number -> decimal_number .)
    RCBRACKET       reduce using rule 140 (unsigned_number -> decimal_number .)
    COMMA           reduce using rule 140 (unsigned_number -> decimal_number .)
    RBBRACKET       reduce using rule 140 (unsigned_number -> decimal_number .)
    ELSE            reduce using rule 140 (unsigned_number -> decimal_number .)
    END             reduce using rule 140 (unsigned_number -> decimal_number .)
    SEMICOLON       reduce using rule 140 (unsigned_number -> decimal_number .)
    COLON           reduce using rule 140 (unsigned_number -> decimal_number .)
    STEP            reduce using rule 140 (unsigned_number -> decimal_number .)
    WHILE           reduce using rule 140 (unsigned_number -> decimal_number .)
    DO              reduce using rule 140 (unsigned_number -> decimal_number .)
    AND             reduce using rule 140 (unsigned_number -> decimal_number .)
    OR              reduce using rule 140 (unsigned_number -> decimal_number .)
    IMPL            reduce using rule 140 (unsigned_number -> decimal_number .)
    EQUIV           reduce using rule 140 (unsigned_number -> decimal_number .)
    THEN            reduce using rule 140 (unsigned_number -> decimal_number .)
    UNTIL           reduce using rule 140 (unsigned_number -> decimal_number .)
    EREAL           shift and go to state 115

    exponential_part               shift and go to state 200

state 113

    (123) simple_arithmetic_expression -> term .
    (129) term -> term . multiplying_operator factor
    (130) multiplying_operator -> . TIMES
    (131) multiplying_operator -> . DIV
    (132) multiplying_operator -> . MOD

    ELSE            reduce using rule 123 (simple_arithmetic_expression -> term .)
    PLUS            reduce using rule 123 (simple_arithmetic_expression -> term .)
    MINUS           reduce using rule 123 (simple_arithmetic_expression -> term .)
    LESS            reduce using rule 123 (simple_arithmetic_expression -> term .)
    NOTGREATER      reduce using rule 123 (simple_arithmetic_expression -> term .)
    EQUAL           reduce using rule 123 (simple_arithmetic_expression -> term .)
    NOTLESS         reduce using rule 123 (simple_arithmetic_expression -> term .)
    GREATER         reduce using rule 123 (simple_arithmetic_expression -> term .)
    NOTEQUAL        reduce using rule 123 (simple_arithmetic_expression -> term .)
    RCBRACKET       reduce using rule 123 (simple_arithmetic_expression -> term .)
    RBBRACKET       reduce using rule 123 (simple_arithmetic_expression -> term .)
    COMMA           reduce using rule 123 (simple_arithmetic_expression -> term .)
    STEP            reduce using rule 123 (simple_arithmetic_expression -> term .)
    WHILE           reduce using rule 123 (simple_arithmetic_expression -> term .)
    DO              reduce using rule 123 (simple_arithmetic_expression -> term .)
    END             reduce using rule 123 (simple_arithmetic_expression -> term .)
    SEMICOLON       reduce using rule 123 (simple_arithmetic_expression -> term .)
    COLON           reduce using rule 123 (simple_arithmetic_expression -> term .)
    UNTIL           reduce using rule 123 (simple_arithmetic_expression -> term .)
    AND             reduce using rule 123 (simple_arithmetic_expression -> term .)
    OR              reduce using rule 123 (simple_arithmetic_expression -> term .)
    IMPL            reduce using rule 123 (simple_arithmetic_expression -> term .)
    EQUIV           reduce using rule 123 (simple_arithmetic_expression -> term .)
    THEN            reduce using rule 123 (simple_arithmetic_expression -> term .)
    TIMES           shift and go to state 201
    DIV             shift and go to state 202
    MOD             shift and go to state 204

    multiplying_operator           shift and go to state 203

state 114

    (80) assignment_statement -> left_part_list boolean_expression .

    END             reduce using rule 80 (assignment_statement -> left_part_list boolean_expression .)
    SEMICOLON       reduce using rule 80 (assignment_statement -> left_part_list boolean_expression .)
    ELSE            reduce using rule 80 (assignment_statement -> left_part_list boolean_expression .)


state 115

    (149) exponential_part -> EREAL . integer
    (150) integer -> . unsigned_integer
    (151) integer -> . PLUS unsigned_integer
    (152) integer -> . MINUS unsigned_integer
    (146) unsigned_integer -> . DIGIT
    (147) unsigned_integer -> . unsigned_integer DIGIT

    PLUS            shift and go to state 205
    MINUS           shift and go to state 207
    DIGIT           shift and go to state 6

    integer                        shift and go to state 206
    unsigned_integer               shift and go to state 208

state 116

    (139) primary -> LCBRACKET . arithmetic_expression RCBRACKET
    (169) boolean_primary -> LCBRACKET . boolean_expression RCBRACKET
    (121) arithmetic_expression -> . simple_arithmetic_expression
    (122) arithmetic_expression -> . if_clause simple_arithmetic_expression ELSE arithmetic_expression
    (153) boolean_expression -> . simple_boolean
    (154) boolean_expression -> . if_clause simple_boolean ELSE boolean_expression
    (123) simple_arithmetic_expression -> . term
    (124) simple_arithmetic_expression -> . adding_operator term
    (125) simple_arithmetic_expression -> . simple_arithmetic_expression adding_operator term
    (109) if_clause -> . IF boolean_expression THEN
    (155) simple_boolean -> . implication
    (156) simple_boolean -> . simple_boolean EQUIV implication
    (128) term -> . factor
    (129) term -> . term multiplying_operator factor
    (126) adding_operator -> . PLUS
    (127) adding_operator -> . MINUS
    (157) implication -> . boolean_term
    (158) implication -> . implication IMPL boolean_term
    (133) factor -> . primary
    (134) factor -> . factor
    (135) factor -> . factor POWER primary
    (159) boolean_term -> . boolean_factor
    (160) boolean_term -> . boolean_term OR boolean_factor
    (136) primary -> . unsigned_number
    (137) primary -> . variable
    (138) primary -> . function_designator
    (139) primary -> . LCBRACKET arithmetic_expression RCBRACKET
    (161) boolean_factor -> . boolean_secondary
    (162) boolean_factor -> . boolean_factor AND boolean_secondary
    (140) unsigned_number -> . decimal_number
    (141) unsigned_number -> . exponential_part
    (142) unsigned_number -> . decimal_number exponential_part
    (172) variable -> . simple_variable
    (173) variable -> . subscripted_variable
    (171) function_designator -> . procedure_identifier actual_parameter_part
    (163) boolean_secondary -> . boolean_primary
    (164) boolean_secondary -> . NOT boolean_primary
    (143) decimal_number -> . unsigned_integer
    (144) decimal_number -> . decimal_fraction
    (145) decimal_number -> . unsigned_integer decimal_fraction
    (149) exponential_part -> . EREAL integer
    (174) simple_variable -> . variable_identifier
    (176) subscripted_variable -> . array_identifier LBBRACKET subscript_list RBBRACKET
    (44) procedure_identifier -> . IDENTIFIER
    (165) boolean_primary -> . logical_value
    (166) boolean_primary -> . variable
    (167) boolean_primary -> . function_designator
    (168) boolean_primary -> . relation
    (169) boolean_primary -> . LCBRACKET boolean_expression RCBRACKET
    (146) unsigned_integer -> . DIGIT
    (147) unsigned_integer -> . unsigned_integer DIGIT
    (148) decimal_fraction -> . DOT unsigned_integer
    (175) variable_identifier -> . IDENTIFIER
    (31) array_identifier -> . IDENTIFIER
    (183) logical_value -> . TRUE
    (184) logical_value -> . FALSE
    (170) relation -> . simple_arithmetic_expression relational_operator simple_arithmetic_expression

    IF              shift and go to state 45
    PLUS            shift and go to state 102
    MINUS           shift and go to state 94
    LCBRACKET       shift and go to state 116
    NOT             shift and go to state 118
    EREAL           shift and go to state 115
    IDENTIFIER      shift and go to state 106
    DIGIT           shift and go to state 6
    DOT             shift and go to state 95
    TRUE            shift and go to state 93
    FALSE           shift and go to state 100

    boolean_primary                shift and go to state 99
    procedure_identifier           shift and go to state 125
    boolean_term                   shift and go to state 88
    if_clause                      shift and go to state 89
    boolean_factor                 shift and go to state 90
    relation                       shift and go to state 91
    simple_boolean                 shift and go to state 97
    boolean_secondary              shift and go to state 101
    unsigned_number                shift and go to state 105
    decimal_fraction               shift and go to state 103
    factor                         shift and go to state 104
    simple_arithmetic_expression   shift and go to state 107
    arithmetic_expression          shift and go to state 209
    logical_value                  shift and go to state 109
    decimal_number                 shift and go to state 112
    primary                        shift and go to state 98
    variable_identifier            shift and go to state 41
    function_designator            shift and go to state 110
    array_identifier               shift and go to state 14
    variable                       shift and go to state 161
    exponential_part               shift and go to state 92
    term                           shift and go to state 113
    boolean_expression             shift and go to state 210
    subscripted_variable           shift and go to state 13
    simple_variable                shift and go to state 49
    adding_operator                shift and go to state 117
    implication                    shift and go to state 119
    unsigned_integer               shift and go to state 120

state 117

    (124) simple_arithmetic_expression -> adding_operator . term
    (128) term -> . factor
    (129) term -> . term multiplying_operator factor
    (133) factor -> . primary
    (134) factor -> . factor
    (135) factor -> . factor POWER primary
    (136) primary -> . unsigned_number
    (137) primary -> . variable
    (138) primary -> . function_designator
    (139) primary -> . LCBRACKET arithmetic_expression RCBRACKET
    (140) unsigned_number -> . decimal_number
    (141) unsigned_number -> . exponential_part
    (142) unsigned_number -> . decimal_number exponential_part
    (172) variable -> . simple_variable
    (173) variable -> . subscripted_variable
    (171) function_designator -> . procedure_identifier actual_parameter_part
    (143) decimal_number -> . unsigned_integer
    (144) decimal_number -> . decimal_fraction
    (145) decimal_number -> . unsigned_integer decimal_fraction
    (149) exponential_part -> . EREAL integer
    (174) simple_variable -> . variable_identifier
    (176) subscripted_variable -> . array_identifier LBBRACKET subscript_list RBBRACKET
    (44) procedure_identifier -> . IDENTIFIER
    (146) unsigned_integer -> . DIGIT
    (147) unsigned_integer -> . unsigned_integer DIGIT
    (148) decimal_fraction -> . DOT unsigned_integer
    (175) variable_identifier -> . IDENTIFIER
    (31) array_identifier -> . IDENTIFIER

    LCBRACKET       shift and go to state 145
    EREAL           shift and go to state 115
    IDENTIFIER      shift and go to state 106
    DIGIT           shift and go to state 6
    DOT             shift and go to state 95

    term                           shift and go to state 211
    procedure_identifier           shift and go to state 125
    array_identifier               shift and go to state 14
    subscripted_variable           shift and go to state 13
    primary                        shift and go to state 98
    function_designator            shift and go to state 149
    decimal_number                 shift and go to state 112
    variable_identifier            shift and go to state 41
    unsigned_number                shift and go to state 105
    decimal_fraction               shift and go to state 103
    factor                         shift and go to state 104
    variable                       shift and go to state 150
    simple_variable                shift and go to state 49
    unsigned_integer               shift and go to state 120
    exponential_part               shift and go to state 92

state 118

    (164) boolean_secondary -> NOT . boolean_primary
    (165) boolean_primary -> . logical_value
    (166) boolean_primary -> . variable
    (167) boolean_primary -> . function_designator
    (168) boolean_primary -> . relation
    (169) boolean_primary -> . LCBRACKET boolean_expression RCBRACKET
    (183) logical_value -> . TRUE
    (184) logical_value -> . FALSE
    (172) variable -> . simple_variable
    (173) variable -> . subscripted_variable
    (171) function_designator -> . procedure_identifier actual_parameter_part
    (170) relation -> . simple_arithmetic_expression relational_operator simple_arithmetic_expression
    (174) simple_variable -> . variable_identifier
    (176) subscripted_variable -> . array_identifier LBBRACKET subscript_list RBBRACKET
    (44) procedure_identifier -> . IDENTIFIER
    (123) simple_arithmetic_expression -> . term
    (124) simple_arithmetic_expression -> . adding_operator term
    (125) simple_arithmetic_expression -> . simple_arithmetic_expression adding_operator term
    (175) variable_identifier -> . IDENTIFIER
    (31) array_identifier -> . IDENTIFIER
    (128) term -> . factor
    (129) term -> . term multiplying_operator factor
    (126) adding_operator -> . PLUS
    (127) adding_operator -> . MINUS
    (133) factor -> . primary
    (134) factor -> . factor
    (135) factor -> . factor POWER primary
    (136) primary -> . unsigned_number
    (137) primary -> . variable
    (138) primary -> . function_designator
    (139) primary -> . LCBRACKET arithmetic_expression RCBRACKET
    (140) unsigned_number -> . decimal_number
    (141) unsigned_number -> . exponential_part
    (142) unsigned_number -> . decimal_number exponential_part
    (143) decimal_number -> . unsigned_integer
    (144) decimal_number -> . decimal_fraction
    (145) decimal_number -> . unsigned_integer decimal_fraction
    (149) exponential_part -> . EREAL integer
    (146) unsigned_integer -> . DIGIT
    (147) unsigned_integer -> . unsigned_integer DIGIT
    (148) decimal_fraction -> . DOT unsigned_integer

    LCBRACKET       shift and go to state 127
    TRUE            shift and go to state 93
    FALSE           shift and go to state 100
    IDENTIFIER      shift and go to state 106
    PLUS            shift and go to state 102
    MINUS           shift and go to state 94
    EREAL           shift and go to state 115
    DIGIT           shift and go to state 6
    DOT             shift and go to state 95

    subscripted_variable           shift and go to state 13
    primary                        shift and go to state 98
    function_designator            shift and go to state 128
    relation                       shift and go to state 91
    unsigned_number                shift and go to state 105
    decimal_fraction               shift and go to state 103
    factor                         shift and go to state 104
    simple_arithmetic_expression   shift and go to state 131
    boolean_primary                shift and go to state 212
    logical_value                  shift and go to state 109
    decimal_number                 shift and go to state 112
    variable_identifier            shift and go to state 41
    array_identifier               shift and go to state 14
    variable                       shift and go to state 129
    exponential_part               shift and go to state 92
    term                           shift and go to state 113
    procedure_identifier           shift and go to state 125
    simple_variable                shift and go to state 49
    adding_operator                shift and go to state 117
    unsigned_integer               shift and go to state 120

state 119

    (155) simple_boolean -> implication .
    (158) implication -> implication . IMPL boolean_term

    EQUIV           reduce using rule 155 (simple_boolean -> implication .)
    THEN            reduce using rule 155 (simple_boolean -> implication .)
    RCBRACKET       reduce using rule 155 (simple_boolean -> implication .)
    ELSE            reduce using rule 155 (simple_boolean -> implication .)
    DO              reduce using rule 155 (simple_boolean -> implication .)
    COMMA           reduce using rule 155 (simple_boolean -> implication .)
    END             reduce using rule 155 (simple_boolean -> implication .)
    SEMICOLON       reduce using rule 155 (simple_boolean -> implication .)
    IMPL            shift and go to state 213


state 120

    (143) decimal_number -> unsigned_integer .
    (145) decimal_number -> unsigned_integer . decimal_fraction
    (147) unsigned_integer -> unsigned_integer . DIGIT
    (148) decimal_fraction -> . DOT unsigned_integer

    EREAL           reduce using rule 143 (decimal_number -> unsigned_integer .)
    POWER           reduce using rule 143 (decimal_number -> unsigned_integer .)
    TIMES           reduce using rule 143 (decimal_number -> unsigned_integer .)
    DIV             reduce using rule 143 (decimal_number -> unsigned_integer .)
    MOD             reduce using rule 143 (decimal_number -> unsigned_integer .)
    PLUS            reduce using rule 143 (decimal_number -> unsigned_integer .)
    MINUS           reduce using rule 143 (decimal_number -> unsigned_integer .)
    COLON           reduce using rule 143 (decimal_number -> unsigned_integer .)
    LESS            reduce using rule 143 (decimal_number -> unsigned_integer .)
    NOTGREATER      reduce using rule 143 (decimal_number -> unsigned_integer .)
    EQUAL           reduce using rule 143 (decimal_number -> unsigned_integer .)
    NOTLESS         reduce using rule 143 (decimal_number -> unsigned_integer .)
    GREATER         reduce using rule 143 (decimal_number -> unsigned_integer .)
    NOTEQUAL        reduce using rule 143 (decimal_number -> unsigned_integer .)
    END             reduce using rule 143 (decimal_number -> unsigned_integer .)
    SEMICOLON       reduce using rule 143 (decimal_number -> unsigned_integer .)
    ELSE            reduce using rule 143 (decimal_number -> unsigned_integer .)
    RBBRACKET       reduce using rule 143 (decimal_number -> unsigned_integer .)
    COMMA           reduce using rule 143 (decimal_number -> unsigned_integer .)
    RCBRACKET       reduce using rule 143 (decimal_number -> unsigned_integer .)
    STEP            reduce using rule 143 (decimal_number -> unsigned_integer .)
    WHILE           reduce using rule 143 (decimal_number -> unsigned_integer .)
    DO              reduce using rule 143 (decimal_number -> unsigned_integer .)
    AND             reduce using rule 143 (decimal_number -> unsigned_integer .)
    OR              reduce using rule 143 (decimal_number -> unsigned_integer .)
    IMPL            reduce using rule 143 (decimal_number -> unsigned_integer .)
    EQUIV           reduce using rule 143 (decimal_number -> unsigned_integer .)
    THEN            reduce using rule 143 (decimal_number -> unsigned_integer .)
    UNTIL           reduce using rule 143 (decimal_number -> unsigned_integer .)
    DIGIT           shift and go to state 57
    DOT             shift and go to state 95

    decimal_fraction               shift and go to state 214

state 121

    (83) left_part -> variable ASSIGNMENT .

    IF              reduce using rule 83 (left_part -> variable ASSIGNMENT .)
    IDENTIFIER      reduce using rule 83 (left_part -> variable ASSIGNMENT .)
    PLUS            reduce using rule 83 (left_part -> variable ASSIGNMENT .)
    MINUS           reduce using rule 83 (left_part -> variable ASSIGNMENT .)
    LCBRACKET       reduce using rule 83 (left_part -> variable ASSIGNMENT .)
    NOT             reduce using rule 83 (left_part -> variable ASSIGNMENT .)
    EREAL           reduce using rule 83 (left_part -> variable ASSIGNMENT .)
    DIGIT           reduce using rule 83 (left_part -> variable ASSIGNMENT .)
    DOT             reduce using rule 83 (left_part -> variable ASSIGNMENT .)
    TRUE            reduce using rule 83 (left_part -> variable ASSIGNMENT .)
    FALSE           reduce using rule 83 (left_part -> variable ASSIGNMENT .)


state 122

    (41) procedure_declaration -> PROCEDURE procedure_heading . procedure_body
    (65) procedure_body -> . statement
    (66) statement -> . unconditional_statement
    (67) statement -> . conditional_statement
    (68) statement -> . for_statement
    (69) unconditional_statement -> . basic_statement
    (70) unconditional_statement -> . compound_statement
    (71) unconditional_statement -> . block
    (104) conditional_statement -> . if_statement
    (105) conditional_statement -> . if_statement ELSE statement
    (106) conditional_statement -> . if_clause for_statement
    (107) conditional_statement -> . label COLON conditional_statement
    (110) for_statement -> . for_clause statement
    (111) for_statement -> . label COLON for_statement
    (72) basic_statement -> . unlabelled_basic_statement
    (73) basic_statement -> . label COLON basic_statement
    (8) compound_statement -> . unlabelled_compound
    (9) compound_statement -> . label COLON compound_statement
    (3) block -> . unlabelled_block
    (4) block -> . TLABEL COLON block
    (108) if_statement -> . if_clause unconditional_statement
    (109) if_clause -> . IF boolean_expression THEN
    (74) label -> . IDENTIFIER
    (75) label -> . unsigned_integer
    (112) for_clause -> . FOR variable ASSIGNMENT for_list DO
    (76) unlabelled_basic_statement -> . assignment_statement
    (77) unlabelled_basic_statement -> . go_to_statement
    (78) unlabelled_basic_statement -> . procedure_statement
    (10) unlabelled_compound -> . BEGIN compound_tail
    (5) unlabelled_block -> . block_head SEMICOLON compound_tail
    (146) unsigned_integer -> . DIGIT
    (147) unsigned_integer -> . unsigned_integer DIGIT
    (79) assignment_statement -> . left_part_list arithmetic_expression
    (80) assignment_statement -> . left_part_list boolean_expression
    (85) go_to_statement -> . GOTO designational_expression
    (92) procedure_statement -> . procedure_identifier actual_parameter_part
    (6) block_head -> . BEGIN declaration
    (7) block_head -> . block_head SEMICOLON declaration
    (81) left_part_list -> . left_part
    (82) left_part_list -> . left_part_list left_part
    (44) procedure_identifier -> . IDENTIFIER
    (83) left_part -> . variable ASSIGNMENT
    (84) left_part -> . procedure_identifier ASSIGNMENT
    (172) variable -> . simple_variable
    (173) variable -> . subscripted_variable
    (174) simple_variable -> . variable_identifier
    (176) subscripted_variable -> . array_identifier LBBRACKET subscript_list RBBRACKET
    (175) variable_identifier -> . IDENTIFIER
    (31) array_identifier -> . IDENTIFIER

    TLABEL          shift and go to state 4
    IF              shift and go to state 45
    IDENTIFIER      shift and go to state 47
    FOR             shift and go to state 37
    BEGIN           shift and go to state 1
    DIGIT           shift and go to state 6
    GOTO            shift and go to state 20

    subscripted_variable           shift and go to state 13
    block                          shift and go to state 54
    unlabelled_compound            shift and go to state 2
    array_identifier               shift and go to state 14
    if_clause                      shift and go to state 16
    block_head                     shift and go to state 10
    conditional_statement          shift and go to state 25
    left_part                      shift and go to state 34
    left_part_list                 shift and go to state 40
    compound_statement             shift and go to state 22
    assignment_statement           shift and go to state 23
    procedure_statement            shift and go to state 24
    label                          shift and go to state 19
    statement                      shift and go to state 215
    if_statement                   shift and go to state 30
    basic_statement                shift and go to state 33
    for_statement                  shift and go to state 35
    go_to_statement                shift and go to state 38
    variable_identifier            shift and go to state 41
    variable                       shift and go to state 43
    unconditional_statement        shift and go to state 28
    unlabelled_block               shift and go to state 5
    procedure_identifier           shift and go to state 21
    simple_variable                shift and go to state 49
    unlabelled_basic_statement     shift and go to state 50
    for_clause                     shift and go to state 52
    procedure_body                 shift and go to state 216
    unsigned_integer               shift and go to state 9

state 123

    (43) procedure_heading -> procedure_identifier . formal_parameter_part SEMICOLON value_part specification_part
    (45) formal_parameter_part -> .
    (46) formal_parameter_part -> . LCBRACKET formal_parameter_list RCBRACKET

    SEMICOLON       reduce using rule 45 (formal_parameter_part -> .)
    LCBRACKET       shift and go to state 218

    formal_parameter_part          shift and go to state 217

state 124

    (44) procedure_identifier -> IDENTIFIER .

    LCBRACKET       reduce using rule 44 (procedure_identifier -> IDENTIFIER .)
    SEMICOLON       reduce using rule 44 (procedure_identifier -> IDENTIFIER .)


state 125

    (171) function_designator -> procedure_identifier . actual_parameter_part
    (93) actual_parameter_part -> . LCBRACKET RCBRACKET
    (94) actual_parameter_part -> . LCBRACKET actual_parameter_list RCBRACKET

    LCBRACKET       shift and go to state 73

    actual_parameter_part          shift and go to state 184

state 126

    (154) boolean_expression -> if_clause . simple_boolean ELSE boolean_expression
    (155) simple_boolean -> . implication
    (156) simple_boolean -> . simple_boolean EQUIV implication
    (157) implication -> . boolean_term
    (158) implication -> . implication IMPL boolean_term
    (159) boolean_term -> . boolean_factor
    (160) boolean_term -> . boolean_term OR boolean_factor
    (161) boolean_factor -> . boolean_secondary
    (162) boolean_factor -> . boolean_factor AND boolean_secondary
    (163) boolean_secondary -> . boolean_primary
    (164) boolean_secondary -> . NOT boolean_primary
    (165) boolean_primary -> . logical_value
    (166) boolean_primary -> . variable
    (167) boolean_primary -> . function_designator
    (168) boolean_primary -> . relation
    (169) boolean_primary -> . LCBRACKET boolean_expression RCBRACKET
    (183) logical_value -> . TRUE
    (184) logical_value -> . FALSE
    (172) variable -> . simple_variable
    (173) variable -> . subscripted_variable
    (171) function_designator -> . procedure_identifier actual_parameter_part
    (170) relation -> . simple_arithmetic_expression relational_operator simple_arithmetic_expression
    (174) simple_variable -> . variable_identifier
    (176) subscripted_variable -> . array_identifier LBBRACKET subscript_list RBBRACKET
    (44) procedure_identifier -> . IDENTIFIER
    (123) simple_arithmetic_expression -> . term
    (124) simple_arithmetic_expression -> . adding_operator term
    (125) simple_arithmetic_expression -> . simple_arithmetic_expression adding_operator term
    (175) variable_identifier -> . IDENTIFIER
    (31) array_identifier -> . IDENTIFIER
    (128) term -> . factor
    (129) term -> . term multiplying_operator factor
    (126) adding_operator -> . PLUS
    (127) adding_operator -> . MINUS
    (133) factor -> . primary
    (134) factor -> . factor
    (135) factor -> . factor POWER primary
    (136) primary -> . unsigned_number
    (137) primary -> . variable
    (138) primary -> . function_designator
    (139) primary -> . LCBRACKET arithmetic_expression RCBRACKET
    (140) unsigned_number -> . decimal_number
    (141) unsigned_number -> . exponential_part
    (142) unsigned_number -> . decimal_number exponential_part
    (143) decimal_number -> . unsigned_integer
    (144) decimal_number -> . decimal_fraction
    (145) decimal_number -> . unsigned_integer decimal_fraction
    (149) exponential_part -> . EREAL integer
    (146) unsigned_integer -> . DIGIT
    (147) unsigned_integer -> . unsigned_integer DIGIT
    (148) decimal_fraction -> . DOT unsigned_integer

    NOT             shift and go to state 118
    LCBRACKET       shift and go to state 127
    TRUE            shift and go to state 93
    FALSE           shift and go to state 100
    IDENTIFIER      shift and go to state 106
    PLUS            shift and go to state 102
    MINUS           shift and go to state 94
    EREAL           shift and go to state 115
    DIGIT           shift and go to state 6
    DOT             shift and go to state 95

    subscripted_variable           shift and go to state 13
    boolean_term                   shift and go to state 88
    boolean_factor                 shift and go to state 90
    relation                       shift and go to state 91
    simple_boolean                 shift and go to state 187
    boolean_secondary              shift and go to state 101
    unsigned_number                shift and go to state 105
    decimal_fraction               shift and go to state 103
    factor                         shift and go to state 104
    simple_arithmetic_expression   shift and go to state 131
    boolean_primary                shift and go to state 99
    logical_value                  shift and go to state 109
    decimal_number                 shift and go to state 112
    primary                        shift and go to state 98
    variable_identifier            shift and go to state 41
    function_designator            shift and go to state 128
    array_identifier               shift and go to state 14
    variable                       shift and go to state 129
    exponential_part               shift and go to state 92
    term                           shift and go to state 113
    procedure_identifier           shift and go to state 125
    simple_variable                shift and go to state 49
    adding_operator                shift and go to state 117
    implication                    shift and go to state 119
    unsigned_integer               shift and go to state 120

state 127

    (169) boolean_primary -> LCBRACKET . boolean_expression RCBRACKET
    (139) primary -> LCBRACKET . arithmetic_expression RCBRACKET
    (153) boolean_expression -> . simple_boolean
    (154) boolean_expression -> . if_clause simple_boolean ELSE boolean_expression
    (121) arithmetic_expression -> . simple_arithmetic_expression
    (122) arithmetic_expression -> . if_clause simple_arithmetic_expression ELSE arithmetic_expression
    (155) simple_boolean -> . implication
    (156) simple_boolean -> . simple_boolean EQUIV implication
    (109) if_clause -> . IF boolean_expression THEN
    (123) simple_arithmetic_expression -> . term
    (124) simple_arithmetic_expression -> . adding_operator term
    (125) simple_arithmetic_expression -> . simple_arithmetic_expression adding_operator term
    (157) implication -> . boolean_term
    (158) implication -> . implication IMPL boolean_term
    (128) term -> . factor
    (129) term -> . term multiplying_operator factor
    (126) adding_operator -> . PLUS
    (127) adding_operator -> . MINUS
    (159) boolean_term -> . boolean_factor
    (160) boolean_term -> . boolean_term OR boolean_factor
    (133) factor -> . primary
    (134) factor -> . factor
    (135) factor -> . factor POWER primary
    (161) boolean_factor -> . boolean_secondary
    (162) boolean_factor -> . boolean_factor AND boolean_secondary
    (136) primary -> . unsigned_number
    (137) primary -> . variable
    (138) primary -> . function_designator
    (139) primary -> . LCBRACKET arithmetic_expression RCBRACKET
    (163) boolean_secondary -> . boolean_primary
    (164) boolean_secondary -> . NOT boolean_primary
    (140) unsigned_number -> . decimal_number
    (141) unsigned_number -> . exponential_part
    (142) unsigned_number -> . decimal_number exponential_part
    (172) variable -> . simple_variable
    (173) variable -> . subscripted_variable
    (171) function_designator -> . procedure_identifier actual_parameter_part
    (165) boolean_primary -> . logical_value
    (166) boolean_primary -> . variable
    (167) boolean_primary -> . function_designator
    (168) boolean_primary -> . relation
    (169) boolean_primary -> . LCBRACKET boolean_expression RCBRACKET
    (143) decimal_number -> . unsigned_integer
    (144) decimal_number -> . decimal_fraction
    (145) decimal_number -> . unsigned_integer decimal_fraction
    (149) exponential_part -> . EREAL integer
    (174) simple_variable -> . variable_identifier
    (176) subscripted_variable -> . array_identifier LBBRACKET subscript_list RBBRACKET
    (44) procedure_identifier -> . IDENTIFIER
    (183) logical_value -> . TRUE
    (184) logical_value -> . FALSE
    (170) relation -> . simple_arithmetic_expression relational_operator simple_arithmetic_expression
    (146) unsigned_integer -> . DIGIT
    (147) unsigned_integer -> . unsigned_integer DIGIT
    (148) decimal_fraction -> . DOT unsigned_integer
    (175) variable_identifier -> . IDENTIFIER
    (31) array_identifier -> . IDENTIFIER

    IF              shift and go to state 45
    PLUS            shift and go to state 102
    MINUS           shift and go to state 94
    LCBRACKET       shift and go to state 116
    NOT             shift and go to state 118
    EREAL           shift and go to state 115
    IDENTIFIER      shift and go to state 106
    TRUE            shift and go to state 93
    FALSE           shift and go to state 100
    DIGIT           shift and go to state 6
    DOT             shift and go to state 95

    boolean_primary                shift and go to state 99
    procedure_identifier           shift and go to state 125
    boolean_term                   shift and go to state 88
    if_clause                      shift and go to state 219
    boolean_factor                 shift and go to state 90
    relation                       shift and go to state 91
    simple_boolean                 shift and go to state 97
    boolean_secondary              shift and go to state 101
    unsigned_number                shift and go to state 105
    decimal_fraction               shift and go to state 103
    factor                         shift and go to state 104
    simple_arithmetic_expression   shift and go to state 107
    arithmetic_expression          shift and go to state 209
    logical_value                  shift and go to state 109
    decimal_number                 shift and go to state 112
    primary                        shift and go to state 98
    variable_identifier            shift and go to state 41
    function_designator            shift and go to state 110
    array_identifier               shift and go to state 14
    variable                       shift and go to state 161
    exponential_part               shift and go to state 92
    term                           shift and go to state 113
    boolean_expression             shift and go to state 210
    subscripted_variable           shift and go to state 13
    simple_variable                shift and go to state 49
    adding_operator                shift and go to state 117
    implication                    shift and go to state 119
    unsigned_integer               shift and go to state 120

state 128

    (167) boolean_primary -> function_designator .
    (138) primary -> function_designator .

    AND             reduce using rule 167 (boolean_primary -> function_designator .)
    OR              reduce using rule 167 (boolean_primary -> function_designator .)
    IMPL            reduce using rule 167 (boolean_primary -> function_designator .)
    EQUIV           reduce using rule 167 (boolean_primary -> function_designator .)
    END             reduce using rule 167 (boolean_primary -> function_designator .)
    SEMICOLON       reduce using rule 167 (boolean_primary -> function_designator .)
    ELSE            reduce using rule 167 (boolean_primary -> function_designator .)
    THEN            reduce using rule 167 (boolean_primary -> function_designator .)
    RCBRACKET       reduce using rule 167 (boolean_primary -> function_designator .)
    COMMA           reduce using rule 167 (boolean_primary -> function_designator .)
    DO              reduce using rule 167 (boolean_primary -> function_designator .)
    POWER           reduce using rule 138 (primary -> function_designator .)
    TIMES           reduce using rule 138 (primary -> function_designator .)
    DIV             reduce using rule 138 (primary -> function_designator .)
    MOD             reduce using rule 138 (primary -> function_designator .)
    LESS            reduce using rule 138 (primary -> function_designator .)
    NOTGREATER      reduce using rule 138 (primary -> function_designator .)
    EQUAL           reduce using rule 138 (primary -> function_designator .)
    NOTLESS         reduce using rule 138 (primary -> function_designator .)
    GREATER         reduce using rule 138 (primary -> function_designator .)
    NOTEQUAL        reduce using rule 138 (primary -> function_designator .)
    PLUS            reduce using rule 138 (primary -> function_designator .)
    MINUS           reduce using rule 138 (primary -> function_designator .)


state 129

    (166) boolean_primary -> variable .
    (137) primary -> variable .

    AND             reduce using rule 166 (boolean_primary -> variable .)
    OR              reduce using rule 166 (boolean_primary -> variable .)
    IMPL            reduce using rule 166 (boolean_primary -> variable .)
    EQUIV           reduce using rule 166 (boolean_primary -> variable .)
    END             reduce using rule 166 (boolean_primary -> variable .)
    SEMICOLON       reduce using rule 166 (boolean_primary -> variable .)
    ELSE            reduce using rule 166 (boolean_primary -> variable .)
    THEN            reduce using rule 166 (boolean_primary -> variable .)
    RCBRACKET       reduce using rule 166 (boolean_primary -> variable .)
    COMMA           reduce using rule 166 (boolean_primary -> variable .)
    DO              reduce using rule 166 (boolean_primary -> variable .)
    POWER           reduce using rule 137 (primary -> variable .)
    TIMES           reduce using rule 137 (primary -> variable .)
    DIV             reduce using rule 137 (primary -> variable .)
    MOD             reduce using rule 137 (primary -> variable .)
    LESS            reduce using rule 137 (primary -> variable .)
    NOTGREATER      reduce using rule 137 (primary -> variable .)
    EQUAL           reduce using rule 137 (primary -> variable .)
    NOTLESS         reduce using rule 137 (primary -> variable .)
    GREATER         reduce using rule 137 (primary -> variable .)
    NOTEQUAL        reduce using rule 137 (primary -> variable .)
    PLUS            reduce using rule 137 (primary -> variable .)
    MINUS           reduce using rule 137 (primary -> variable .)


state 130

    (109) if_clause -> IF boolean_expression . THEN

    THEN            shift and go to state 220


state 131

    (170) relation -> simple_arithmetic_expression . relational_operator simple_arithmetic_expression
    (125) simple_arithmetic_expression -> simple_arithmetic_expression . adding_operator term
    (185) relational_operator -> . LESS
    (186) relational_operator -> . NOTGREATER
    (187) relational_operator -> . EQUAL
    (188) relational_operator -> . NOTLESS
    (189) relational_operator -> . GREATER
    (190) relational_operator -> . NOTEQUAL
    (126) adding_operator -> . PLUS
    (127) adding_operator -> . MINUS

    LESS            shift and go to state 194
    NOTGREATER      shift and go to state 199
    EQUAL           shift and go to state 195
    NOTLESS         shift and go to state 198
    GREATER         shift and go to state 197
    NOTEQUAL        shift and go to state 192
    PLUS            shift and go to state 102
    MINUS           shift and go to state 94

    relational_operator            shift and go to state 193
    adding_operator                shift and go to state 196

state 132

    (19) local_or_own_type -> TOWN type .

    TARRAY          reduce using rule 19 (local_or_own_type -> TOWN type .)
    IDENTIFIER      reduce using rule 19 (local_or_own_type -> TOWN type .)


state 133

    (23) type_list -> simple_variable .
    (24) type_list -> simple_variable . COMMA type_list

    SEMICOLON       reduce using rule 23 (type_list -> simple_variable .)
    COMMA           shift and go to state 221


state 134

    (17) type_declaration -> local_or_own_type type_list .

    SEMICOLON       reduce using rule 17 (type_declaration -> local_or_own_type type_list .)


state 135

    (175) variable_identifier -> IDENTIFIER .

    COMMA           reduce using rule 175 (variable_identifier -> IDENTIFIER .)
    SEMICOLON       reduce using rule 175 (variable_identifier -> IDENTIFIER .)


state 136

    (26) array_declaration -> local_or_own_type TARRAY . array_list
    (27) array_list -> . array_segment
    (28) array_list -> . array_list COMMA array_segment
    (29) array_segment -> . array_identifier LBBRACKET bound_pair_list RBBRACKET
    (30) array_segment -> . array_identifier COMMA array_segment
    (31) array_identifier -> . IDENTIFIER

    IDENTIFIER      shift and go to state 83

    array_segment                  shift and go to state 81
    array_list                     shift and go to state 222
    array_identifier               shift and go to state 82

state 137

    (110) for_statement -> for_clause statement .

    END             reduce using rule 110 (for_statement -> for_clause statement .)
    SEMICOLON       reduce using rule 110 (for_statement -> for_clause statement .)


state 138

    (6) block_head -> BEGIN . declaration
    (13) declaration -> . type_declaration
    (14) declaration -> . array_declaration
    (15) declaration -> . switch_declaration
    (16) declaration -> . procedure_declaration
    (17) type_declaration -> . local_or_own_type type_list
    (25) array_declaration -> . TARRAY array_list
    (26) array_declaration -> . local_or_own_type TARRAY array_list
    (37) switch_declaration -> . SWITCH switch_identifier ASSIGNMENT switch_list
    (41) procedure_declaration -> . PROCEDURE procedure_heading procedure_body
    (42) procedure_declaration -> . type PROCEDURE procedure_heading procedure_body
    (18) local_or_own_type -> . type
    (19) local_or_own_type -> . TOWN type
    (20) type -> . TREAL
    (21) type -> . TINTEGER
    (22) type -> . TBOOLEAN

    TARRAY          shift and go to state 32
    SWITCH          shift and go to state 27
    PROCEDURE       shift and go to state 44
    TOWN            shift and go to state 46
    TREAL           shift and go to state 15
    TINTEGER        shift and go to state 18
    TBOOLEAN        shift and go to state 26

    type                           shift and go to state 31
    procedure_declaration          shift and go to state 48
    declaration                    shift and go to state 42
    type_declaration               shift and go to state 17
    local_or_own_type              shift and go to state 51
    switch_declaration             shift and go to state 39
    array_declaration              shift and go to state 53

state 139

    (4) block -> TLABEL COLON block .

    END             reduce using rule 4 (block -> TLABEL COLON block .)
    SEMICOLON       reduce using rule 4 (block -> TLABEL COLON block .)
    $end            reduce using rule 4 (block -> TLABEL COLON block .)
    ELSE            reduce using rule 4 (block -> TLABEL COLON block .)


state 140

    (10) unlabelled_compound -> BEGIN . compound_tail
    (11) compound_tail -> . statement END
    (12) compound_tail -> . statement SEMICOLON compound_tail
    (66) statement -> . unconditional_statement
    (67) statement -> . conditional_statement
    (68) statement -> . for_statement
    (69) unconditional_statement -> . basic_statement
    (70) unconditional_statement -> . compound_statement
    (71) unconditional_statement -> . block
    (104) conditional_statement -> . if_statement
    (105) conditional_statement -> . if_statement ELSE statement
    (106) conditional_statement -> . if_clause for_statement
    (107) conditional_statement -> . label COLON conditional_statement
    (110) for_statement -> . for_clause statement
    (111) for_statement -> . label COLON for_statement
    (72) basic_statement -> . unlabelled_basic_statement
    (73) basic_statement -> . label COLON basic_statement
    (8) compound_statement -> . unlabelled_compound
    (9) compound_statement -> . label COLON compound_statement
    (3) block -> . unlabelled_block
    (4) block -> . TLABEL COLON block
    (108) if_statement -> . if_clause unconditional_statement
    (109) if_clause -> . IF boolean_expression THEN
    (74) label -> . IDENTIFIER
    (75) label -> . unsigned_integer
    (112) for_clause -> . FOR variable ASSIGNMENT for_list DO
    (76) unlabelled_basic_statement -> . assignment_statement
    (77) unlabelled_basic_statement -> . go_to_statement
    (78) unlabelled_basic_statement -> . procedure_statement
    (10) unlabelled_compound -> . BEGIN compound_tail
    (5) unlabelled_block -> . block_head SEMICOLON compound_tail
    (146) unsigned_integer -> . DIGIT
    (147) unsigned_integer -> . unsigned_integer DIGIT
    (79) assignment_statement -> . left_part_list arithmetic_expression
    (80) assignment_statement -> . left_part_list boolean_expression
    (85) go_to_statement -> . GOTO designational_expression
    (92) procedure_statement -> . procedure_identifier actual_parameter_part
    (6) block_head -> . BEGIN declaration
    (7) block_head -> . block_head SEMICOLON declaration
    (81) left_part_list -> . left_part
    (82) left_part_list -> . left_part_list left_part
    (44) procedure_identifier -> . IDENTIFIER
    (83) left_part -> . variable ASSIGNMENT
    (84) left_part -> . procedure_identifier ASSIGNMENT
    (172) variable -> . simple_variable
    (173) variable -> . subscripted_variable
    (174) simple_variable -> . variable_identifier
    (176) subscripted_variable -> . array_identifier LBBRACKET subscript_list RBBRACKET
    (175) variable_identifier -> . IDENTIFIER
    (31) array_identifier -> . IDENTIFIER

    TLABEL          shift and go to state 4
    IF              shift and go to state 45
    IDENTIFIER      shift and go to state 47
    FOR             shift and go to state 37
    BEGIN           shift and go to state 1
    DIGIT           shift and go to state 6
    GOTO            shift and go to state 20

    subscripted_variable           shift and go to state 13
    block                          shift and go to state 54
    unlabelled_compound            shift and go to state 2
    array_identifier               shift and go to state 14
    if_clause                      shift and go to state 16
    block_head                     shift and go to state 10
    conditional_statement          shift and go to state 25
    left_part                      shift and go to state 34
    left_part_list                 shift and go to state 40
    compound_statement             shift and go to state 22
    assignment_statement           shift and go to state 23
    procedure_statement            shift and go to state 24
    label                          shift and go to state 19
    statement                      shift and go to state 29
    if_statement                   shift and go to state 30
    basic_statement                shift and go to state 33
    for_statement                  shift and go to state 35
    compound_tail                  shift and go to state 36
    go_to_statement                shift and go to state 38
    variable_identifier            shift and go to state 41
    variable                       shift and go to state 43
    unconditional_statement        shift and go to state 28
    unlabelled_block               shift and go to state 5
    procedure_identifier           shift and go to state 21
    simple_variable                shift and go to state 49
    unlabelled_basic_statement     shift and go to state 50
    for_clause                     shift and go to state 52
    unsigned_integer               shift and go to state 9

state 141

    (9) compound_statement -> label COLON compound_statement .

    SEMICOLON       reduce using rule 9 (compound_statement -> label COLON compound_statement .)
    END             reduce using rule 9 (compound_statement -> label COLON compound_statement .)
    $end            reduce using rule 9 (compound_statement -> label COLON compound_statement .)
    ELSE            reduce using rule 9 (compound_statement -> label COLON compound_statement .)


state 142

    (5) unlabelled_block -> block_head SEMICOLON compound_tail .

    $end            reduce using rule 5 (unlabelled_block -> block_head SEMICOLON compound_tail .)
    END             reduce using rule 5 (unlabelled_block -> block_head SEMICOLON compound_tail .)
    SEMICOLON       reduce using rule 5 (unlabelled_block -> block_head SEMICOLON compound_tail .)
    ELSE            reduce using rule 5 (unlabelled_block -> block_head SEMICOLON compound_tail .)


state 143

    (7) block_head -> block_head SEMICOLON declaration .

    SEMICOLON       reduce using rule 7 (block_head -> block_head SEMICOLON declaration .)


state 144

    (122) arithmetic_expression -> if_clause . simple_arithmetic_expression ELSE arithmetic_expression
    (123) simple_arithmetic_expression -> . term
    (124) simple_arithmetic_expression -> . adding_operator term
    (125) simple_arithmetic_expression -> . simple_arithmetic_expression adding_operator term
    (128) term -> . factor
    (129) term -> . term multiplying_operator factor
    (126) adding_operator -> . PLUS
    (127) adding_operator -> . MINUS
    (133) factor -> . primary
    (134) factor -> . factor
    (135) factor -> . factor POWER primary
    (136) primary -> . unsigned_number
    (137) primary -> . variable
    (138) primary -> . function_designator
    (139) primary -> . LCBRACKET arithmetic_expression RCBRACKET
    (140) unsigned_number -> . decimal_number
    (141) unsigned_number -> . exponential_part
    (142) unsigned_number -> . decimal_number exponential_part
    (172) variable -> . simple_variable
    (173) variable -> . subscripted_variable
    (171) function_designator -> . procedure_identifier actual_parameter_part
    (143) decimal_number -> . unsigned_integer
    (144) decimal_number -> . decimal_fraction
    (145) decimal_number -> . unsigned_integer decimal_fraction
    (149) exponential_part -> . EREAL integer
    (174) simple_variable -> . variable_identifier
    (176) subscripted_variable -> . array_identifier LBBRACKET subscript_list RBBRACKET
    (44) procedure_identifier -> . IDENTIFIER
    (146) unsigned_integer -> . DIGIT
    (147) unsigned_integer -> . unsigned_integer DIGIT
    (148) decimal_fraction -> . DOT unsigned_integer
    (175) variable_identifier -> . IDENTIFIER
    (31) array_identifier -> . IDENTIFIER

    PLUS            shift and go to state 102
    MINUS           shift and go to state 94
    LCBRACKET       shift and go to state 145
    EREAL           shift and go to state 115
    IDENTIFIER      shift and go to state 106
    DIGIT           shift and go to state 6
    DOT             shift and go to state 95

    subscripted_variable           shift and go to state 13
    primary                        shift and go to state 98
    unsigned_number                shift and go to state 105
    decimal_fraction               shift and go to state 103
    factor                         shift and go to state 104
    simple_arithmetic_expression   shift and go to state 223
    decimal_number                 shift and go to state 112
    variable_identifier            shift and go to state 41
    function_designator            shift and go to state 149
    array_identifier               shift and go to state 14
    variable                       shift and go to state 150
    exponential_part               shift and go to state 92
    term                           shift and go to state 113
    procedure_identifier           shift and go to state 125
    simple_variable                shift and go to state 49
    adding_operator                shift and go to state 117
    unsigned_integer               shift and go to state 120

state 145

    (139) primary -> LCBRACKET . arithmetic_expression RCBRACKET
    (121) arithmetic_expression -> . simple_arithmetic_expression
    (122) arithmetic_expression -> . if_clause simple_arithmetic_expression ELSE arithmetic_expression
    (123) simple_arithmetic_expression -> . term
    (124) simple_arithmetic_expression -> . adding_operator term
    (125) simple_arithmetic_expression -> . simple_arithmetic_expression adding_operator term
    (109) if_clause -> . IF boolean_expression THEN
    (128) term -> . factor
    (129) term -> . term multiplying_operator factor
    (126) adding_operator -> . PLUS
    (127) adding_operator -> . MINUS
    (133) factor -> . primary
    (134) factor -> . factor
    (135) factor -> . factor POWER primary
    (136) primary -> . unsigned_number
    (137) primary -> . variable
    (138) primary -> . function_designator
    (139) primary -> . LCBRACKET arithmetic_expression RCBRACKET
    (140) unsigned_number -> . decimal_number
    (141) unsigned_number -> . exponential_part
    (142) unsigned_number -> . decimal_number exponential_part
    (172) variable -> . simple_variable
    (173) variable -> . subscripted_variable
    (171) function_designator -> . procedure_identifier actual_parameter_part
    (143) decimal_number -> . unsigned_integer
    (144) decimal_number -> . decimal_fraction
    (145) decimal_number -> . unsigned_integer decimal_fraction
    (149) exponential_part -> . EREAL integer
    (174) simple_variable -> . variable_identifier
    (176) subscripted_variable -> . array_identifier LBBRACKET subscript_list RBBRACKET
    (44) procedure_identifier -> . IDENTIFIER
    (146) unsigned_integer -> . DIGIT
    (147) unsigned_integer -> . unsigned_integer DIGIT
    (148) decimal_fraction -> . DOT unsigned_integer
    (175) variable_identifier -> . IDENTIFIER
    (31) array_identifier -> . IDENTIFIER

    IF              shift and go to state 45
    PLUS            shift and go to state 102
    MINUS           shift and go to state 94
    LCBRACKET       shift and go to state 145
    EREAL           shift and go to state 115
    IDENTIFIER      shift and go to state 106
    DIGIT           shift and go to state 6
    DOT             shift and go to state 95

    subscripted_variable           shift and go to state 13
    primary                        shift and go to state 98
    if_clause                      shift and go to state 144
    unsigned_number                shift and go to state 105
    decimal_fraction               shift and go to state 103
    factor                         shift and go to state 104
    simple_arithmetic_expression   shift and go to state 147
    arithmetic_expression          shift and go to state 209
    decimal_number                 shift and go to state 112
    variable_identifier            shift and go to state 41
    function_designator            shift and go to state 149
    array_identifier               shift and go to state 14
    variable                       shift and go to state 150
    exponential_part               shift and go to state 92
    term                           shift and go to state 113
    procedure_identifier           shift and go to state 125
    simple_variable                shift and go to state 49
    adding_operator                shift and go to state 117
    unsigned_integer               shift and go to state 120

state 146

    (177) subscript_list -> subscript_expression .

    RBBRACKET       reduce using rule 177 (subscript_list -> subscript_expression .)
    COMMA           reduce using rule 177 (subscript_list -> subscript_expression .)


state 147

    (121) arithmetic_expression -> simple_arithmetic_expression .
    (125) simple_arithmetic_expression -> simple_arithmetic_expression . adding_operator term
    (126) adding_operator -> . PLUS
    (127) adding_operator -> . MINUS

    UNTIL           reduce using rule 121 (arithmetic_expression -> simple_arithmetic_expression .)
    COLON           reduce using rule 121 (arithmetic_expression -> simple_arithmetic_expression .)
    RBBRACKET       reduce using rule 121 (arithmetic_expression -> simple_arithmetic_expression .)
    COMMA           reduce using rule 121 (arithmetic_expression -> simple_arithmetic_expression .)
    DO              reduce using rule 121 (arithmetic_expression -> simple_arithmetic_expression .)
    RCBRACKET       reduce using rule 121 (arithmetic_expression -> simple_arithmetic_expression .)
    STEP            reduce using rule 121 (arithmetic_expression -> simple_arithmetic_expression .)
    WHILE           reduce using rule 121 (arithmetic_expression -> simple_arithmetic_expression .)
    END             reduce using rule 121 (arithmetic_expression -> simple_arithmetic_expression .)
    SEMICOLON       reduce using rule 121 (arithmetic_expression -> simple_arithmetic_expression .)
    ELSE            reduce using rule 121 (arithmetic_expression -> simple_arithmetic_expression .)
    PLUS            shift and go to state 102
    MINUS           shift and go to state 94

    adding_operator                shift and go to state 196

state 148

    (179) subscript_expression -> arithmetic_expression .

    RBBRACKET       reduce using rule 179 (subscript_expression -> arithmetic_expression .)
    COMMA           reduce using rule 179 (subscript_expression -> arithmetic_expression .)


state 149

    (138) primary -> function_designator .

    POWER           reduce using rule 138 (primary -> function_designator .)
    TIMES           reduce using rule 138 (primary -> function_designator .)
    DIV             reduce using rule 138 (primary -> function_designator .)
    MOD             reduce using rule 138 (primary -> function_designator .)
    ELSE            reduce using rule 138 (primary -> function_designator .)
    PLUS            reduce using rule 138 (primary -> function_designator .)
    MINUS           reduce using rule 138 (primary -> function_designator .)
    RBBRACKET       reduce using rule 138 (primary -> function_designator .)
    COMMA           reduce using rule 138 (primary -> function_designator .)
    STEP            reduce using rule 138 (primary -> function_designator .)
    WHILE           reduce using rule 138 (primary -> function_designator .)
    DO              reduce using rule 138 (primary -> function_designator .)
    UNTIL           reduce using rule 138 (primary -> function_designator .)
    COLON           reduce using rule 138 (primary -> function_designator .)
    RCBRACKET       reduce using rule 138 (primary -> function_designator .)
    END             reduce using rule 138 (primary -> function_designator .)
    SEMICOLON       reduce using rule 138 (primary -> function_designator .)
    LESS            reduce using rule 138 (primary -> function_designator .)
    NOTGREATER      reduce using rule 138 (primary -> function_designator .)
    EQUAL           reduce using rule 138 (primary -> function_designator .)
    NOTLESS         reduce using rule 138 (primary -> function_designator .)
    GREATER         reduce using rule 138 (primary -> function_designator .)
    NOTEQUAL        reduce using rule 138 (primary -> function_designator .)
    AND             reduce using rule 138 (primary -> function_designator .)
    OR              reduce using rule 138 (primary -> function_designator .)
    IMPL            reduce using rule 138 (primary -> function_designator .)
    EQUIV           reduce using rule 138 (primary -> function_designator .)
    THEN            reduce using rule 138 (primary -> function_designator .)


state 150

    (137) primary -> variable .

    POWER           reduce using rule 137 (primary -> variable .)
    TIMES           reduce using rule 137 (primary -> variable .)
    DIV             reduce using rule 137 (primary -> variable .)
    MOD             reduce using rule 137 (primary -> variable .)
    ELSE            reduce using rule 137 (primary -> variable .)
    PLUS            reduce using rule 137 (primary -> variable .)
    MINUS           reduce using rule 137 (primary -> variable .)
    RBBRACKET       reduce using rule 137 (primary -> variable .)
    COMMA           reduce using rule 137 (primary -> variable .)
    STEP            reduce using rule 137 (primary -> variable .)
    WHILE           reduce using rule 137 (primary -> variable .)
    DO              reduce using rule 137 (primary -> variable .)
    UNTIL           reduce using rule 137 (primary -> variable .)
    COLON           reduce using rule 137 (primary -> variable .)
    RCBRACKET       reduce using rule 137 (primary -> variable .)
    END             reduce using rule 137 (primary -> variable .)
    SEMICOLON       reduce using rule 137 (primary -> variable .)
    LESS            reduce using rule 137 (primary -> variable .)
    NOTGREATER      reduce using rule 137 (primary -> variable .)
    EQUAL           reduce using rule 137 (primary -> variable .)
    NOTLESS         reduce using rule 137 (primary -> variable .)
    GREATER         reduce using rule 137 (primary -> variable .)
    NOTEQUAL        reduce using rule 137 (primary -> variable .)
    AND             reduce using rule 137 (primary -> variable .)
    OR              reduce using rule 137 (primary -> variable .)
    IMPL            reduce using rule 137 (primary -> variable .)
    EQUIV           reduce using rule 137 (primary -> variable .)
    THEN            reduce using rule 137 (primary -> variable .)


state 151

    (176) subscripted_variable -> array_identifier LBBRACKET subscript_list . RBBRACKET
    (178) subscript_list -> subscript_list . COMMA subscript_expression

    RBBRACKET       shift and go to state 224
    COMMA           shift and go to state 225


state 152

    (111) for_statement -> label COLON . for_statement
    (73) basic_statement -> label COLON . basic_statement
    (9) compound_statement -> label COLON . compound_statement
    (110) for_statement -> . for_clause statement
    (111) for_statement -> . label COLON for_statement
    (72) basic_statement -> . unlabelled_basic_statement
    (73) basic_statement -> . label COLON basic_statement
    (8) compound_statement -> . unlabelled_compound
    (9) compound_statement -> . label COLON compound_statement
    (112) for_clause -> . FOR variable ASSIGNMENT for_list DO
    (74) label -> . IDENTIFIER
    (75) label -> . unsigned_integer
    (76) unlabelled_basic_statement -> . assignment_statement
    (77) unlabelled_basic_statement -> . go_to_statement
    (78) unlabelled_basic_statement -> . procedure_statement
    (10) unlabelled_compound -> . BEGIN compound_tail
    (146) unsigned_integer -> . DIGIT
    (147) unsigned_integer -> . unsigned_integer DIGIT
    (79) assignment_statement -> . left_part_list arithmetic_expression
    (80) assignment_statement -> . left_part_list boolean_expression
    (85) go_to_statement -> . GOTO designational_expression
    (92) procedure_statement -> . procedure_identifier actual_parameter_part
    (81) left_part_list -> . left_part
    (82) left_part_list -> . left_part_list left_part
    (44) procedure_identifier -> . IDENTIFIER
    (83) left_part -> . variable ASSIGNMENT
    (84) left_part -> . procedure_identifier ASSIGNMENT
    (172) variable -> . simple_variable
    (173) variable -> . subscripted_variable
    (174) simple_variable -> . variable_identifier
    (176) subscripted_variable -> . array_identifier LBBRACKET subscript_list RBBRACKET
    (175) variable_identifier -> . IDENTIFIER
    (31) array_identifier -> . IDENTIFIER

    FOR             shift and go to state 37
    IDENTIFIER      shift and go to state 47
    BEGIN           shift and go to state 140
    DIGIT           shift and go to state 6
    GOTO            shift and go to state 20

    subscripted_variable           shift and go to state 13
    unlabelled_compound            shift and go to state 2
    left_part                      shift and go to state 34
    left_part_list                 shift and go to state 40
    compound_statement             shift and go to state 141
    assignment_statement           shift and go to state 23
    procedure_statement            shift and go to state 24
    label                          shift and go to state 60
    basic_statement                shift and go to state 154
    for_statement                  shift and go to state 155
    go_to_statement                shift and go to state 38
    variable_identifier            shift and go to state 41
    array_identifier               shift and go to state 14
    variable                       shift and go to state 43
    procedure_identifier           shift and go to state 21
    simple_variable                shift and go to state 49
    unlabelled_basic_statement     shift and go to state 50
    for_clause                     shift and go to state 52
    unsigned_integer               shift and go to state 9

state 153

    (107) conditional_statement -> label COLON conditional_statement .

    END             reduce using rule 107 (conditional_statement -> label COLON conditional_statement .)
    SEMICOLON       reduce using rule 107 (conditional_statement -> label COLON conditional_statement .)


state 154

    (73) basic_statement -> label COLON basic_statement .

    END             reduce using rule 73 (basic_statement -> label COLON basic_statement .)
    SEMICOLON       reduce using rule 73 (basic_statement -> label COLON basic_statement .)
    ELSE            reduce using rule 73 (basic_statement -> label COLON basic_statement .)


state 155

    (111) for_statement -> label COLON for_statement .

    END             reduce using rule 111 (for_statement -> label COLON for_statement .)
    SEMICOLON       reduce using rule 111 (for_statement -> label COLON for_statement .)


state 156

    (87) designational_expression -> if_clause simple_designational_expression . ELSE designational_expression

    ELSE            shift and go to state 226


state 157

    (91) switch_designator -> switch_identifier LBBRACKET . subscript_expression RBBRACKET
    (179) subscript_expression -> . arithmetic_expression
    (121) arithmetic_expression -> . simple_arithmetic_expression
    (122) arithmetic_expression -> . if_clause simple_arithmetic_expression ELSE arithmetic_expression
    (123) simple_arithmetic_expression -> . term
    (124) simple_arithmetic_expression -> . adding_operator term
    (125) simple_arithmetic_expression -> . simple_arithmetic_expression adding_operator term
    (109) if_clause -> . IF boolean_expression THEN
    (128) term -> . factor
    (129) term -> . term multiplying_operator factor
    (126) adding_operator -> . PLUS
    (127) adding_operator -> . MINUS
    (133) factor -> . primary
    (134) factor -> . factor
    (135) factor -> . factor POWER primary
    (136) primary -> . unsigned_number
    (137) primary -> . variable
    (138) primary -> . function_designator
    (139) primary -> . LCBRACKET arithmetic_expression RCBRACKET
    (140) unsigned_number -> . decimal_number
    (141) unsigned_number -> . exponential_part
    (142) unsigned_number -> . decimal_number exponential_part
    (172) variable -> . simple_variable
    (173) variable -> . subscripted_variable
    (171) function_designator -> . procedure_identifier actual_parameter_part
    (143) decimal_number -> . unsigned_integer
    (144) decimal_number -> . decimal_fraction
    (145) decimal_number -> . unsigned_integer decimal_fraction
    (149) exponential_part -> . EREAL integer
    (174) simple_variable -> . variable_identifier
    (176) subscripted_variable -> . array_identifier LBBRACKET subscript_list RBBRACKET
    (44) procedure_identifier -> . IDENTIFIER
    (146) unsigned_integer -> . DIGIT
    (147) unsigned_integer -> . unsigned_integer DIGIT
    (148) decimal_fraction -> . DOT unsigned_integer
    (175) variable_identifier -> . IDENTIFIER
    (31) array_identifier -> . IDENTIFIER

    IF              shift and go to state 45
    PLUS            shift and go to state 102
    MINUS           shift and go to state 94
    LCBRACKET       shift and go to state 145
    EREAL           shift and go to state 115
    IDENTIFIER      shift and go to state 106
    DIGIT           shift and go to state 6
    DOT             shift and go to state 95

    subscripted_variable           shift and go to state 13
    primary                        shift and go to state 98
    if_clause                      shift and go to state 144
    subscript_expression           shift and go to state 227
    decimal_fraction               shift and go to state 103
    factor                         shift and go to state 104
    unsigned_number                shift and go to state 105
    simple_arithmetic_expression   shift and go to state 147
    arithmetic_expression          shift and go to state 148
    decimal_number                 shift and go to state 112
    variable_identifier            shift and go to state 41
    function_designator            shift and go to state 149
    array_identifier               shift and go to state 14
    variable                       shift and go to state 150
    exponential_part               shift and go to state 92
    term                           shift and go to state 113
    procedure_identifier           shift and go to state 125
    simple_variable                shift and go to state 49
    adding_operator                shift and go to state 117
    unsigned_integer               shift and go to state 120

state 158

    (90) simple_designational_expression -> LCBRACKET designational_expression . RCBRACKET

    RCBRACKET       shift and go to state 228


state 159

    (94) actual_parameter_part -> LCBRACKET actual_parameter_list . RCBRACKET
    (96) actual_parameter_list -> actual_parameter_list . parameter_delimiter actual_parameter
    (97) parameter_delimiter -> . COMMA
    (98) parameter_delimiter -> . RCBRACKET letter_string COLON LCBRACKET

    RCBRACKET       shift and go to state 229
    COMMA           shift and go to state 231

    parameter_delimiter            shift and go to state 230

state 160

    (122) arithmetic_expression -> if_clause . simple_arithmetic_expression ELSE arithmetic_expression
    (154) boolean_expression -> if_clause . simple_boolean ELSE boolean_expression
    (87) designational_expression -> if_clause . simple_designational_expression ELSE designational_expression
    (123) simple_arithmetic_expression -> . term
    (124) simple_arithmetic_expression -> . adding_operator term
    (125) simple_arithmetic_expression -> . simple_arithmetic_expression adding_operator term
    (155) simple_boolean -> . implication
    (156) simple_boolean -> . simple_boolean EQUIV implication
    (88) simple_designational_expression -> . label
    (89) simple_designational_expression -> . switch_designator
    (90) simple_designational_expression -> . LCBRACKET designational_expression RCBRACKET
    (128) term -> . factor
    (129) term -> . term multiplying_operator factor
    (126) adding_operator -> . PLUS
    (127) adding_operator -> . MINUS
    (157) implication -> . boolean_term
    (158) implication -> . implication IMPL boolean_term
    (74) label -> . IDENTIFIER
    (75) label -> . unsigned_integer
    (91) switch_designator -> . switch_identifier LBBRACKET subscript_expression RBBRACKET
    (133) factor -> . primary
    (134) factor -> . factor
    (135) factor -> . factor POWER primary
    (159) boolean_term -> . boolean_factor
    (160) boolean_term -> . boolean_term OR boolean_factor
    (146) unsigned_integer -> . DIGIT
    (147) unsigned_integer -> . unsigned_integer DIGIT
    (38) switch_identifier -> . IDENTIFIER
    (136) primary -> . unsigned_number
    (137) primary -> . variable
    (138) primary -> . function_designator
    (139) primary -> . LCBRACKET arithmetic_expression RCBRACKET
    (161) boolean_factor -> . boolean_secondary
    (162) boolean_factor -> . boolean_factor AND boolean_secondary
    (140) unsigned_number -> . decimal_number
    (141) unsigned_number -> . exponential_part
    (142) unsigned_number -> . decimal_number exponential_part
    (172) variable -> . simple_variable
    (173) variable -> . subscripted_variable
    (171) function_designator -> . procedure_identifier actual_parameter_part
    (163) boolean_secondary -> . boolean_primary
    (164) boolean_secondary -> . NOT boolean_primary
    (143) decimal_number -> . unsigned_integer
    (144) decimal_number -> . decimal_fraction
    (145) decimal_number -> . unsigned_integer decimal_fraction
    (149) exponential_part -> . EREAL integer
    (174) simple_variable -> . variable_identifier
    (176) subscripted_variable -> . array_identifier LBBRACKET subscript_list RBBRACKET
    (44) procedure_identifier -> . IDENTIFIER
    (165) boolean_primary -> . logical_value
    (166) boolean_primary -> . variable
    (167) boolean_primary -> . function_designator
    (168) boolean_primary -> . relation
    (169) boolean_primary -> . LCBRACKET boolean_expression RCBRACKET
    (148) decimal_fraction -> . DOT unsigned_integer
    (175) variable_identifier -> . IDENTIFIER
    (31) array_identifier -> . IDENTIFIER
    (183) logical_value -> . TRUE
    (184) logical_value -> . FALSE
    (170) relation -> . simple_arithmetic_expression relational_operator simple_arithmetic_expression

    LCBRACKET       shift and go to state 170
    PLUS            shift and go to state 102
    MINUS           shift and go to state 94
    IDENTIFIER      shift and go to state 232
    DIGIT           shift and go to state 6
    NOT             shift and go to state 118
    EREAL           shift and go to state 115
    DOT             shift and go to state 95
    TRUE            shift and go to state 93
    FALSE           shift and go to state 100

    boolean_primary                shift and go to state 99
    procedure_identifier           shift and go to state 125
    primary                        shift and go to state 98
    boolean_factor                 shift and go to state 90
    relation                       shift and go to state 91
    simple_boolean                 shift and go to state 187
    boolean_secondary              shift and go to state 101
    label                          shift and go to state 67
    decimal_fraction               shift and go to state 103
    switch_identifier              shift and go to state 68
    unsigned_number                shift and go to state 105
    simple_arithmetic_expression   shift and go to state 186
    simple_designational_expression shift and go to state 156
    logical_value                  shift and go to state 109
    factor                         shift and go to state 104
    decimal_number                 shift and go to state 112
    boolean_term                   shift and go to state 88
    variable_identifier            shift and go to state 41
    function_designator            shift and go to state 110
    array_identifier               shift and go to state 14
    variable                       shift and go to state 161
    exponential_part               shift and go to state 92
    term                           shift and go to state 113
    switch_designator              shift and go to state 65
    subscripted_variable           shift and go to state 13
    simple_variable                shift and go to state 49
    adding_operator                shift and go to state 117
    implication                    shift and go to state 119
    unsigned_integer               shift and go to state 175

state 161

    (137) primary -> variable .
    (166) boolean_primary -> variable .

  ! reduce/reduce conflict for ELSE resolved using rule 137 (primary -> variable .)
  ! reduce/reduce conflict for RCBRACKET resolved using rule 137 (primary -> variable .)
  ! reduce/reduce conflict for COMMA resolved using rule 137 (primary -> variable .)
    POWER           reduce using rule 137 (primary -> variable .)
    TIMES           reduce using rule 137 (primary -> variable .)
    DIV             reduce using rule 137 (primary -> variable .)
    MOD             reduce using rule 137 (primary -> variable .)
    PLUS            reduce using rule 137 (primary -> variable .)
    MINUS           reduce using rule 137 (primary -> variable .)
    LESS            reduce using rule 137 (primary -> variable .)
    NOTGREATER      reduce using rule 137 (primary -> variable .)
    EQUAL           reduce using rule 137 (primary -> variable .)
    NOTLESS         reduce using rule 137 (primary -> variable .)
    GREATER         reduce using rule 137 (primary -> variable .)
    NOTEQUAL        reduce using rule 137 (primary -> variable .)
    RCBRACKET       reduce using rule 137 (primary -> variable .)
    COMMA           reduce using rule 137 (primary -> variable .)
    ELSE            reduce using rule 137 (primary -> variable .)
    AND             reduce using rule 166 (boolean_primary -> variable .)
    OR              reduce using rule 166 (boolean_primary -> variable .)
    IMPL            reduce using rule 166 (boolean_primary -> variable .)
    EQUIV           reduce using rule 166 (boolean_primary -> variable .)

  ! ELSE            [ reduce using rule 166 (boolean_primary -> variable .) ]
  ! RCBRACKET       [ reduce using rule 166 (boolean_primary -> variable .) ]
  ! COMMA           [ reduce using rule 166 (boolean_primary -> variable .) ]


state 162

    (93) actual_parameter_part -> LCBRACKET RCBRACKET .

    POWER           reduce using rule 93 (actual_parameter_part -> LCBRACKET RCBRACKET .)
    TIMES           reduce using rule 93 (actual_parameter_part -> LCBRACKET RCBRACKET .)
    DIV             reduce using rule 93 (actual_parameter_part -> LCBRACKET RCBRACKET .)
    MOD             reduce using rule 93 (actual_parameter_part -> LCBRACKET RCBRACKET .)
    PLUS            reduce using rule 93 (actual_parameter_part -> LCBRACKET RCBRACKET .)
    MINUS           reduce using rule 93 (actual_parameter_part -> LCBRACKET RCBRACKET .)
    LESS            reduce using rule 93 (actual_parameter_part -> LCBRACKET RCBRACKET .)
    NOTGREATER      reduce using rule 93 (actual_parameter_part -> LCBRACKET RCBRACKET .)
    EQUAL           reduce using rule 93 (actual_parameter_part -> LCBRACKET RCBRACKET .)
    NOTLESS         reduce using rule 93 (actual_parameter_part -> LCBRACKET RCBRACKET .)
    GREATER         reduce using rule 93 (actual_parameter_part -> LCBRACKET RCBRACKET .)
    NOTEQUAL        reduce using rule 93 (actual_parameter_part -> LCBRACKET RCBRACKET .)
    END             reduce using rule 93 (actual_parameter_part -> LCBRACKET RCBRACKET .)
    SEMICOLON       reduce using rule 93 (actual_parameter_part -> LCBRACKET RCBRACKET .)
    ELSE            reduce using rule 93 (actual_parameter_part -> LCBRACKET RCBRACKET .)
    AND             reduce using rule 93 (actual_parameter_part -> LCBRACKET RCBRACKET .)
    OR              reduce using rule 93 (actual_parameter_part -> LCBRACKET RCBRACKET .)
    IMPL            reduce using rule 93 (actual_parameter_part -> LCBRACKET RCBRACKET .)
    EQUIV           reduce using rule 93 (actual_parameter_part -> LCBRACKET RCBRACKET .)
    RCBRACKET       reduce using rule 93 (actual_parameter_part -> LCBRACKET RCBRACKET .)
    COMMA           reduce using rule 93 (actual_parameter_part -> LCBRACKET RCBRACKET .)
    THEN            reduce using rule 93 (actual_parameter_part -> LCBRACKET RCBRACKET .)
    RBBRACKET       reduce using rule 93 (actual_parameter_part -> LCBRACKET RCBRACKET .)
    COLON           reduce using rule 93 (actual_parameter_part -> LCBRACKET RCBRACKET .)
    STEP            reduce using rule 93 (actual_parameter_part -> LCBRACKET RCBRACKET .)
    WHILE           reduce using rule 93 (actual_parameter_part -> LCBRACKET RCBRACKET .)
    DO              reduce using rule 93 (actual_parameter_part -> LCBRACKET RCBRACKET .)
    UNTIL           reduce using rule 93 (actual_parameter_part -> LCBRACKET RCBRACKET .)


state 163

    (95) actual_parameter_list -> actual_parameter .

    RCBRACKET       reduce using rule 95 (actual_parameter_list -> actual_parameter .)
    COMMA           reduce using rule 95 (actual_parameter_list -> actual_parameter .)


state 164

    (102) actual_parameter -> switch_identifier .
    (91) switch_designator -> switch_identifier . LBBRACKET subscript_expression RBBRACKET

    RCBRACKET       reduce using rule 102 (actual_parameter -> switch_identifier .)
    COMMA           reduce using rule 102 (actual_parameter -> switch_identifier .)
    LBBRACKET       shift and go to state 157


state 165

    (180) string -> STRING .

    RCBRACKET       reduce using rule 180 (string -> STRING .)
    COMMA           reduce using rule 180 (string -> STRING .)


state 166

    (31) array_identifier -> IDENTIFIER .
    (38) switch_identifier -> IDENTIFIER .
    (44) procedure_identifier -> IDENTIFIER .
    (74) label -> IDENTIFIER .
    (175) variable_identifier -> IDENTIFIER .

  ! reduce/reduce conflict for LBBRACKET resolved using rule 31 (array_identifier -> IDENTIFIER .)
  ! reduce/reduce conflict for RCBRACKET resolved using rule 31 (array_identifier -> IDENTIFIER .)
  ! reduce/reduce conflict for COMMA resolved using rule 31 (array_identifier -> IDENTIFIER .)
  ! reduce/reduce conflict for RCBRACKET resolved using rule 31 (array_identifier -> IDENTIFIER .)
  ! reduce/reduce conflict for COMMA resolved using rule 31 (array_identifier -> IDENTIFIER .)
  ! reduce/reduce conflict for RCBRACKET resolved using rule 31 (array_identifier -> IDENTIFIER .)
  ! reduce/reduce conflict for COMMA resolved using rule 31 (array_identifier -> IDENTIFIER .)
  ! reduce/reduce conflict for RCBRACKET resolved using rule 31 (array_identifier -> IDENTIFIER .)
  ! reduce/reduce conflict for COMMA resolved using rule 31 (array_identifier -> IDENTIFIER .)
    LBBRACKET       reduce using rule 31 (array_identifier -> IDENTIFIER .)
    RCBRACKET       reduce using rule 31 (array_identifier -> IDENTIFIER .)
    COMMA           reduce using rule 31 (array_identifier -> IDENTIFIER .)
    LCBRACKET       reduce using rule 44 (procedure_identifier -> IDENTIFIER .)
    POWER           reduce using rule 175 (variable_identifier -> IDENTIFIER .)
    TIMES           reduce using rule 175 (variable_identifier -> IDENTIFIER .)
    DIV             reduce using rule 175 (variable_identifier -> IDENTIFIER .)
    MOD             reduce using rule 175 (variable_identifier -> IDENTIFIER .)
    PLUS            reduce using rule 175 (variable_identifier -> IDENTIFIER .)
    MINUS           reduce using rule 175 (variable_identifier -> IDENTIFIER .)
    LESS            reduce using rule 175 (variable_identifier -> IDENTIFIER .)
    NOTGREATER      reduce using rule 175 (variable_identifier -> IDENTIFIER .)
    EQUAL           reduce using rule 175 (variable_identifier -> IDENTIFIER .)
    NOTLESS         reduce using rule 175 (variable_identifier -> IDENTIFIER .)
    GREATER         reduce using rule 175 (variable_identifier -> IDENTIFIER .)
    NOTEQUAL        reduce using rule 175 (variable_identifier -> IDENTIFIER .)
    AND             reduce using rule 175 (variable_identifier -> IDENTIFIER .)
    OR              reduce using rule 175 (variable_identifier -> IDENTIFIER .)
    IMPL            reduce using rule 175 (variable_identifier -> IDENTIFIER .)
    EQUIV           reduce using rule 175 (variable_identifier -> IDENTIFIER .)

  ! LBBRACKET       [ reduce using rule 38 (switch_identifier -> IDENTIFIER .) ]
  ! RCBRACKET       [ reduce using rule 38 (switch_identifier -> IDENTIFIER .) ]
  ! COMMA           [ reduce using rule 38 (switch_identifier -> IDENTIFIER .) ]
  ! RCBRACKET       [ reduce using rule 44 (procedure_identifier -> IDENTIFIER .) ]
  ! COMMA           [ reduce using rule 44 (procedure_identifier -> IDENTIFIER .) ]
  ! RCBRACKET       [ reduce using rule 74 (label -> IDENTIFIER .) ]
  ! COMMA           [ reduce using rule 74 (label -> IDENTIFIER .) ]
  ! RCBRACKET       [ reduce using rule 175 (variable_identifier -> IDENTIFIER .) ]
  ! COMMA           [ reduce using rule 175 (variable_identifier -> IDENTIFIER .) ]


state 167

    (118) expression -> arithmetic_expression .

    RCBRACKET       reduce using rule 118 (expression -> arithmetic_expression .)
    COMMA           reduce using rule 118 (expression -> arithmetic_expression .)


state 168

    (99) actual_parameter -> string .

    RCBRACKET       reduce using rule 99 (actual_parameter -> string .)
    COMMA           reduce using rule 99 (actual_parameter -> string .)


state 169

    (101) actual_parameter -> array_identifier .
    (176) subscripted_variable -> array_identifier . LBBRACKET subscript_list RBBRACKET

    RCBRACKET       reduce using rule 101 (actual_parameter -> array_identifier .)
    COMMA           reduce using rule 101 (actual_parameter -> array_identifier .)
    LBBRACKET       shift and go to state 59


state 170

    (90) simple_designational_expression -> LCBRACKET . designational_expression RCBRACKET
    (139) primary -> LCBRACKET . arithmetic_expression RCBRACKET
    (169) boolean_primary -> LCBRACKET . boolean_expression RCBRACKET
    (86) designational_expression -> . simple_designational_expression
    (87) designational_expression -> . if_clause simple_designational_expression ELSE designational_expression
    (121) arithmetic_expression -> . simple_arithmetic_expression
    (122) arithmetic_expression -> . if_clause simple_arithmetic_expression ELSE arithmetic_expression
    (153) boolean_expression -> . simple_boolean
    (154) boolean_expression -> . if_clause simple_boolean ELSE boolean_expression
    (88) simple_designational_expression -> . label
    (89) simple_designational_expression -> . switch_designator
    (90) simple_designational_expression -> . LCBRACKET designational_expression RCBRACKET
    (109) if_clause -> . IF boolean_expression THEN
    (123) simple_arithmetic_expression -> . term
    (124) simple_arithmetic_expression -> . adding_operator term
    (125) simple_arithmetic_expression -> . simple_arithmetic_expression adding_operator term
    (155) simple_boolean -> . implication
    (156) simple_boolean -> . simple_boolean EQUIV implication
    (74) label -> . IDENTIFIER
    (75) label -> . unsigned_integer
    (91) switch_designator -> . switch_identifier LBBRACKET subscript_expression RBBRACKET
    (128) term -> . factor
    (129) term -> . term multiplying_operator factor
    (126) adding_operator -> . PLUS
    (127) adding_operator -> . MINUS
    (157) implication -> . boolean_term
    (158) implication -> . implication IMPL boolean_term
    (146) unsigned_integer -> . DIGIT
    (147) unsigned_integer -> . unsigned_integer DIGIT
    (38) switch_identifier -> . IDENTIFIER
    (133) factor -> . primary
    (134) factor -> . factor
    (135) factor -> . factor POWER primary
    (159) boolean_term -> . boolean_factor
    (160) boolean_term -> . boolean_term OR boolean_factor
    (136) primary -> . unsigned_number
    (137) primary -> . variable
    (138) primary -> . function_designator
    (139) primary -> . LCBRACKET arithmetic_expression RCBRACKET
    (161) boolean_factor -> . boolean_secondary
    (162) boolean_factor -> . boolean_factor AND boolean_secondary
    (140) unsigned_number -> . decimal_number
    (141) unsigned_number -> . exponential_part
    (142) unsigned_number -> . decimal_number exponential_part
    (172) variable -> . simple_variable
    (173) variable -> . subscripted_variable
    (171) function_designator -> . procedure_identifier actual_parameter_part
    (163) boolean_secondary -> . boolean_primary
    (164) boolean_secondary -> . NOT boolean_primary
    (143) decimal_number -> . unsigned_integer
    (144) decimal_number -> . decimal_fraction
    (145) decimal_number -> . unsigned_integer decimal_fraction
    (149) exponential_part -> . EREAL integer
    (174) simple_variable -> . variable_identifier
    (176) subscripted_variable -> . array_identifier LBBRACKET subscript_list RBBRACKET
    (44) procedure_identifier -> . IDENTIFIER
    (165) boolean_primary -> . logical_value
    (166) boolean_primary -> . variable
    (167) boolean_primary -> . function_designator
    (168) boolean_primary -> . relation
    (169) boolean_primary -> . LCBRACKET boolean_expression RCBRACKET
    (148) decimal_fraction -> . DOT unsigned_integer
    (175) variable_identifier -> . IDENTIFIER
    (31) array_identifier -> . IDENTIFIER
    (183) logical_value -> . TRUE
    (184) logical_value -> . FALSE
    (170) relation -> . simple_arithmetic_expression relational_operator simple_arithmetic_expression

    LCBRACKET       shift and go to state 170
    IF              shift and go to state 45
    IDENTIFIER      shift and go to state 232
    PLUS            shift and go to state 102
    MINUS           shift and go to state 94
    DIGIT           shift and go to state 6
    NOT             shift and go to state 118
    EREAL           shift and go to state 115
    DOT             shift and go to state 95
    TRUE            shift and go to state 93
    FALSE           shift and go to state 100

    boolean_primary                shift and go to state 99
    procedure_identifier           shift and go to state 125
    primary                        shift and go to state 98
    if_clause                      shift and go to state 233
    boolean_factor                 shift and go to state 90
    relation                       shift and go to state 91
    simple_boolean                 shift and go to state 97
    boolean_secondary              shift and go to state 101
    label                          shift and go to state 67
    decimal_fraction               shift and go to state 103
    factor                         shift and go to state 104
    unsigned_number                shift and go to state 105
    simple_arithmetic_expression   shift and go to state 107
    arithmetic_expression          shift and go to state 209
    simple_designational_expression shift and go to state 71
    logical_value                  shift and go to state 109
    switch_identifier              shift and go to state 68
    decimal_number                 shift and go to state 112
    boolean_term                   shift and go to state 88
    variable_identifier            shift and go to state 41
    function_designator            shift and go to state 110
    array_identifier               shift and go to state 14
    variable                       shift and go to state 161
    exponential_part               shift and go to state 92
    term                           shift and go to state 113
    designational_expression       shift and go to state 158
    boolean_expression             shift and go to state 210
    switch_designator              shift and go to state 65
    subscripted_variable           shift and go to state 13
    simple_variable                shift and go to state 49
    adding_operator                shift and go to state 117
    implication                    shift and go to state 119
    unsigned_integer               shift and go to state 175

state 171

    (120) expression -> designational_expression .

    RCBRACKET       reduce using rule 120 (expression -> designational_expression .)
    COMMA           reduce using rule 120 (expression -> designational_expression .)


state 172

    (119) expression -> boolean_expression .

    RCBRACKET       reduce using rule 119 (expression -> boolean_expression .)
    COMMA           reduce using rule 119 (expression -> boolean_expression .)


state 173

    (103) actual_parameter -> procedure_identifier .
    (171) function_designator -> procedure_identifier . actual_parameter_part
    (93) actual_parameter_part -> . LCBRACKET RCBRACKET
    (94) actual_parameter_part -> . LCBRACKET actual_parameter_list RCBRACKET

    RCBRACKET       reduce using rule 103 (actual_parameter -> procedure_identifier .)
    COMMA           reduce using rule 103 (actual_parameter -> procedure_identifier .)
    LCBRACKET       shift and go to state 73

    actual_parameter_part          shift and go to state 184

state 174

    (100) actual_parameter -> expression .

    RCBRACKET       reduce using rule 100 (actual_parameter -> expression .)
    COMMA           reduce using rule 100 (actual_parameter -> expression .)


state 175

    (75) label -> unsigned_integer .
    (147) unsigned_integer -> unsigned_integer . DIGIT
    (143) decimal_number -> unsigned_integer .
    (145) decimal_number -> unsigned_integer . decimal_fraction
    (148) decimal_fraction -> . DOT unsigned_integer

  ! reduce/reduce conflict for ELSE resolved using rule 75 (label -> unsigned_integer .)
  ! reduce/reduce conflict for RCBRACKET resolved using rule 75 (label -> unsigned_integer .)
  ! reduce/reduce conflict for COMMA resolved using rule 75 (label -> unsigned_integer .)
    RCBRACKET       reduce using rule 75 (label -> unsigned_integer .)
    COMMA           reduce using rule 75 (label -> unsigned_integer .)
    ELSE            reduce using rule 75 (label -> unsigned_integer .)
    DIGIT           shift and go to state 57
    EREAL           reduce using rule 143 (decimal_number -> unsigned_integer .)
    POWER           reduce using rule 143 (decimal_number -> unsigned_integer .)
    TIMES           reduce using rule 143 (decimal_number -> unsigned_integer .)
    DIV             reduce using rule 143 (decimal_number -> unsigned_integer .)
    MOD             reduce using rule 143 (decimal_number -> unsigned_integer .)
    PLUS            reduce using rule 143 (decimal_number -> unsigned_integer .)
    MINUS           reduce using rule 143 (decimal_number -> unsigned_integer .)
    LESS            reduce using rule 143 (decimal_number -> unsigned_integer .)
    NOTGREATER      reduce using rule 143 (decimal_number -> unsigned_integer .)
    EQUAL           reduce using rule 143 (decimal_number -> unsigned_integer .)
    NOTLESS         reduce using rule 143 (decimal_number -> unsigned_integer .)
    GREATER         reduce using rule 143 (decimal_number -> unsigned_integer .)
    NOTEQUAL        reduce using rule 143 (decimal_number -> unsigned_integer .)
    DOT             shift and go to state 95

  ! ELSE            [ reduce using rule 143 (decimal_number -> unsigned_integer .) ]
  ! RCBRACKET       [ reduce using rule 143 (decimal_number -> unsigned_integer .) ]
  ! COMMA           [ reduce using rule 143 (decimal_number -> unsigned_integer .) ]

    decimal_fraction               shift and go to state 214

state 176

    (37) switch_declaration -> SWITCH switch_identifier ASSIGNMENT . switch_list
    (39) switch_list -> . designational_expression
    (40) switch_list -> . switch_list COMMA designational_expression
    (86) designational_expression -> . simple_designational_expression
    (87) designational_expression -> . if_clause simple_designational_expression ELSE designational_expression
    (88) simple_designational_expression -> . label
    (89) simple_designational_expression -> . switch_designator
    (90) simple_designational_expression -> . LCBRACKET designational_expression RCBRACKET
    (109) if_clause -> . IF boolean_expression THEN
    (74) label -> . IDENTIFIER
    (75) label -> . unsigned_integer
    (91) switch_designator -> . switch_identifier LBBRACKET subscript_expression RBBRACKET
    (146) unsigned_integer -> . DIGIT
    (147) unsigned_integer -> . unsigned_integer DIGIT
    (38) switch_identifier -> . IDENTIFIER

    LCBRACKET       shift and go to state 69
    IF              shift and go to state 45
    IDENTIFIER      shift and go to state 70
    DIGIT           shift and go to state 6

    designational_expression       shift and go to state 235
    simple_designational_expression shift and go to state 71
    switch_designator              shift and go to state 65
    if_clause                      shift and go to state 66
    label                          shift and go to state 67
    switch_identifier              shift and go to state 68
    switch_list                    shift and go to state 234
    unsigned_integer               shift and go to state 9

state 177

    (12) compound_tail -> statement SEMICOLON compound_tail .

    $end            reduce using rule 12 (compound_tail -> statement SEMICOLON compound_tail .)
    END             reduce using rule 12 (compound_tail -> statement SEMICOLON compound_tail .)
    SEMICOLON       reduce using rule 12 (compound_tail -> statement SEMICOLON compound_tail .)
    ELSE            reduce using rule 12 (compound_tail -> statement SEMICOLON compound_tail .)


state 178

    (105) conditional_statement -> if_statement ELSE statement .

    END             reduce using rule 105 (conditional_statement -> if_statement ELSE statement .)
    SEMICOLON       reduce using rule 105 (conditional_statement -> if_statement ELSE statement .)


state 179

    (42) procedure_declaration -> type PROCEDURE procedure_heading . procedure_body
    (65) procedure_body -> . statement
    (66) statement -> . unconditional_statement
    (67) statement -> . conditional_statement
    (68) statement -> . for_statement
    (69) unconditional_statement -> . basic_statement
    (70) unconditional_statement -> . compound_statement
    (71) unconditional_statement -> . block
    (104) conditional_statement -> . if_statement
    (105) conditional_statement -> . if_statement ELSE statement
    (106) conditional_statement -> . if_clause for_statement
    (107) conditional_statement -> . label COLON conditional_statement
    (110) for_statement -> . for_clause statement
    (111) for_statement -> . label COLON for_statement
    (72) basic_statement -> . unlabelled_basic_statement
    (73) basic_statement -> . label COLON basic_statement
    (8) compound_statement -> . unlabelled_compound
    (9) compound_statement -> . label COLON compound_statement
    (3) block -> . unlabelled_block
    (4) block -> . TLABEL COLON block
    (108) if_statement -> . if_clause unconditional_statement
    (109) if_clause -> . IF boolean_expression THEN
    (74) label -> . IDENTIFIER
    (75) label -> . unsigned_integer
    (112) for_clause -> . FOR variable ASSIGNMENT for_list DO
    (76) unlabelled_basic_statement -> . assignment_statement
    (77) unlabelled_basic_statement -> . go_to_statement
    (78) unlabelled_basic_statement -> . procedure_statement
    (10) unlabelled_compound -> . BEGIN compound_tail
    (5) unlabelled_block -> . block_head SEMICOLON compound_tail
    (146) unsigned_integer -> . DIGIT
    (147) unsigned_integer -> . unsigned_integer DIGIT
    (79) assignment_statement -> . left_part_list arithmetic_expression
    (80) assignment_statement -> . left_part_list boolean_expression
    (85) go_to_statement -> . GOTO designational_expression
    (92) procedure_statement -> . procedure_identifier actual_parameter_part
    (6) block_head -> . BEGIN declaration
    (7) block_head -> . block_head SEMICOLON declaration
    (81) left_part_list -> . left_part
    (82) left_part_list -> . left_part_list left_part
    (44) procedure_identifier -> . IDENTIFIER
    (83) left_part -> . variable ASSIGNMENT
    (84) left_part -> . procedure_identifier ASSIGNMENT
    (172) variable -> . simple_variable
    (173) variable -> . subscripted_variable
    (174) simple_variable -> . variable_identifier
    (176) subscripted_variable -> . array_identifier LBBRACKET subscript_list RBBRACKET
    (175) variable_identifier -> . IDENTIFIER
    (31) array_identifier -> . IDENTIFIER

    TLABEL          shift and go to state 4
    IF              shift and go to state 45
    IDENTIFIER      shift and go to state 47
    FOR             shift and go to state 37
    BEGIN           shift and go to state 1
    DIGIT           shift and go to state 6
    GOTO            shift and go to state 20

    subscripted_variable           shift and go to state 13
    block                          shift and go to state 54
    unlabelled_compound            shift and go to state 2
    array_identifier               shift and go to state 14
    if_clause                      shift and go to state 16
    block_head                     shift and go to state 10
    conditional_statement          shift and go to state 25
    left_part                      shift and go to state 34
    left_part_list                 shift and go to state 40
    compound_statement             shift and go to state 22
    assignment_statement           shift and go to state 23
    procedure_statement            shift and go to state 24
    label                          shift and go to state 19
    statement                      shift and go to state 215
    if_statement                   shift and go to state 30
    basic_statement                shift and go to state 33
    for_statement                  shift and go to state 35
    go_to_statement                shift and go to state 38
    variable_identifier            shift and go to state 41
    variable                       shift and go to state 43
    unconditional_statement        shift and go to state 28
    unlabelled_block               shift and go to state 5
    procedure_identifier           shift and go to state 21
    simple_variable                shift and go to state 49
    unlabelled_basic_statement     shift and go to state 50
    for_clause                     shift and go to state 52
    procedure_body                 shift and go to state 236
    unsigned_integer               shift and go to state 9

state 180

    (29) array_segment -> array_identifier LBBRACKET . bound_pair_list RBBRACKET
    (32) bound_pair_list -> . bound_pair
    (33) bound_pair_list -> . bound_pair_list COMMA bound_pair
    (34) bound_pair -> . lower_bound COLON upper_bound
    (36) lower_bound -> . arithmetic_expression
    (121) arithmetic_expression -> . simple_arithmetic_expression
    (122) arithmetic_expression -> . if_clause simple_arithmetic_expression ELSE arithmetic_expression
    (123) simple_arithmetic_expression -> . term
    (124) simple_arithmetic_expression -> . adding_operator term
    (125) simple_arithmetic_expression -> . simple_arithmetic_expression adding_operator term
    (109) if_clause -> . IF boolean_expression THEN
    (128) term -> . factor
    (129) term -> . term multiplying_operator factor
    (126) adding_operator -> . PLUS
    (127) adding_operator -> . MINUS
    (133) factor -> . primary
    (134) factor -> . factor
    (135) factor -> . factor POWER primary
    (136) primary -> . unsigned_number
    (137) primary -> . variable
    (138) primary -> . function_designator
    (139) primary -> . LCBRACKET arithmetic_expression RCBRACKET
    (140) unsigned_number -> . decimal_number
    (141) unsigned_number -> . exponential_part
    (142) unsigned_number -> . decimal_number exponential_part
    (172) variable -> . simple_variable
    (173) variable -> . subscripted_variable
    (171) function_designator -> . procedure_identifier actual_parameter_part
    (143) decimal_number -> . unsigned_integer
    (144) decimal_number -> . decimal_fraction
    (145) decimal_number -> . unsigned_integer decimal_fraction
    (149) exponential_part -> . EREAL integer
    (174) simple_variable -> . variable_identifier
    (176) subscripted_variable -> . array_identifier LBBRACKET subscript_list RBBRACKET
    (44) procedure_identifier -> . IDENTIFIER
    (146) unsigned_integer -> . DIGIT
    (147) unsigned_integer -> . unsigned_integer DIGIT
    (148) decimal_fraction -> . DOT unsigned_integer
    (175) variable_identifier -> . IDENTIFIER
    (31) array_identifier -> . IDENTIFIER

    IF              shift and go to state 45
    PLUS            shift and go to state 102
    MINUS           shift and go to state 94
    LCBRACKET       shift and go to state 145
    EREAL           shift and go to state 115
    IDENTIFIER      shift and go to state 106
    DIGIT           shift and go to state 6
    DOT             shift and go to state 95

    subscripted_variable           shift and go to state 13
    primary                        shift and go to state 98
    if_clause                      shift and go to state 144
    unsigned_number                shift and go to state 105
    decimal_fraction               shift and go to state 103
    factor                         shift and go to state 104
    simple_arithmetic_expression   shift and go to state 147
    arithmetic_expression          shift and go to state 237
    lower_bound                    shift and go to state 238
    decimal_number                 shift and go to state 112
    variable_identifier            shift and go to state 41
    function_designator            shift and go to state 149
    array_identifier               shift and go to state 14
    variable                       shift and go to state 150
    bound_pair_list                shift and go to state 239
    exponential_part               shift and go to state 92
    term                           shift and go to state 113
    procedure_identifier           shift and go to state 125
    simple_variable                shift and go to state 49
    bound_pair                     shift and go to state 240
    adding_operator                shift and go to state 117
    unsigned_integer               shift and go to state 120

state 181

    (30) array_segment -> array_identifier COMMA . array_segment
    (29) array_segment -> . array_identifier LBBRACKET bound_pair_list RBBRACKET
    (30) array_segment -> . array_identifier COMMA array_segment
    (31) array_identifier -> . IDENTIFIER

    IDENTIFIER      shift and go to state 83

    array_segment                  shift and go to state 241
    array_identifier               shift and go to state 82

state 182

    (28) array_list -> array_list COMMA . array_segment
    (29) array_segment -> . array_identifier LBBRACKET bound_pair_list RBBRACKET
    (30) array_segment -> . array_identifier COMMA array_segment
    (31) array_identifier -> . IDENTIFIER

    IDENTIFIER      shift and go to state 83

    array_segment                  shift and go to state 242
    array_identifier               shift and go to state 82

state 183

    (112) for_clause -> FOR variable ASSIGNMENT . for_list DO
    (113) for_list -> . for_list_element
    (114) for_list -> . for_list COMMA for_list_element
    (115) for_list_element -> . arithmetic_expression
    (116) for_list_element -> . arithmetic_expression STEP arithmetic_expression UNTIL arithmetic_expression
    (117) for_list_element -> . arithmetic_expression WHILE boolean_expression
    (121) arithmetic_expression -> . simple_arithmetic_expression
    (122) arithmetic_expression -> . if_clause simple_arithmetic_expression ELSE arithmetic_expression
    (123) simple_arithmetic_expression -> . term
    (124) simple_arithmetic_expression -> . adding_operator term
    (125) simple_arithmetic_expression -> . simple_arithmetic_expression adding_operator term
    (109) if_clause -> . IF boolean_expression THEN
    (128) term -> . factor
    (129) term -> . term multiplying_operator factor
    (126) adding_operator -> . PLUS
    (127) adding_operator -> . MINUS
    (133) factor -> . primary
    (134) factor -> . factor
    (135) factor -> . factor POWER primary
    (136) primary -> . unsigned_number
    (137) primary -> . variable
    (138) primary -> . function_designator
    (139) primary -> . LCBRACKET arithmetic_expression RCBRACKET
    (140) unsigned_number -> . decimal_number
    (141) unsigned_number -> . exponential_part
    (142) unsigned_number -> . decimal_number exponential_part
    (172) variable -> . simple_variable
    (173) variable -> . subscripted_variable
    (171) function_designator -> . procedure_identifier actual_parameter_part
    (143) decimal_number -> . unsigned_integer
    (144) decimal_number -> . decimal_fraction
    (145) decimal_number -> . unsigned_integer decimal_fraction
    (149) exponential_part -> . EREAL integer
    (174) simple_variable -> . variable_identifier
    (176) subscripted_variable -> . array_identifier LBBRACKET subscript_list RBBRACKET
    (44) procedure_identifier -> . IDENTIFIER
    (146) unsigned_integer -> . DIGIT
    (147) unsigned_integer -> . unsigned_integer DIGIT
    (148) decimal_fraction -> . DOT unsigned_integer
    (175) variable_identifier -> . IDENTIFIER
    (31) array_identifier -> . IDENTIFIER

    IF              shift and go to state 45
    PLUS            shift and go to state 102
    MINUS           shift and go to state 94
    LCBRACKET       shift and go to state 145
    EREAL           shift and go to state 115
    IDENTIFIER      shift and go to state 106
    DIGIT           shift and go to state 6
    DOT             shift and go to state 95

    subscripted_variable           shift and go to state 13
    for_list_element               shift and go to state 243
    if_clause                      shift and go to state 144
    for_list                       shift and go to state 244
    unsigned_number                shift and go to state 105
    decimal_fraction               shift and go to state 103
    factor                         shift and go to state 104
    simple_arithmetic_expression   shift and go to state 147
    arithmetic_expression          shift and go to state 245
    decimal_number                 shift and go to state 112
    primary                        shift and go to state 98
    variable_identifier            shift and go to state 41
    function_designator            shift and go to state 149
    array_identifier               shift and go to state 14
    variable                       shift and go to state 150
    exponential_part               shift and go to state 92
    term                           shift and go to state 113
    procedure_identifier           shift and go to state 125
    simple_variable                shift and go to state 49
    adding_operator                shift and go to state 117
    unsigned_integer               shift and go to state 120

state 184

    (171) function_designator -> procedure_identifier actual_parameter_part .

    AND             reduce using rule 171 (function_designator -> procedure_identifier actual_parameter_part .)
    OR              reduce using rule 171 (function_designator -> procedure_identifier actual_parameter_part .)
    IMPL            reduce using rule 171 (function_designator -> procedure_identifier actual_parameter_part .)
    ELSE            reduce using rule 171 (function_designator -> procedure_identifier actual_parameter_part .)
    EQUIV           reduce using rule 171 (function_designator -> procedure_identifier actual_parameter_part .)
    POWER           reduce using rule 171 (function_designator -> procedure_identifier actual_parameter_part .)
    TIMES           reduce using rule 171 (function_designator -> procedure_identifier actual_parameter_part .)
    DIV             reduce using rule 171 (function_designator -> procedure_identifier actual_parameter_part .)
    MOD             reduce using rule 171 (function_designator -> procedure_identifier actual_parameter_part .)
    LESS            reduce using rule 171 (function_designator -> procedure_identifier actual_parameter_part .)
    NOTGREATER      reduce using rule 171 (function_designator -> procedure_identifier actual_parameter_part .)
    EQUAL           reduce using rule 171 (function_designator -> procedure_identifier actual_parameter_part .)
    NOTLESS         reduce using rule 171 (function_designator -> procedure_identifier actual_parameter_part .)
    GREATER         reduce using rule 171 (function_designator -> procedure_identifier actual_parameter_part .)
    NOTEQUAL        reduce using rule 171 (function_designator -> procedure_identifier actual_parameter_part .)
    PLUS            reduce using rule 171 (function_designator -> procedure_identifier actual_parameter_part .)
    MINUS           reduce using rule 171 (function_designator -> procedure_identifier actual_parameter_part .)
    END             reduce using rule 171 (function_designator -> procedure_identifier actual_parameter_part .)
    SEMICOLON       reduce using rule 171 (function_designator -> procedure_identifier actual_parameter_part .)
    THEN            reduce using rule 171 (function_designator -> procedure_identifier actual_parameter_part .)
    RCBRACKET       reduce using rule 171 (function_designator -> procedure_identifier actual_parameter_part .)
    COMMA           reduce using rule 171 (function_designator -> procedure_identifier actual_parameter_part .)
    DO              reduce using rule 171 (function_designator -> procedure_identifier actual_parameter_part .)
    RBBRACKET       reduce using rule 171 (function_designator -> procedure_identifier actual_parameter_part .)
    COLON           reduce using rule 171 (function_designator -> procedure_identifier actual_parameter_part .)
    STEP            reduce using rule 171 (function_designator -> procedure_identifier actual_parameter_part .)
    WHILE           reduce using rule 171 (function_designator -> procedure_identifier actual_parameter_part .)
    UNTIL           reduce using rule 171 (function_designator -> procedure_identifier actual_parameter_part .)


state 185

    (160) boolean_term -> boolean_term OR . boolean_factor
    (161) boolean_factor -> . boolean_secondary
    (162) boolean_factor -> . boolean_factor AND boolean_secondary
    (163) boolean_secondary -> . boolean_primary
    (164) boolean_secondary -> . NOT boolean_primary
    (165) boolean_primary -> . logical_value
    (166) boolean_primary -> . variable
    (167) boolean_primary -> . function_designator
    (168) boolean_primary -> . relation
    (169) boolean_primary -> . LCBRACKET boolean_expression RCBRACKET
    (183) logical_value -> . TRUE
    (184) logical_value -> . FALSE
    (172) variable -> . simple_variable
    (173) variable -> . subscripted_variable
    (171) function_designator -> . procedure_identifier actual_parameter_part
    (170) relation -> . simple_arithmetic_expression relational_operator simple_arithmetic_expression
    (174) simple_variable -> . variable_identifier
    (176) subscripted_variable -> . array_identifier LBBRACKET subscript_list RBBRACKET
    (44) procedure_identifier -> . IDENTIFIER
    (123) simple_arithmetic_expression -> . term
    (124) simple_arithmetic_expression -> . adding_operator term
    (125) simple_arithmetic_expression -> . simple_arithmetic_expression adding_operator term
    (175) variable_identifier -> . IDENTIFIER
    (31) array_identifier -> . IDENTIFIER
    (128) term -> . factor
    (129) term -> . term multiplying_operator factor
    (126) adding_operator -> . PLUS
    (127) adding_operator -> . MINUS
    (133) factor -> . primary
    (134) factor -> . factor
    (135) factor -> . factor POWER primary
    (136) primary -> . unsigned_number
    (137) primary -> . variable
    (138) primary -> . function_designator
    (139) primary -> . LCBRACKET arithmetic_expression RCBRACKET
    (140) unsigned_number -> . decimal_number
    (141) unsigned_number -> . exponential_part
    (142) unsigned_number -> . decimal_number exponential_part
    (143) decimal_number -> . unsigned_integer
    (144) decimal_number -> . decimal_fraction
    (145) decimal_number -> . unsigned_integer decimal_fraction
    (149) exponential_part -> . EREAL integer
    (146) unsigned_integer -> . DIGIT
    (147) unsigned_integer -> . unsigned_integer DIGIT
    (148) decimal_fraction -> . DOT unsigned_integer

    NOT             shift and go to state 118
    LCBRACKET       shift and go to state 127
    TRUE            shift and go to state 93
    FALSE           shift and go to state 100
    IDENTIFIER      shift and go to state 106
    PLUS            shift and go to state 102
    MINUS           shift and go to state 94
    EREAL           shift and go to state 115
    DIGIT           shift and go to state 6
    DOT             shift and go to state 95

    subscripted_variable           shift and go to state 13
    function_designator            shift and go to state 128
    boolean_factor                 shift and go to state 246
    relation                       shift and go to state 91
    boolean_secondary              shift and go to state 101
    unsigned_number                shift and go to state 105
    decimal_fraction               shift and go to state 103
    factor                         shift and go to state 104
    simple_arithmetic_expression   shift and go to state 131
    boolean_primary                shift and go to state 99
    logical_value                  shift and go to state 109
    decimal_number                 shift and go to state 112
    primary                        shift and go to state 98
    variable_identifier            shift and go to state 41
    array_identifier               shift and go to state 14
    variable                       shift and go to state 129
    exponential_part               shift and go to state 92
    term                           shift and go to state 113
    procedure_identifier           shift and go to state 125
    simple_variable                shift and go to state 49
    adding_operator                shift and go to state 117
    unsigned_integer               shift and go to state 120

state 186

    (122) arithmetic_expression -> if_clause simple_arithmetic_expression . ELSE arithmetic_expression
    (125) simple_arithmetic_expression -> simple_arithmetic_expression . adding_operator term
    (170) relation -> simple_arithmetic_expression . relational_operator simple_arithmetic_expression
    (126) adding_operator -> . PLUS
    (127) adding_operator -> . MINUS
    (185) relational_operator -> . LESS
    (186) relational_operator -> . NOTGREATER
    (187) relational_operator -> . EQUAL
    (188) relational_operator -> . NOTLESS
    (189) relational_operator -> . GREATER
    (190) relational_operator -> . NOTEQUAL

    ELSE            shift and go to state 247
    PLUS            shift and go to state 102
    MINUS           shift and go to state 94
    LESS            shift and go to state 194
    NOTGREATER      shift and go to state 199
    EQUAL           shift and go to state 195
    NOTLESS         shift and go to state 198
    GREATER         shift and go to state 197
    NOTEQUAL        shift and go to state 192

    relational_operator            shift and go to state 193
    adding_operator                shift and go to state 196

state 187

    (154) boolean_expression -> if_clause simple_boolean . ELSE boolean_expression
    (156) simple_boolean -> simple_boolean . EQUIV implication

    ELSE            shift and go to state 248
    EQUIV           shift and go to state 190


state 188

    (162) boolean_factor -> boolean_factor AND . boolean_secondary
    (163) boolean_secondary -> . boolean_primary
    (164) boolean_secondary -> . NOT boolean_primary
    (165) boolean_primary -> . logical_value
    (166) boolean_primary -> . variable
    (167) boolean_primary -> . function_designator
    (168) boolean_primary -> . relation
    (169) boolean_primary -> . LCBRACKET boolean_expression RCBRACKET
    (183) logical_value -> . TRUE
    (184) logical_value -> . FALSE
    (172) variable -> . simple_variable
    (173) variable -> . subscripted_variable
    (171) function_designator -> . procedure_identifier actual_parameter_part
    (170) relation -> . simple_arithmetic_expression relational_operator simple_arithmetic_expression
    (174) simple_variable -> . variable_identifier
    (176) subscripted_variable -> . array_identifier LBBRACKET subscript_list RBBRACKET
    (44) procedure_identifier -> . IDENTIFIER
    (123) simple_arithmetic_expression -> . term
    (124) simple_arithmetic_expression -> . adding_operator term
    (125) simple_arithmetic_expression -> . simple_arithmetic_expression adding_operator term
    (175) variable_identifier -> . IDENTIFIER
    (31) array_identifier -> . IDENTIFIER
    (128) term -> . factor
    (129) term -> . term multiplying_operator factor
    (126) adding_operator -> . PLUS
    (127) adding_operator -> . MINUS
    (133) factor -> . primary
    (134) factor -> . factor
    (135) factor -> . factor POWER primary
    (136) primary -> . unsigned_number
    (137) primary -> . variable
    (138) primary -> . function_designator
    (139) primary -> . LCBRACKET arithmetic_expression RCBRACKET
    (140) unsigned_number -> . decimal_number
    (141) unsigned_number -> . exponential_part
    (142) unsigned_number -> . decimal_number exponential_part
    (143) decimal_number -> . unsigned_integer
    (144) decimal_number -> . decimal_fraction
    (145) decimal_number -> . unsigned_integer decimal_fraction
    (149) exponential_part -> . EREAL integer
    (146) unsigned_integer -> . DIGIT
    (147) unsigned_integer -> . unsigned_integer DIGIT
    (148) decimal_fraction -> . DOT unsigned_integer

    NOT             shift and go to state 118
    LCBRACKET       shift and go to state 127
    TRUE            shift and go to state 93
    FALSE           shift and go to state 100
    IDENTIFIER      shift and go to state 106
    PLUS            shift and go to state 102
    MINUS           shift and go to state 94
    EREAL           shift and go to state 115
    DIGIT           shift and go to state 6
    DOT             shift and go to state 95

    subscripted_variable           shift and go to state 13
    primary                        shift and go to state 98
    function_designator            shift and go to state 128
    relation                       shift and go to state 91
    boolean_secondary              shift and go to state 249
    unsigned_number                shift and go to state 105
    decimal_fraction               shift and go to state 103
    factor                         shift and go to state 104
    simple_arithmetic_expression   shift and go to state 131
    boolean_primary                shift and go to state 99
    logical_value                  shift and go to state 109
    decimal_number                 shift and go to state 112
    variable_identifier            shift and go to state 41
    array_identifier               shift and go to state 14
    variable                       shift and go to state 129
    exponential_part               shift and go to state 92
    term                           shift and go to state 113
    procedure_identifier           shift and go to state 125
    simple_variable                shift and go to state 49
    adding_operator                shift and go to state 117
    unsigned_integer               shift and go to state 120

state 189

    (148) decimal_fraction -> DOT unsigned_integer .
    (147) unsigned_integer -> unsigned_integer . DIGIT

    EREAL           reduce using rule 148 (decimal_fraction -> DOT unsigned_integer .)
    POWER           reduce using rule 148 (decimal_fraction -> DOT unsigned_integer .)
    TIMES           reduce using rule 148 (decimal_fraction -> DOT unsigned_integer .)
    DIV             reduce using rule 148 (decimal_fraction -> DOT unsigned_integer .)
    MOD             reduce using rule 148 (decimal_fraction -> DOT unsigned_integer .)
    PLUS            reduce using rule 148 (decimal_fraction -> DOT unsigned_integer .)
    MINUS           reduce using rule 148 (decimal_fraction -> DOT unsigned_integer .)
    LESS            reduce using rule 148 (decimal_fraction -> DOT unsigned_integer .)
    NOTGREATER      reduce using rule 148 (decimal_fraction -> DOT unsigned_integer .)
    EQUAL           reduce using rule 148 (decimal_fraction -> DOT unsigned_integer .)
    NOTLESS         reduce using rule 148 (decimal_fraction -> DOT unsigned_integer .)
    GREATER         reduce using rule 148 (decimal_fraction -> DOT unsigned_integer .)
    NOTEQUAL        reduce using rule 148 (decimal_fraction -> DOT unsigned_integer .)
    RCBRACKET       reduce using rule 148 (decimal_fraction -> DOT unsigned_integer .)
    RBBRACKET       reduce using rule 148 (decimal_fraction -> DOT unsigned_integer .)
    END             reduce using rule 148 (decimal_fraction -> DOT unsigned_integer .)
    SEMICOLON       reduce using rule 148 (decimal_fraction -> DOT unsigned_integer .)
    ELSE            reduce using rule 148 (decimal_fraction -> DOT unsigned_integer .)
    COMMA           reduce using rule 148 (decimal_fraction -> DOT unsigned_integer .)
    COLON           reduce using rule 148 (decimal_fraction -> DOT unsigned_integer .)
    STEP            reduce using rule 148 (decimal_fraction -> DOT unsigned_integer .)
    WHILE           reduce using rule 148 (decimal_fraction -> DOT unsigned_integer .)
    DO              reduce using rule 148 (decimal_fraction -> DOT unsigned_integer .)
    UNTIL           reduce using rule 148 (decimal_fraction -> DOT unsigned_integer .)
    AND             reduce using rule 148 (decimal_fraction -> DOT unsigned_integer .)
    OR              reduce using rule 148 (decimal_fraction -> DOT unsigned_integer .)
    IMPL            reduce using rule 148 (decimal_fraction -> DOT unsigned_integer .)
    EQUIV           reduce using rule 148 (decimal_fraction -> DOT unsigned_integer .)
    THEN            reduce using rule 148 (decimal_fraction -> DOT unsigned_integer .)
    DIGIT           shift and go to state 57


state 190

    (156) simple_boolean -> simple_boolean EQUIV . implication
    (157) implication -> . boolean_term
    (158) implication -> . implication IMPL boolean_term
    (159) boolean_term -> . boolean_factor
    (160) boolean_term -> . boolean_term OR boolean_factor
    (161) boolean_factor -> . boolean_secondary
    (162) boolean_factor -> . boolean_factor AND boolean_secondary
    (163) boolean_secondary -> . boolean_primary
    (164) boolean_secondary -> . NOT boolean_primary
    (165) boolean_primary -> . logical_value
    (166) boolean_primary -> . variable
    (167) boolean_primary -> . function_designator
    (168) boolean_primary -> . relation
    (169) boolean_primary -> . LCBRACKET boolean_expression RCBRACKET
    (183) logical_value -> . TRUE
    (184) logical_value -> . FALSE
    (172) variable -> . simple_variable
    (173) variable -> . subscripted_variable
    (171) function_designator -> . procedure_identifier actual_parameter_part
    (170) relation -> . simple_arithmetic_expression relational_operator simple_arithmetic_expression
    (174) simple_variable -> . variable_identifier
    (176) subscripted_variable -> . array_identifier LBBRACKET subscript_list RBBRACKET
    (44) procedure_identifier -> . IDENTIFIER
    (123) simple_arithmetic_expression -> . term
    (124) simple_arithmetic_expression -> . adding_operator term
    (125) simple_arithmetic_expression -> . simple_arithmetic_expression adding_operator term
    (175) variable_identifier -> . IDENTIFIER
    (31) array_identifier -> . IDENTIFIER
    (128) term -> . factor
    (129) term -> . term multiplying_operator factor
    (126) adding_operator -> . PLUS
    (127) adding_operator -> . MINUS
    (133) factor -> . primary
    (134) factor -> . factor
    (135) factor -> . factor POWER primary
    (136) primary -> . unsigned_number
    (137) primary -> . variable
    (138) primary -> . function_designator
    (139) primary -> . LCBRACKET arithmetic_expression RCBRACKET
    (140) unsigned_number -> . decimal_number
    (141) unsigned_number -> . exponential_part
    (142) unsigned_number -> . decimal_number exponential_part
    (143) decimal_number -> . unsigned_integer
    (144) decimal_number -> . decimal_fraction
    (145) decimal_number -> . unsigned_integer decimal_fraction
    (149) exponential_part -> . EREAL integer
    (146) unsigned_integer -> . DIGIT
    (147) unsigned_integer -> . unsigned_integer DIGIT
    (148) decimal_fraction -> . DOT unsigned_integer

    NOT             shift and go to state 118
    LCBRACKET       shift and go to state 127
    TRUE            shift and go to state 93
    FALSE           shift and go to state 100
    IDENTIFIER      shift and go to state 106
    PLUS            shift and go to state 102
    MINUS           shift and go to state 94
    EREAL           shift and go to state 115
    DIGIT           shift and go to state 6
    DOT             shift and go to state 95

    subscripted_variable           shift and go to state 13
    boolean_term                   shift and go to state 88
    function_designator            shift and go to state 128
    boolean_factor                 shift and go to state 90
    relation                       shift and go to state 91
    boolean_secondary              shift and go to state 101
    unsigned_number                shift and go to state 105
    decimal_fraction               shift and go to state 103
    factor                         shift and go to state 104
    simple_arithmetic_expression   shift and go to state 131
    boolean_primary                shift and go to state 99
    logical_value                  shift and go to state 109
    decimal_number                 shift and go to state 112
    primary                        shift and go to state 98
    variable_identifier            shift and go to state 41
    array_identifier               shift and go to state 14
    variable                       shift and go to state 129
    exponential_part               shift and go to state 92
    term                           shift and go to state 113
    procedure_identifier           shift and go to state 125
    simple_variable                shift and go to state 49
    adding_operator                shift and go to state 117
    implication                    shift and go to state 250
    unsigned_integer               shift and go to state 120

state 191

    (135) factor -> factor POWER . primary
    (136) primary -> . unsigned_number
    (137) primary -> . variable
    (138) primary -> . function_designator
    (139) primary -> . LCBRACKET arithmetic_expression RCBRACKET
    (140) unsigned_number -> . decimal_number
    (141) unsigned_number -> . exponential_part
    (142) unsigned_number -> . decimal_number exponential_part
    (172) variable -> . simple_variable
    (173) variable -> . subscripted_variable
    (171) function_designator -> . procedure_identifier actual_parameter_part
    (143) decimal_number -> . unsigned_integer
    (144) decimal_number -> . decimal_fraction
    (145) decimal_number -> . unsigned_integer decimal_fraction
    (149) exponential_part -> . EREAL integer
    (174) simple_variable -> . variable_identifier
    (176) subscripted_variable -> . array_identifier LBBRACKET subscript_list RBBRACKET
    (44) procedure_identifier -> . IDENTIFIER
    (146) unsigned_integer -> . DIGIT
    (147) unsigned_integer -> . unsigned_integer DIGIT
    (148) decimal_fraction -> . DOT unsigned_integer
    (175) variable_identifier -> . IDENTIFIER
    (31) array_identifier -> . IDENTIFIER

    LCBRACKET       shift and go to state 145
    EREAL           shift and go to state 115
    IDENTIFIER      shift and go to state 106
    DIGIT           shift and go to state 6
    DOT             shift and go to state 95

    procedure_identifier           shift and go to state 125
    array_identifier               shift and go to state 14
    subscripted_variable           shift and go to state 13
    primary                        shift and go to state 251
    function_designator            shift and go to state 149
    decimal_number                 shift and go to state 112
    variable_identifier            shift and go to state 41
    unsigned_number                shift and go to state 105
    simple_variable                shift and go to state 49
    decimal_fraction               shift and go to state 103
    variable                       shift and go to state 150
    unsigned_integer               shift and go to state 120
    exponential_part               shift and go to state 92

state 192

    (190) relational_operator -> NOTEQUAL .

    PLUS            reduce using rule 190 (relational_operator -> NOTEQUAL .)
    MINUS           reduce using rule 190 (relational_operator -> NOTEQUAL .)
    LCBRACKET       reduce using rule 190 (relational_operator -> NOTEQUAL .)
    EREAL           reduce using rule 190 (relational_operator -> NOTEQUAL .)
    IDENTIFIER      reduce using rule 190 (relational_operator -> NOTEQUAL .)
    DIGIT           reduce using rule 190 (relational_operator -> NOTEQUAL .)
    DOT             reduce using rule 190 (relational_operator -> NOTEQUAL .)


state 193

    (170) relation -> simple_arithmetic_expression relational_operator . simple_arithmetic_expression
    (123) simple_arithmetic_expression -> . term
    (124) simple_arithmetic_expression -> . adding_operator term
    (125) simple_arithmetic_expression -> . simple_arithmetic_expression adding_operator term
    (128) term -> . factor
    (129) term -> . term multiplying_operator factor
    (126) adding_operator -> . PLUS
    (127) adding_operator -> . MINUS
    (133) factor -> . primary
    (134) factor -> . factor
    (135) factor -> . factor POWER primary
    (136) primary -> . unsigned_number
    (137) primary -> . variable
    (138) primary -> . function_designator
    (139) primary -> . LCBRACKET arithmetic_expression RCBRACKET
    (140) unsigned_number -> . decimal_number
    (141) unsigned_number -> . exponential_part
    (142) unsigned_number -> . decimal_number exponential_part
    (172) variable -> . simple_variable
    (173) variable -> . subscripted_variable
    (171) function_designator -> . procedure_identifier actual_parameter_part
    (143) decimal_number -> . unsigned_integer
    (144) decimal_number -> . decimal_fraction
    (145) decimal_number -> . unsigned_integer decimal_fraction
    (149) exponential_part -> . EREAL integer
    (174) simple_variable -> . variable_identifier
    (176) subscripted_variable -> . array_identifier LBBRACKET subscript_list RBBRACKET
    (44) procedure_identifier -> . IDENTIFIER
    (146) unsigned_integer -> . DIGIT
    (147) unsigned_integer -> . unsigned_integer DIGIT
    (148) decimal_fraction -> . DOT unsigned_integer
    (175) variable_identifier -> . IDENTIFIER
    (31) array_identifier -> . IDENTIFIER

    PLUS            shift and go to state 102
    MINUS           shift and go to state 94
    LCBRACKET       shift and go to state 145
    EREAL           shift and go to state 115
    IDENTIFIER      shift and go to state 106
    DIGIT           shift and go to state 6
    DOT             shift and go to state 95

    subscripted_variable           shift and go to state 13
    primary                        shift and go to state 98
    function_designator            shift and go to state 149
    unsigned_number                shift and go to state 105
    decimal_fraction               shift and go to state 103
    factor                         shift and go to state 104
    simple_arithmetic_expression   shift and go to state 252
    decimal_number                 shift and go to state 112
    variable_identifier            shift and go to state 41
    array_identifier               shift and go to state 14
    variable                       shift and go to state 150
    exponential_part               shift and go to state 92
    term                           shift and go to state 113
    procedure_identifier           shift and go to state 125
    simple_variable                shift and go to state 49
    adding_operator                shift and go to state 117
    unsigned_integer               shift and go to state 120

state 194

    (185) relational_operator -> LESS .

    PLUS            reduce using rule 185 (relational_operator -> LESS .)
    MINUS           reduce using rule 185 (relational_operator -> LESS .)
    LCBRACKET       reduce using rule 185 (relational_operator -> LESS .)
    EREAL           reduce using rule 185 (relational_operator -> LESS .)
    IDENTIFIER      reduce using rule 185 (relational_operator -> LESS .)
    DIGIT           reduce using rule 185 (relational_operator -> LESS .)
    DOT             reduce using rule 185 (relational_operator -> LESS .)


state 195

    (187) relational_operator -> EQUAL .

    PLUS            reduce using rule 187 (relational_operator -> EQUAL .)
    MINUS           reduce using rule 187 (relational_operator -> EQUAL .)
    LCBRACKET       reduce using rule 187 (relational_operator -> EQUAL .)
    EREAL           reduce using rule 187 (relational_operator -> EQUAL .)
    IDENTIFIER      reduce using rule 187 (relational_operator -> EQUAL .)
    DIGIT           reduce using rule 187 (relational_operator -> EQUAL .)
    DOT             reduce using rule 187 (relational_operator -> EQUAL .)


state 196

    (125) simple_arithmetic_expression -> simple_arithmetic_expression adding_operator . term
    (128) term -> . factor
    (129) term -> . term multiplying_operator factor
    (133) factor -> . primary
    (134) factor -> . factor
    (135) factor -> . factor POWER primary
    (136) primary -> . unsigned_number
    (137) primary -> . variable
    (138) primary -> . function_designator
    (139) primary -> . LCBRACKET arithmetic_expression RCBRACKET
    (140) unsigned_number -> . decimal_number
    (141) unsigned_number -> . exponential_part
    (142) unsigned_number -> . decimal_number exponential_part
    (172) variable -> . simple_variable
    (173) variable -> . subscripted_variable
    (171) function_designator -> . procedure_identifier actual_parameter_part
    (143) decimal_number -> . unsigned_integer
    (144) decimal_number -> . decimal_fraction
    (145) decimal_number -> . unsigned_integer decimal_fraction
    (149) exponential_part -> . EREAL integer
    (174) simple_variable -> . variable_identifier
    (176) subscripted_variable -> . array_identifier LBBRACKET subscript_list RBBRACKET
    (44) procedure_identifier -> . IDENTIFIER
    (146) unsigned_integer -> . DIGIT
    (147) unsigned_integer -> . unsigned_integer DIGIT
    (148) decimal_fraction -> . DOT unsigned_integer
    (175) variable_identifier -> . IDENTIFIER
    (31) array_identifier -> . IDENTIFIER

    LCBRACKET       shift and go to state 145
    EREAL           shift and go to state 115
    IDENTIFIER      shift and go to state 106
    DIGIT           shift and go to state 6
    DOT             shift and go to state 95

    subscripted_variable           shift and go to state 13
    primary                        shift and go to state 98
    function_designator            shift and go to state 149
    unsigned_number                shift and go to state 105
    decimal_fraction               shift and go to state 103
    factor                         shift and go to state 104
    decimal_number                 shift and go to state 112
    variable_identifier            shift and go to state 41
    array_identifier               shift and go to state 14
    variable                       shift and go to state 150
    exponential_part               shift and go to state 92
    term                           shift and go to state 253
    procedure_identifier           shift and go to state 125
    simple_variable                shift and go to state 49
    unsigned_integer               shift and go to state 120

state 197

    (189) relational_operator -> GREATER .

    PLUS            reduce using rule 189 (relational_operator -> GREATER .)
    MINUS           reduce using rule 189 (relational_operator -> GREATER .)
    LCBRACKET       reduce using rule 189 (relational_operator -> GREATER .)
    EREAL           reduce using rule 189 (relational_operator -> GREATER .)
    IDENTIFIER      reduce using rule 189 (relational_operator -> GREATER .)
    DIGIT           reduce using rule 189 (relational_operator -> GREATER .)
    DOT             reduce using rule 189 (relational_operator -> GREATER .)


state 198

    (188) relational_operator -> NOTLESS .

    PLUS            reduce using rule 188 (relational_operator -> NOTLESS .)
    MINUS           reduce using rule 188 (relational_operator -> NOTLESS .)
    LCBRACKET       reduce using rule 188 (relational_operator -> NOTLESS .)
    EREAL           reduce using rule 188 (relational_operator -> NOTLESS .)
    IDENTIFIER      reduce using rule 188 (relational_operator -> NOTLESS .)
    DIGIT           reduce using rule 188 (relational_operator -> NOTLESS .)
    DOT             reduce using rule 188 (relational_operator -> NOTLESS .)


state 199

    (186) relational_operator -> NOTGREATER .

    PLUS            reduce using rule 186 (relational_operator -> NOTGREATER .)
    MINUS           reduce using rule 186 (relational_operator -> NOTGREATER .)
    LCBRACKET       reduce using rule 186 (relational_operator -> NOTGREATER .)
    EREAL           reduce using rule 186 (relational_operator -> NOTGREATER .)
    IDENTIFIER      reduce using rule 186 (relational_operator -> NOTGREATER .)
    DIGIT           reduce using rule 186 (relational_operator -> NOTGREATER .)
    DOT             reduce using rule 186 (relational_operator -> NOTGREATER .)


state 200

    (142) unsigned_number -> decimal_number exponential_part .

    POWER           reduce using rule 142 (unsigned_number -> decimal_number exponential_part .)
    TIMES           reduce using rule 142 (unsigned_number -> decimal_number exponential_part .)
    DIV             reduce using rule 142 (unsigned_number -> decimal_number exponential_part .)
    MOD             reduce using rule 142 (unsigned_number -> decimal_number exponential_part .)
    PLUS            reduce using rule 142 (unsigned_number -> decimal_number exponential_part .)
    MINUS           reduce using rule 142 (unsigned_number -> decimal_number exponential_part .)
    LESS            reduce using rule 142 (unsigned_number -> decimal_number exponential_part .)
    NOTGREATER      reduce using rule 142 (unsigned_number -> decimal_number exponential_part .)
    EQUAL           reduce using rule 142 (unsigned_number -> decimal_number exponential_part .)
    NOTLESS         reduce using rule 142 (unsigned_number -> decimal_number exponential_part .)
    GREATER         reduce using rule 142 (unsigned_number -> decimal_number exponential_part .)
    NOTEQUAL        reduce using rule 142 (unsigned_number -> decimal_number exponential_part .)
    RCBRACKET       reduce using rule 142 (unsigned_number -> decimal_number exponential_part .)
    COMMA           reduce using rule 142 (unsigned_number -> decimal_number exponential_part .)
    RBBRACKET       reduce using rule 142 (unsigned_number -> decimal_number exponential_part .)
    ELSE            reduce using rule 142 (unsigned_number -> decimal_number exponential_part .)
    END             reduce using rule 142 (unsigned_number -> decimal_number exponential_part .)
    SEMICOLON       reduce using rule 142 (unsigned_number -> decimal_number exponential_part .)
    COLON           reduce using rule 142 (unsigned_number -> decimal_number exponential_part .)
    STEP            reduce using rule 142 (unsigned_number -> decimal_number exponential_part .)
    WHILE           reduce using rule 142 (unsigned_number -> decimal_number exponential_part .)
    DO              reduce using rule 142 (unsigned_number -> decimal_number exponential_part .)
    AND             reduce using rule 142 (unsigned_number -> decimal_number exponential_part .)
    OR              reduce using rule 142 (unsigned_number -> decimal_number exponential_part .)
    IMPL            reduce using rule 142 (unsigned_number -> decimal_number exponential_part .)
    EQUIV           reduce using rule 142 (unsigned_number -> decimal_number exponential_part .)
    THEN            reduce using rule 142 (unsigned_number -> decimal_number exponential_part .)
    UNTIL           reduce using rule 142 (unsigned_number -> decimal_number exponential_part .)


state 201

    (130) multiplying_operator -> TIMES .

    LCBRACKET       reduce using rule 130 (multiplying_operator -> TIMES .)
    EREAL           reduce using rule 130 (multiplying_operator -> TIMES .)
    IDENTIFIER      reduce using rule 130 (multiplying_operator -> TIMES .)
    DIGIT           reduce using rule 130 (multiplying_operator -> TIMES .)
    DOT             reduce using rule 130 (multiplying_operator -> TIMES .)


state 202

    (131) multiplying_operator -> DIV .

    LCBRACKET       reduce using rule 131 (multiplying_operator -> DIV .)
    EREAL           reduce using rule 131 (multiplying_operator -> DIV .)
    IDENTIFIER      reduce using rule 131 (multiplying_operator -> DIV .)
    DIGIT           reduce using rule 131 (multiplying_operator -> DIV .)
    DOT             reduce using rule 131 (multiplying_operator -> DIV .)


state 203

    (129) term -> term multiplying_operator . factor
    (133) factor -> . primary
    (134) factor -> . factor
    (135) factor -> . factor POWER primary
    (136) primary -> . unsigned_number
    (137) primary -> . variable
    (138) primary -> . function_designator
    (139) primary -> . LCBRACKET arithmetic_expression RCBRACKET
    (140) unsigned_number -> . decimal_number
    (141) unsigned_number -> . exponential_part
    (142) unsigned_number -> . decimal_number exponential_part
    (172) variable -> . simple_variable
    (173) variable -> . subscripted_variable
    (171) function_designator -> . procedure_identifier actual_parameter_part
    (143) decimal_number -> . unsigned_integer
    (144) decimal_number -> . decimal_fraction
    (145) decimal_number -> . unsigned_integer decimal_fraction
    (149) exponential_part -> . EREAL integer
    (174) simple_variable -> . variable_identifier
    (176) subscripted_variable -> . array_identifier LBBRACKET subscript_list RBBRACKET
    (44) procedure_identifier -> . IDENTIFIER
    (146) unsigned_integer -> . DIGIT
    (147) unsigned_integer -> . unsigned_integer DIGIT
    (148) decimal_fraction -> . DOT unsigned_integer
    (175) variable_identifier -> . IDENTIFIER
    (31) array_identifier -> . IDENTIFIER

    LCBRACKET       shift and go to state 145
    EREAL           shift and go to state 115
    IDENTIFIER      shift and go to state 106
    DIGIT           shift and go to state 6
    DOT             shift and go to state 95

    procedure_identifier           shift and go to state 125
    array_identifier               shift and go to state 14
    subscripted_variable           shift and go to state 13
    primary                        shift and go to state 98
    function_designator            shift and go to state 149
    decimal_number                 shift and go to state 112
    variable_identifier            shift and go to state 41
    unsigned_number                shift and go to state 105
    simple_variable                shift and go to state 49
    decimal_fraction               shift and go to state 103
    factor                         shift and go to state 254
    variable                       shift and go to state 150
    unsigned_integer               shift and go to state 120
    exponential_part               shift and go to state 92

state 204

    (132) multiplying_operator -> MOD .

    LCBRACKET       reduce using rule 132 (multiplying_operator -> MOD .)
    EREAL           reduce using rule 132 (multiplying_operator -> MOD .)
    IDENTIFIER      reduce using rule 132 (multiplying_operator -> MOD .)
    DIGIT           reduce using rule 132 (multiplying_operator -> MOD .)
    DOT             reduce using rule 132 (multiplying_operator -> MOD .)


state 205

    (151) integer -> PLUS . unsigned_integer
    (146) unsigned_integer -> . DIGIT
    (147) unsigned_integer -> . unsigned_integer DIGIT

    DIGIT           shift and go to state 6

    unsigned_integer               shift and go to state 255

state 206

    (149) exponential_part -> EREAL integer .

    POWER           reduce using rule 149 (exponential_part -> EREAL integer .)
    TIMES           reduce using rule 149 (exponential_part -> EREAL integer .)
    DIV             reduce using rule 149 (exponential_part -> EREAL integer .)
    MOD             reduce using rule 149 (exponential_part -> EREAL integer .)
    LESS            reduce using rule 149 (exponential_part -> EREAL integer .)
    NOTGREATER      reduce using rule 149 (exponential_part -> EREAL integer .)
    EQUAL           reduce using rule 149 (exponential_part -> EREAL integer .)
    NOTLESS         reduce using rule 149 (exponential_part -> EREAL integer .)
    GREATER         reduce using rule 149 (exponential_part -> EREAL integer .)
    NOTEQUAL        reduce using rule 149 (exponential_part -> EREAL integer .)
    PLUS            reduce using rule 149 (exponential_part -> EREAL integer .)
    MINUS           reduce using rule 149 (exponential_part -> EREAL integer .)
    END             reduce using rule 149 (exponential_part -> EREAL integer .)
    SEMICOLON       reduce using rule 149 (exponential_part -> EREAL integer .)
    ELSE            reduce using rule 149 (exponential_part -> EREAL integer .)
    COLON           reduce using rule 149 (exponential_part -> EREAL integer .)
    RBBRACKET       reduce using rule 149 (exponential_part -> EREAL integer .)
    COMMA           reduce using rule 149 (exponential_part -> EREAL integer .)
    RCBRACKET       reduce using rule 149 (exponential_part -> EREAL integer .)
    STEP            reduce using rule 149 (exponential_part -> EREAL integer .)
    WHILE           reduce using rule 149 (exponential_part -> EREAL integer .)
    DO              reduce using rule 149 (exponential_part -> EREAL integer .)
    AND             reduce using rule 149 (exponential_part -> EREAL integer .)
    OR              reduce using rule 149 (exponential_part -> EREAL integer .)
    IMPL            reduce using rule 149 (exponential_part -> EREAL integer .)
    EQUIV           reduce using rule 149 (exponential_part -> EREAL integer .)
    THEN            reduce using rule 149 (exponential_part -> EREAL integer .)
    UNTIL           reduce using rule 149 (exponential_part -> EREAL integer .)


state 207

    (152) integer -> MINUS . unsigned_integer
    (146) unsigned_integer -> . DIGIT
    (147) unsigned_integer -> . unsigned_integer DIGIT

    DIGIT           shift and go to state 6

    unsigned_integer               shift and go to state 256

state 208

    (150) integer -> unsigned_integer .
    (147) unsigned_integer -> unsigned_integer . DIGIT

    POWER           reduce using rule 150 (integer -> unsigned_integer .)
    TIMES           reduce using rule 150 (integer -> unsigned_integer .)
    DIV             reduce using rule 150 (integer -> unsigned_integer .)
    MOD             reduce using rule 150 (integer -> unsigned_integer .)
    PLUS            reduce using rule 150 (integer -> unsigned_integer .)
    MINUS           reduce using rule 150 (integer -> unsigned_integer .)
    LESS            reduce using rule 150 (integer -> unsigned_integer .)
    NOTGREATER      reduce using rule 150 (integer -> unsigned_integer .)
    EQUAL           reduce using rule 150 (integer -> unsigned_integer .)
    NOTLESS         reduce using rule 150 (integer -> unsigned_integer .)
    GREATER         reduce using rule 150 (integer -> unsigned_integer .)
    NOTEQUAL        reduce using rule 150 (integer -> unsigned_integer .)
    END             reduce using rule 150 (integer -> unsigned_integer .)
    SEMICOLON       reduce using rule 150 (integer -> unsigned_integer .)
    ELSE            reduce using rule 150 (integer -> unsigned_integer .)
    RBBRACKET       reduce using rule 150 (integer -> unsigned_integer .)
    COMMA           reduce using rule 150 (integer -> unsigned_integer .)
    RCBRACKET       reduce using rule 150 (integer -> unsigned_integer .)
    COLON           reduce using rule 150 (integer -> unsigned_integer .)
    STEP            reduce using rule 150 (integer -> unsigned_integer .)
    WHILE           reduce using rule 150 (integer -> unsigned_integer .)
    DO              reduce using rule 150 (integer -> unsigned_integer .)
    AND             reduce using rule 150 (integer -> unsigned_integer .)
    OR              reduce using rule 150 (integer -> unsigned_integer .)
    IMPL            reduce using rule 150 (integer -> unsigned_integer .)
    EQUIV           reduce using rule 150 (integer -> unsigned_integer .)
    THEN            reduce using rule 150 (integer -> unsigned_integer .)
    UNTIL           reduce using rule 150 (integer -> unsigned_integer .)
    DIGIT           shift and go to state 57


state 209

    (139) primary -> LCBRACKET arithmetic_expression . RCBRACKET

    RCBRACKET       shift and go to state 257


state 210

    (169) boolean_primary -> LCBRACKET boolean_expression . RCBRACKET

    RCBRACKET       shift and go to state 258


state 211

    (124) simple_arithmetic_expression -> adding_operator term .
    (129) term -> term . multiplying_operator factor
    (130) multiplying_operator -> . TIMES
    (131) multiplying_operator -> . DIV
    (132) multiplying_operator -> . MOD

    ELSE            reduce using rule 124 (simple_arithmetic_expression -> adding_operator term .)
    PLUS            reduce using rule 124 (simple_arithmetic_expression -> adding_operator term .)
    MINUS           reduce using rule 124 (simple_arithmetic_expression -> adding_operator term .)
    LESS            reduce using rule 124 (simple_arithmetic_expression -> adding_operator term .)
    NOTGREATER      reduce using rule 124 (simple_arithmetic_expression -> adding_operator term .)
    EQUAL           reduce using rule 124 (simple_arithmetic_expression -> adding_operator term .)
    NOTLESS         reduce using rule 124 (simple_arithmetic_expression -> adding_operator term .)
    GREATER         reduce using rule 124 (simple_arithmetic_expression -> adding_operator term .)
    NOTEQUAL        reduce using rule 124 (simple_arithmetic_expression -> adding_operator term .)
    RCBRACKET       reduce using rule 124 (simple_arithmetic_expression -> adding_operator term .)
    RBBRACKET       reduce using rule 124 (simple_arithmetic_expression -> adding_operator term .)
    COMMA           reduce using rule 124 (simple_arithmetic_expression -> adding_operator term .)
    STEP            reduce using rule 124 (simple_arithmetic_expression -> adding_operator term .)
    WHILE           reduce using rule 124 (simple_arithmetic_expression -> adding_operator term .)
    DO              reduce using rule 124 (simple_arithmetic_expression -> adding_operator term .)
    END             reduce using rule 124 (simple_arithmetic_expression -> adding_operator term .)
    SEMICOLON       reduce using rule 124 (simple_arithmetic_expression -> adding_operator term .)
    COLON           reduce using rule 124 (simple_arithmetic_expression -> adding_operator term .)
    UNTIL           reduce using rule 124 (simple_arithmetic_expression -> adding_operator term .)
    AND             reduce using rule 124 (simple_arithmetic_expression -> adding_operator term .)
    OR              reduce using rule 124 (simple_arithmetic_expression -> adding_operator term .)
    IMPL            reduce using rule 124 (simple_arithmetic_expression -> adding_operator term .)
    EQUIV           reduce using rule 124 (simple_arithmetic_expression -> adding_operator term .)
    THEN            reduce using rule 124 (simple_arithmetic_expression -> adding_operator term .)
    TIMES           shift and go to state 201
    DIV             shift and go to state 202
    MOD             shift and go to state 204

    multiplying_operator           shift and go to state 203

state 212

    (164) boolean_secondary -> NOT boolean_primary .

    AND             reduce using rule 164 (boolean_secondary -> NOT boolean_primary .)
    OR              reduce using rule 164 (boolean_secondary -> NOT boolean_primary .)
    IMPL            reduce using rule 164 (boolean_secondary -> NOT boolean_primary .)
    EQUIV           reduce using rule 164 (boolean_secondary -> NOT boolean_primary .)
    END             reduce using rule 164 (boolean_secondary -> NOT boolean_primary .)
    SEMICOLON       reduce using rule 164 (boolean_secondary -> NOT boolean_primary .)
    ELSE            reduce using rule 164 (boolean_secondary -> NOT boolean_primary .)
    THEN            reduce using rule 164 (boolean_secondary -> NOT boolean_primary .)
    RCBRACKET       reduce using rule 164 (boolean_secondary -> NOT boolean_primary .)
    COMMA           reduce using rule 164 (boolean_secondary -> NOT boolean_primary .)
    DO              reduce using rule 164 (boolean_secondary -> NOT boolean_primary .)


state 213

    (158) implication -> implication IMPL . boolean_term
    (159) boolean_term -> . boolean_factor
    (160) boolean_term -> . boolean_term OR boolean_factor
    (161) boolean_factor -> . boolean_secondary
    (162) boolean_factor -> . boolean_factor AND boolean_secondary
    (163) boolean_secondary -> . boolean_primary
    (164) boolean_secondary -> . NOT boolean_primary
    (165) boolean_primary -> . logical_value
    (166) boolean_primary -> . variable
    (167) boolean_primary -> . function_designator
    (168) boolean_primary -> . relation
    (169) boolean_primary -> . LCBRACKET boolean_expression RCBRACKET
    (183) logical_value -> . TRUE
    (184) logical_value -> . FALSE
    (172) variable -> . simple_variable
    (173) variable -> . subscripted_variable
    (171) function_designator -> . procedure_identifier actual_parameter_part
    (170) relation -> . simple_arithmetic_expression relational_operator simple_arithmetic_expression
    (174) simple_variable -> . variable_identifier
    (176) subscripted_variable -> . array_identifier LBBRACKET subscript_list RBBRACKET
    (44) procedure_identifier -> . IDENTIFIER
    (123) simple_arithmetic_expression -> . term
    (124) simple_arithmetic_expression -> . adding_operator term
    (125) simple_arithmetic_expression -> . simple_arithmetic_expression adding_operator term
    (175) variable_identifier -> . IDENTIFIER
    (31) array_identifier -> . IDENTIFIER
    (128) term -> . factor
    (129) term -> . term multiplying_operator factor
    (126) adding_operator -> . PLUS
    (127) adding_operator -> . MINUS
    (133) factor -> . primary
    (134) factor -> . factor
    (135) factor -> . factor POWER primary
    (136) primary -> . unsigned_number
    (137) primary -> . variable
    (138) primary -> . function_designator
    (139) primary -> . LCBRACKET arithmetic_expression RCBRACKET
    (140) unsigned_number -> . decimal_number
    (141) unsigned_number -> . exponential_part
    (142) unsigned_number -> . decimal_number exponential_part
    (143) decimal_number -> . unsigned_integer
    (144) decimal_number -> . decimal_fraction
    (145) decimal_number -> . unsigned_integer decimal_fraction
    (149) exponential_part -> . EREAL integer
    (146) unsigned_integer -> . DIGIT
    (147) unsigned_integer -> . unsigned_integer DIGIT
    (148) decimal_fraction -> . DOT unsigned_integer

    NOT             shift and go to state 118
    LCBRACKET       shift and go to state 127
    TRUE            shift and go to state 93
    FALSE           shift and go to state 100
    IDENTIFIER      shift and go to state 106
    PLUS            shift and go to state 102
    MINUS           shift and go to state 94
    EREAL           shift and go to state 115
    DIGIT           shift and go to state 6
    DOT             shift and go to state 95

    subscripted_variable           shift and go to state 13
    boolean_term                   shift and go to state 259
    function_designator            shift and go to state 128
    boolean_factor                 shift and go to state 90
    relation                       shift and go to state 91
    boolean_secondary              shift and go to state 101
    unsigned_number                shift and go to state 105
    decimal_fraction               shift and go to state 103
    factor                         shift and go to state 104
    simple_arithmetic_expression   shift and go to state 131
    boolean_primary                shift and go to state 99
    logical_value                  shift and go to state 109
    decimal_number                 shift and go to state 112
    primary                        shift and go to state 98
    variable_identifier            shift and go to state 41
    array_identifier               shift and go to state 14
    variable                       shift and go to state 129
    exponential_part               shift and go to state 92
    term                           shift and go to state 113
    procedure_identifier           shift and go to state 125
    simple_variable                shift and go to state 49
    adding_operator                shift and go to state 117
    unsigned_integer               shift and go to state 120

state 214

    (145) decimal_number -> unsigned_integer decimal_fraction .

    EREAL           reduce using rule 145 (decimal_number -> unsigned_integer decimal_fraction .)
    POWER           reduce using rule 145 (decimal_number -> unsigned_integer decimal_fraction .)
    TIMES           reduce using rule 145 (decimal_number -> unsigned_integer decimal_fraction .)
    DIV             reduce using rule 145 (decimal_number -> unsigned_integer decimal_fraction .)
    MOD             reduce using rule 145 (decimal_number -> unsigned_integer decimal_fraction .)
    PLUS            reduce using rule 145 (decimal_number -> unsigned_integer decimal_fraction .)
    MINUS           reduce using rule 145 (decimal_number -> unsigned_integer decimal_fraction .)
    COLON           reduce using rule 145 (decimal_number -> unsigned_integer decimal_fraction .)
    LESS            reduce using rule 145 (decimal_number -> unsigned_integer decimal_fraction .)
    NOTGREATER      reduce using rule 145 (decimal_number -> unsigned_integer decimal_fraction .)
    EQUAL           reduce using rule 145 (decimal_number -> unsigned_integer decimal_fraction .)
    NOTLESS         reduce using rule 145 (decimal_number -> unsigned_integer decimal_fraction .)
    GREATER         reduce using rule 145 (decimal_number -> unsigned_integer decimal_fraction .)
    NOTEQUAL        reduce using rule 145 (decimal_number -> unsigned_integer decimal_fraction .)
    END             reduce using rule 145 (decimal_number -> unsigned_integer decimal_fraction .)
    SEMICOLON       reduce using rule 145 (decimal_number -> unsigned_integer decimal_fraction .)
    ELSE            reduce using rule 145 (decimal_number -> unsigned_integer decimal_fraction .)
    RBBRACKET       reduce using rule 145 (decimal_number -> unsigned_integer decimal_fraction .)
    COMMA           reduce using rule 145 (decimal_number -> unsigned_integer decimal_fraction .)
    RCBRACKET       reduce using rule 145 (decimal_number -> unsigned_integer decimal_fraction .)
    STEP            reduce using rule 145 (decimal_number -> unsigned_integer decimal_fraction .)
    WHILE           reduce using rule 145 (decimal_number -> unsigned_integer decimal_fraction .)
    DO              reduce using rule 145 (decimal_number -> unsigned_integer decimal_fraction .)
    AND             reduce using rule 145 (decimal_number -> unsigned_integer decimal_fraction .)
    OR              reduce using rule 145 (decimal_number -> unsigned_integer decimal_fraction .)
    IMPL            reduce using rule 145 (decimal_number -> unsigned_integer decimal_fraction .)
    EQUIV           reduce using rule 145 (decimal_number -> unsigned_integer decimal_fraction .)
    THEN            reduce using rule 145 (decimal_number -> unsigned_integer decimal_fraction .)
    UNTIL           reduce using rule 145 (decimal_number -> unsigned_integer decimal_fraction .)


state 215

    (65) procedure_body -> statement .

    SEMICOLON       reduce using rule 65 (procedure_body -> statement .)


state 216

    (41) procedure_declaration -> PROCEDURE procedure_heading procedure_body .

    SEMICOLON       reduce using rule 41 (procedure_declaration -> PROCEDURE procedure_heading procedure_body .)


state 217

    (43) procedure_heading -> procedure_identifier formal_parameter_part . SEMICOLON value_part specification_part

    SEMICOLON       shift and go to state 260


state 218

    (46) formal_parameter_part -> LCBRACKET . formal_parameter_list RCBRACKET
    (47) formal_parameter_list -> . formal_parameter
    (48) formal_parameter_list -> . formal_parameter_list parameter_delimiter formal_parameter
    (49) formal_parameter -> . IDENTIFIER

    IDENTIFIER      shift and go to state 263

    formal_parameter_list          shift and go to state 261
    formal_parameter               shift and go to state 262

state 219

    (154) boolean_expression -> if_clause . simple_boolean ELSE boolean_expression
    (122) arithmetic_expression -> if_clause . simple_arithmetic_expression ELSE arithmetic_expression
    (155) simple_boolean -> . implication
    (156) simple_boolean -> . simple_boolean EQUIV implication
    (123) simple_arithmetic_expression -> . term
    (124) simple_arithmetic_expression -> . adding_operator term
    (125) simple_arithmetic_expression -> . simple_arithmetic_expression adding_operator term
    (157) implication -> . boolean_term
    (158) implication -> . implication IMPL boolean_term
    (128) term -> . factor
    (129) term -> . term multiplying_operator factor
    (126) adding_operator -> . PLUS
    (127) adding_operator -> . MINUS
    (159) boolean_term -> . boolean_factor
    (160) boolean_term -> . boolean_term OR boolean_factor
    (133) factor -> . primary
    (134) factor -> . factor
    (135) factor -> . factor POWER primary
    (161) boolean_factor -> . boolean_secondary
    (162) boolean_factor -> . boolean_factor AND boolean_secondary
    (136) primary -> . unsigned_number
    (137) primary -> . variable
    (138) primary -> . function_designator
    (139) primary -> . LCBRACKET arithmetic_expression RCBRACKET
    (163) boolean_secondary -> . boolean_primary
    (164) boolean_secondary -> . NOT boolean_primary
    (140) unsigned_number -> . decimal_number
    (141) unsigned_number -> . exponential_part
    (142) unsigned_number -> . decimal_number exponential_part
    (172) variable -> . simple_variable
    (173) variable -> . subscripted_variable
    (171) function_designator -> . procedure_identifier actual_parameter_part
    (165) boolean_primary -> . logical_value
    (166) boolean_primary -> . variable
    (167) boolean_primary -> . function_designator
    (168) boolean_primary -> . relation
    (169) boolean_primary -> . LCBRACKET boolean_expression RCBRACKET
    (143) decimal_number -> . unsigned_integer
    (144) decimal_number -> . decimal_fraction
    (145) decimal_number -> . unsigned_integer decimal_fraction
    (149) exponential_part -> . EREAL integer
    (174) simple_variable -> . variable_identifier
    (176) subscripted_variable -> . array_identifier LBBRACKET subscript_list RBBRACKET
    (44) procedure_identifier -> . IDENTIFIER
    (183) logical_value -> . TRUE
    (184) logical_value -> . FALSE
    (170) relation -> . simple_arithmetic_expression relational_operator simple_arithmetic_expression
    (146) unsigned_integer -> . DIGIT
    (147) unsigned_integer -> . unsigned_integer DIGIT
    (148) decimal_fraction -> . DOT unsigned_integer
    (175) variable_identifier -> . IDENTIFIER
    (31) array_identifier -> . IDENTIFIER

    PLUS            shift and go to state 102
    MINUS           shift and go to state 94
    LCBRACKET       shift and go to state 116
    NOT             shift and go to state 118
    EREAL           shift and go to state 115
    IDENTIFIER      shift and go to state 106
    TRUE            shift and go to state 93
    FALSE           shift and go to state 100
    DIGIT           shift and go to state 6
    DOT             shift and go to state 95

    boolean_primary                shift and go to state 99
    procedure_identifier           shift and go to state 125
    boolean_term                   shift and go to state 88
    boolean_factor                 shift and go to state 90
    relation                       shift and go to state 91
    simple_boolean                 shift and go to state 187
    boolean_secondary              shift and go to state 101
    unsigned_number                shift and go to state 105
    decimal_fraction               shift and go to state 103
    factor                         shift and go to state 104
    simple_arithmetic_expression   shift and go to state 186
    logical_value                  shift and go to state 109
    decimal_number                 shift and go to state 112
    primary                        shift and go to state 98
    variable_identifier            shift and go to state 41
    function_designator            shift and go to state 110
    array_identifier               shift and go to state 14
    variable                       shift and go to state 161
    exponential_part               shift and go to state 92
    term                           shift and go to state 113
    subscripted_variable           shift and go to state 13
    simple_variable                shift and go to state 49
    adding_operator                shift and go to state 117
    implication                    shift and go to state 119
    unsigned_integer               shift and go to state 120

state 220

    (109) if_clause -> IF boolean_expression THEN .

    PLUS            reduce using rule 109 (if_clause -> IF boolean_expression THEN .)
    MINUS           reduce using rule 109 (if_clause -> IF boolean_expression THEN .)
    LCBRACKET       reduce using rule 109 (if_clause -> IF boolean_expression THEN .)
    EREAL           reduce using rule 109 (if_clause -> IF boolean_expression THEN .)
    IDENTIFIER      reduce using rule 109 (if_clause -> IF boolean_expression THEN .)
    DIGIT           reduce using rule 109 (if_clause -> IF boolean_expression THEN .)
    DOT             reduce using rule 109 (if_clause -> IF boolean_expression THEN .)
    FOR             reduce using rule 109 (if_clause -> IF boolean_expression THEN .)
    TLABEL          reduce using rule 109 (if_clause -> IF boolean_expression THEN .)
    BEGIN           reduce using rule 109 (if_clause -> IF boolean_expression THEN .)
    GOTO            reduce using rule 109 (if_clause -> IF boolean_expression THEN .)
    NOT             reduce using rule 109 (if_clause -> IF boolean_expression THEN .)
    TRUE            reduce using rule 109 (if_clause -> IF boolean_expression THEN .)
    FALSE           reduce using rule 109 (if_clause -> IF boolean_expression THEN .)


state 221

    (24) type_list -> simple_variable COMMA . type_list
    (23) type_list -> . simple_variable
    (24) type_list -> . simple_variable COMMA type_list
    (174) simple_variable -> . variable_identifier
    (175) variable_identifier -> . IDENTIFIER

    IDENTIFIER      shift and go to state 135

    variable_identifier            shift and go to state 41
    type_list                      shift and go to state 264
    simple_variable                shift and go to state 133

state 222

    (26) array_declaration -> local_or_own_type TARRAY array_list .
    (28) array_list -> array_list . COMMA array_segment

    SEMICOLON       reduce using rule 26 (array_declaration -> local_or_own_type TARRAY array_list .)
    COMMA           shift and go to state 182


state 223

    (122) arithmetic_expression -> if_clause simple_arithmetic_expression . ELSE arithmetic_expression
    (125) simple_arithmetic_expression -> simple_arithmetic_expression . adding_operator term
    (126) adding_operator -> . PLUS
    (127) adding_operator -> . MINUS

    ELSE            shift and go to state 247
    PLUS            shift and go to state 102
    MINUS           shift and go to state 94

    adding_operator                shift and go to state 196

state 224

    (176) subscripted_variable -> array_identifier LBBRACKET subscript_list RBBRACKET .

    POWER           reduce using rule 176 (subscripted_variable -> array_identifier LBBRACKET subscript_list RBBRACKET .)
    TIMES           reduce using rule 176 (subscripted_variable -> array_identifier LBBRACKET subscript_list RBBRACKET .)
    DIV             reduce using rule 176 (subscripted_variable -> array_identifier LBBRACKET subscript_list RBBRACKET .)
    MOD             reduce using rule 176 (subscripted_variable -> array_identifier LBBRACKET subscript_list RBBRACKET .)
    PLUS            reduce using rule 176 (subscripted_variable -> array_identifier LBBRACKET subscript_list RBBRACKET .)
    MINUS           reduce using rule 176 (subscripted_variable -> array_identifier LBBRACKET subscript_list RBBRACKET .)
    COLON           reduce using rule 176 (subscripted_variable -> array_identifier LBBRACKET subscript_list RBBRACKET .)
    AND             reduce using rule 176 (subscripted_variable -> array_identifier LBBRACKET subscript_list RBBRACKET .)
    OR              reduce using rule 176 (subscripted_variable -> array_identifier LBBRACKET subscript_list RBBRACKET .)
    IMPL            reduce using rule 176 (subscripted_variable -> array_identifier LBBRACKET subscript_list RBBRACKET .)
    EQUIV           reduce using rule 176 (subscripted_variable -> array_identifier LBBRACKET subscript_list RBBRACKET .)
    END             reduce using rule 176 (subscripted_variable -> array_identifier LBBRACKET subscript_list RBBRACKET .)
    SEMICOLON       reduce using rule 176 (subscripted_variable -> array_identifier LBBRACKET subscript_list RBBRACKET .)
    ELSE            reduce using rule 176 (subscripted_variable -> array_identifier LBBRACKET subscript_list RBBRACKET .)
    THEN            reduce using rule 176 (subscripted_variable -> array_identifier LBBRACKET subscript_list RBBRACKET .)
    RCBRACKET       reduce using rule 176 (subscripted_variable -> array_identifier LBBRACKET subscript_list RBBRACKET .)
    COMMA           reduce using rule 176 (subscripted_variable -> array_identifier LBBRACKET subscript_list RBBRACKET .)
    DO              reduce using rule 176 (subscripted_variable -> array_identifier LBBRACKET subscript_list RBBRACKET .)
    LESS            reduce using rule 176 (subscripted_variable -> array_identifier LBBRACKET subscript_list RBBRACKET .)
    NOTGREATER      reduce using rule 176 (subscripted_variable -> array_identifier LBBRACKET subscript_list RBBRACKET .)
    EQUAL           reduce using rule 176 (subscripted_variable -> array_identifier LBBRACKET subscript_list RBBRACKET .)
    NOTLESS         reduce using rule 176 (subscripted_variable -> array_identifier LBBRACKET subscript_list RBBRACKET .)
    GREATER         reduce using rule 176 (subscripted_variable -> array_identifier LBBRACKET subscript_list RBBRACKET .)
    NOTEQUAL        reduce using rule 176 (subscripted_variable -> array_identifier LBBRACKET subscript_list RBBRACKET .)
    ASSIGNMENT      reduce using rule 176 (subscripted_variable -> array_identifier LBBRACKET subscript_list RBBRACKET .)
    RBBRACKET       reduce using rule 176 (subscripted_variable -> array_identifier LBBRACKET subscript_list RBBRACKET .)
    STEP            reduce using rule 176 (subscripted_variable -> array_identifier LBBRACKET subscript_list RBBRACKET .)
    WHILE           reduce using rule 176 (subscripted_variable -> array_identifier LBBRACKET subscript_list RBBRACKET .)
    UNTIL           reduce using rule 176 (subscripted_variable -> array_identifier LBBRACKET subscript_list RBBRACKET .)


state 225

    (178) subscript_list -> subscript_list COMMA . subscript_expression
    (179) subscript_expression -> . arithmetic_expression
    (121) arithmetic_expression -> . simple_arithmetic_expression
    (122) arithmetic_expression -> . if_clause simple_arithmetic_expression ELSE arithmetic_expression
    (123) simple_arithmetic_expression -> . term
    (124) simple_arithmetic_expression -> . adding_operator term
    (125) simple_arithmetic_expression -> . simple_arithmetic_expression adding_operator term
    (109) if_clause -> . IF boolean_expression THEN
    (128) term -> . factor
    (129) term -> . term multiplying_operator factor
    (126) adding_operator -> . PLUS
    (127) adding_operator -> . MINUS
    (133) factor -> . primary
    (134) factor -> . factor
    (135) factor -> . factor POWER primary
    (136) primary -> . unsigned_number
    (137) primary -> . variable
    (138) primary -> . function_designator
    (139) primary -> . LCBRACKET arithmetic_expression RCBRACKET
    (140) unsigned_number -> . decimal_number
    (141) unsigned_number -> . exponential_part
    (142) unsigned_number -> . decimal_number exponential_part
    (172) variable -> . simple_variable
    (173) variable -> . subscripted_variable
    (171) function_designator -> . procedure_identifier actual_parameter_part
    (143) decimal_number -> . unsigned_integer
    (144) decimal_number -> . decimal_fraction
    (145) decimal_number -> . unsigned_integer decimal_fraction
    (149) exponential_part -> . EREAL integer
    (174) simple_variable -> . variable_identifier
    (176) subscripted_variable -> . array_identifier LBBRACKET subscript_list RBBRACKET
    (44) procedure_identifier -> . IDENTIFIER
    (146) unsigned_integer -> . DIGIT
    (147) unsigned_integer -> . unsigned_integer DIGIT
    (148) decimal_fraction -> . DOT unsigned_integer
    (175) variable_identifier -> . IDENTIFIER
    (31) array_identifier -> . IDENTIFIER

    IF              shift and go to state 45
    PLUS            shift and go to state 102
    MINUS           shift and go to state 94
    LCBRACKET       shift and go to state 145
    EREAL           shift and go to state 115
    IDENTIFIER      shift and go to state 106
    DIGIT           shift and go to state 6
    DOT             shift and go to state 95

    subscripted_variable           shift and go to state 13
    primary                        shift and go to state 98
    if_clause                      shift and go to state 144
    subscript_expression           shift and go to state 265
    decimal_fraction               shift and go to state 103
    factor                         shift and go to state 104
    unsigned_number                shift and go to state 105
    simple_arithmetic_expression   shift and go to state 147
    arithmetic_expression          shift and go to state 148
    decimal_number                 shift and go to state 112
    variable_identifier            shift and go to state 41
    function_designator            shift and go to state 149
    array_identifier               shift and go to state 14
    variable                       shift and go to state 150
    exponential_part               shift and go to state 92
    term                           shift and go to state 113
    procedure_identifier           shift and go to state 125
    simple_variable                shift and go to state 49
    adding_operator                shift and go to state 117
    unsigned_integer               shift and go to state 120

state 226

    (87) designational_expression -> if_clause simple_designational_expression ELSE . designational_expression
    (86) designational_expression -> . simple_designational_expression
    (87) designational_expression -> . if_clause simple_designational_expression ELSE designational_expression
    (88) simple_designational_expression -> . label
    (89) simple_designational_expression -> . switch_designator
    (90) simple_designational_expression -> . LCBRACKET designational_expression RCBRACKET
    (109) if_clause -> . IF boolean_expression THEN
    (74) label -> . IDENTIFIER
    (75) label -> . unsigned_integer
    (91) switch_designator -> . switch_identifier LBBRACKET subscript_expression RBBRACKET
    (146) unsigned_integer -> . DIGIT
    (147) unsigned_integer -> . unsigned_integer DIGIT
    (38) switch_identifier -> . IDENTIFIER

    LCBRACKET       shift and go to state 69
    IF              shift and go to state 45
    IDENTIFIER      shift and go to state 70
    DIGIT           shift and go to state 6

    designational_expression       shift and go to state 266
    simple_designational_expression shift and go to state 71
    switch_designator              shift and go to state 65
    if_clause                      shift and go to state 66
    label                          shift and go to state 67
    switch_identifier              shift and go to state 68
    unsigned_integer               shift and go to state 9

state 227

    (91) switch_designator -> switch_identifier LBBRACKET subscript_expression . RBBRACKET

    RBBRACKET       shift and go to state 267


state 228

    (90) simple_designational_expression -> LCBRACKET designational_expression RCBRACKET .

    RCBRACKET       reduce using rule 90 (simple_designational_expression -> LCBRACKET designational_expression RCBRACKET .)
    COMMA           reduce using rule 90 (simple_designational_expression -> LCBRACKET designational_expression RCBRACKET .)
    ELSE            reduce using rule 90 (simple_designational_expression -> LCBRACKET designational_expression RCBRACKET .)
    SEMICOLON       reduce using rule 90 (simple_designational_expression -> LCBRACKET designational_expression RCBRACKET .)
    END             reduce using rule 90 (simple_designational_expression -> LCBRACKET designational_expression RCBRACKET .)


state 229

    (94) actual_parameter_part -> LCBRACKET actual_parameter_list RCBRACKET .
    (98) parameter_delimiter -> RCBRACKET . letter_string COLON LCBRACKET
    (181) letter_string -> . LETTER
    (182) letter_string -> . letter_string LETTER

    POWER           reduce using rule 94 (actual_parameter_part -> LCBRACKET actual_parameter_list RCBRACKET .)
    TIMES           reduce using rule 94 (actual_parameter_part -> LCBRACKET actual_parameter_list RCBRACKET .)
    DIV             reduce using rule 94 (actual_parameter_part -> LCBRACKET actual_parameter_list RCBRACKET .)
    MOD             reduce using rule 94 (actual_parameter_part -> LCBRACKET actual_parameter_list RCBRACKET .)
    PLUS            reduce using rule 94 (actual_parameter_part -> LCBRACKET actual_parameter_list RCBRACKET .)
    MINUS           reduce using rule 94 (actual_parameter_part -> LCBRACKET actual_parameter_list RCBRACKET .)
    LESS            reduce using rule 94 (actual_parameter_part -> LCBRACKET actual_parameter_list RCBRACKET .)
    NOTGREATER      reduce using rule 94 (actual_parameter_part -> LCBRACKET actual_parameter_list RCBRACKET .)
    EQUAL           reduce using rule 94 (actual_parameter_part -> LCBRACKET actual_parameter_list RCBRACKET .)
    NOTLESS         reduce using rule 94 (actual_parameter_part -> LCBRACKET actual_parameter_list RCBRACKET .)
    GREATER         reduce using rule 94 (actual_parameter_part -> LCBRACKET actual_parameter_list RCBRACKET .)
    NOTEQUAL        reduce using rule 94 (actual_parameter_part -> LCBRACKET actual_parameter_list RCBRACKET .)
    END             reduce using rule 94 (actual_parameter_part -> LCBRACKET actual_parameter_list RCBRACKET .)
    SEMICOLON       reduce using rule 94 (actual_parameter_part -> LCBRACKET actual_parameter_list RCBRACKET .)
    ELSE            reduce using rule 94 (actual_parameter_part -> LCBRACKET actual_parameter_list RCBRACKET .)
    AND             reduce using rule 94 (actual_parameter_part -> LCBRACKET actual_parameter_list RCBRACKET .)
    OR              reduce using rule 94 (actual_parameter_part -> LCBRACKET actual_parameter_list RCBRACKET .)
    IMPL            reduce using rule 94 (actual_parameter_part -> LCBRACKET actual_parameter_list RCBRACKET .)
    EQUIV           reduce using rule 94 (actual_parameter_part -> LCBRACKET actual_parameter_list RCBRACKET .)
    RCBRACKET       reduce using rule 94 (actual_parameter_part -> LCBRACKET actual_parameter_list RCBRACKET .)
    COMMA           reduce using rule 94 (actual_parameter_part -> LCBRACKET actual_parameter_list RCBRACKET .)
    THEN            reduce using rule 94 (actual_parameter_part -> LCBRACKET actual_parameter_list RCBRACKET .)
    RBBRACKET       reduce using rule 94 (actual_parameter_part -> LCBRACKET actual_parameter_list RCBRACKET .)
    COLON           reduce using rule 94 (actual_parameter_part -> LCBRACKET actual_parameter_list RCBRACKET .)
    STEP            reduce using rule 94 (actual_parameter_part -> LCBRACKET actual_parameter_list RCBRACKET .)
    WHILE           reduce using rule 94 (actual_parameter_part -> LCBRACKET actual_parameter_list RCBRACKET .)
    DO              reduce using rule 94 (actual_parameter_part -> LCBRACKET actual_parameter_list RCBRACKET .)
    UNTIL           reduce using rule 94 (actual_parameter_part -> LCBRACKET actual_parameter_list RCBRACKET .)
    LETTER          shift and go to state 269

    letter_string                  shift and go to state 268

state 230

    (96) actual_parameter_list -> actual_parameter_list parameter_delimiter . actual_parameter
    (99) actual_parameter -> . string
    (100) actual_parameter -> . expression
    (101) actual_parameter -> . array_identifier
    (102) actual_parameter -> . switch_identifier
    (103) actual_parameter -> . procedure_identifier
    (180) string -> . STRING
    (118) expression -> . arithmetic_expression
    (119) expression -> . boolean_expression
    (120) expression -> . designational_expression
    (31) array_identifier -> . IDENTIFIER
    (38) switch_identifier -> . IDENTIFIER
    (44) procedure_identifier -> . IDENTIFIER
    (121) arithmetic_expression -> . simple_arithmetic_expression
    (122) arithmetic_expression -> . if_clause simple_arithmetic_expression ELSE arithmetic_expression
    (153) boolean_expression -> . simple_boolean
    (154) boolean_expression -> . if_clause simple_boolean ELSE boolean_expression
    (86) designational_expression -> . simple_designational_expression
    (87) designational_expression -> . if_clause simple_designational_expression ELSE designational_expression
    (123) simple_arithmetic_expression -> . term
    (124) simple_arithmetic_expression -> . adding_operator term
    (125) simple_arithmetic_expression -> . simple_arithmetic_expression adding_operator term
    (109) if_clause -> . IF boolean_expression THEN
    (155) simple_boolean -> . implication
    (156) simple_boolean -> . simple_boolean EQUIV implication
    (88) simple_designational_expression -> . label
    (89) simple_designational_expression -> . switch_designator
    (90) simple_designational_expression -> . LCBRACKET designational_expression RCBRACKET
    (128) term -> . factor
    (129) term -> . term multiplying_operator factor
    (126) adding_operator -> . PLUS
    (127) adding_operator -> . MINUS
    (157) implication -> . boolean_term
    (158) implication -> . implication IMPL boolean_term
    (74) label -> . IDENTIFIER
    (75) label -> . unsigned_integer
    (91) switch_designator -> . switch_identifier LBBRACKET subscript_expression RBBRACKET
    (133) factor -> . primary
    (134) factor -> . factor
    (135) factor -> . factor POWER primary
    (159) boolean_term -> . boolean_factor
    (160) boolean_term -> . boolean_term OR boolean_factor
    (146) unsigned_integer -> . DIGIT
    (147) unsigned_integer -> . unsigned_integer DIGIT
    (136) primary -> . unsigned_number
    (137) primary -> . variable
    (138) primary -> . function_designator
    (139) primary -> . LCBRACKET arithmetic_expression RCBRACKET
    (161) boolean_factor -> . boolean_secondary
    (162) boolean_factor -> . boolean_factor AND boolean_secondary
    (140) unsigned_number -> . decimal_number
    (141) unsigned_number -> . exponential_part
    (142) unsigned_number -> . decimal_number exponential_part
    (172) variable -> . simple_variable
    (173) variable -> . subscripted_variable
    (171) function_designator -> . procedure_identifier actual_parameter_part
    (163) boolean_secondary -> . boolean_primary
    (164) boolean_secondary -> . NOT boolean_primary
    (143) decimal_number -> . unsigned_integer
    (144) decimal_number -> . decimal_fraction
    (145) decimal_number -> . unsigned_integer decimal_fraction
    (149) exponential_part -> . EREAL integer
    (174) simple_variable -> . variable_identifier
    (176) subscripted_variable -> . array_identifier LBBRACKET subscript_list RBBRACKET
    (165) boolean_primary -> . logical_value
    (166) boolean_primary -> . variable
    (167) boolean_primary -> . function_designator
    (168) boolean_primary -> . relation
    (169) boolean_primary -> . LCBRACKET boolean_expression RCBRACKET
    (148) decimal_fraction -> . DOT unsigned_integer
    (175) variable_identifier -> . IDENTIFIER
    (183) logical_value -> . TRUE
    (184) logical_value -> . FALSE
    (170) relation -> . simple_arithmetic_expression relational_operator simple_arithmetic_expression

    STRING          shift and go to state 165
    IDENTIFIER      shift and go to state 166
    IF              shift and go to state 45
    LCBRACKET       shift and go to state 170
    PLUS            shift and go to state 102
    MINUS           shift and go to state 94
    DIGIT           shift and go to state 6
    NOT             shift and go to state 118
    EREAL           shift and go to state 115
    DOT             shift and go to state 95
    TRUE            shift and go to state 93
    FALSE           shift and go to state 100

    boolean_primary                shift and go to state 99
    subscripted_variable           shift and go to state 13
    boolean_term                   shift and go to state 88
    if_clause                      shift and go to state 160
    variable                       shift and go to state 161
    relation                       shift and go to state 91
    simple_designational_expression shift and go to state 71
    simple_boolean                 shift and go to state 97
    boolean_secondary              shift and go to state 101
    label                          shift and go to state 67
    actual_parameter               shift and go to state 270
    switch_identifier              shift and go to state 164
    unsigned_number                shift and go to state 105
    decimal_fraction               shift and go to state 103
    simple_arithmetic_expression   shift and go to state 107
    arithmetic_expression          shift and go to state 167
    string                         shift and go to state 168
    logical_value                  shift and go to state 109
    factor                         shift and go to state 104
    decimal_number                 shift and go to state 112
    primary                        shift and go to state 98
    variable_identifier            shift and go to state 41
    function_designator            shift and go to state 110
    array_identifier               shift and go to state 169
    boolean_factor                 shift and go to state 90
    exponential_part               shift and go to state 92
    term                           shift and go to state 113
    designational_expression       shift and go to state 171
    boolean_expression             shift and go to state 172
    procedure_identifier           shift and go to state 173
    simple_variable                shift and go to state 49
    switch_designator              shift and go to state 65
    adding_operator                shift and go to state 117
    implication                    shift and go to state 119
    expression                     shift and go to state 174
    unsigned_integer               shift and go to state 175

state 231

    (97) parameter_delimiter -> COMMA .

    IDENTIFIER      reduce using rule 97 (parameter_delimiter -> COMMA .)
    STRING          reduce using rule 97 (parameter_delimiter -> COMMA .)
    IF              reduce using rule 97 (parameter_delimiter -> COMMA .)
    LCBRACKET       reduce using rule 97 (parameter_delimiter -> COMMA .)
    PLUS            reduce using rule 97 (parameter_delimiter -> COMMA .)
    MINUS           reduce using rule 97 (parameter_delimiter -> COMMA .)
    DIGIT           reduce using rule 97 (parameter_delimiter -> COMMA .)
    NOT             reduce using rule 97 (parameter_delimiter -> COMMA .)
    EREAL           reduce using rule 97 (parameter_delimiter -> COMMA .)
    DOT             reduce using rule 97 (parameter_delimiter -> COMMA .)
    TRUE            reduce using rule 97 (parameter_delimiter -> COMMA .)
    FALSE           reduce using rule 97 (parameter_delimiter -> COMMA .)


state 232

    (74) label -> IDENTIFIER .
    (38) switch_identifier -> IDENTIFIER .
    (44) procedure_identifier -> IDENTIFIER .
    (175) variable_identifier -> IDENTIFIER .
    (31) array_identifier -> IDENTIFIER .

  ! reduce/reduce conflict for ELSE resolved using rule 74 (label -> IDENTIFIER .)
  ! reduce/reduce conflict for RCBRACKET resolved using rule 74 (label -> IDENTIFIER .)
  ! reduce/reduce conflict for LBBRACKET resolved using rule 31 (array_identifier -> IDENTIFIER .)
    ELSE            reduce using rule 74 (label -> IDENTIFIER .)
    RCBRACKET       reduce using rule 74 (label -> IDENTIFIER .)
    LCBRACKET       reduce using rule 44 (procedure_identifier -> IDENTIFIER .)
    POWER           reduce using rule 175 (variable_identifier -> IDENTIFIER .)
    TIMES           reduce using rule 175 (variable_identifier -> IDENTIFIER .)
    DIV             reduce using rule 175 (variable_identifier -> IDENTIFIER .)
    MOD             reduce using rule 175 (variable_identifier -> IDENTIFIER .)
    PLUS            reduce using rule 175 (variable_identifier -> IDENTIFIER .)
    MINUS           reduce using rule 175 (variable_identifier -> IDENTIFIER .)
    LESS            reduce using rule 175 (variable_identifier -> IDENTIFIER .)
    NOTGREATER      reduce using rule 175 (variable_identifier -> IDENTIFIER .)
    EQUAL           reduce using rule 175 (variable_identifier -> IDENTIFIER .)
    NOTLESS         reduce using rule 175 (variable_identifier -> IDENTIFIER .)
    GREATER         reduce using rule 175 (variable_identifier -> IDENTIFIER .)
    NOTEQUAL        reduce using rule 175 (variable_identifier -> IDENTIFIER .)
    AND             reduce using rule 175 (variable_identifier -> IDENTIFIER .)
    OR              reduce using rule 175 (variable_identifier -> IDENTIFIER .)
    IMPL            reduce using rule 175 (variable_identifier -> IDENTIFIER .)
    EQUIV           reduce using rule 175 (variable_identifier -> IDENTIFIER .)
    LBBRACKET       reduce using rule 31 (array_identifier -> IDENTIFIER .)

  ! LBBRACKET       [ reduce using rule 38 (switch_identifier -> IDENTIFIER .) ]
  ! ELSE            [ reduce using rule 175 (variable_identifier -> IDENTIFIER .) ]
  ! RCBRACKET       [ reduce using rule 175 (variable_identifier -> IDENTIFIER .) ]


state 233

    (87) designational_expression -> if_clause . simple_designational_expression ELSE designational_expression
    (122) arithmetic_expression -> if_clause . simple_arithmetic_expression ELSE arithmetic_expression
    (154) boolean_expression -> if_clause . simple_boolean ELSE boolean_expression
    (88) simple_designational_expression -> . label
    (89) simple_designational_expression -> . switch_designator
    (90) simple_designational_expression -> . LCBRACKET designational_expression RCBRACKET
    (123) simple_arithmetic_expression -> . term
    (124) simple_arithmetic_expression -> . adding_operator term
    (125) simple_arithmetic_expression -> . simple_arithmetic_expression adding_operator term
    (155) simple_boolean -> . implication
    (156) simple_boolean -> . simple_boolean EQUIV implication
    (74) label -> . IDENTIFIER
    (75) label -> . unsigned_integer
    (91) switch_designator -> . switch_identifier LBBRACKET subscript_expression RBBRACKET
    (128) term -> . factor
    (129) term -> . term multiplying_operator factor
    (126) adding_operator -> . PLUS
    (127) adding_operator -> . MINUS
    (157) implication -> . boolean_term
    (158) implication -> . implication IMPL boolean_term
    (146) unsigned_integer -> . DIGIT
    (147) unsigned_integer -> . unsigned_integer DIGIT
    (38) switch_identifier -> . IDENTIFIER
    (133) factor -> . primary
    (134) factor -> . factor
    (135) factor -> . factor POWER primary
    (159) boolean_term -> . boolean_factor
    (160) boolean_term -> . boolean_term OR boolean_factor
    (136) primary -> . unsigned_number
    (137) primary -> . variable
    (138) primary -> . function_designator
    (139) primary -> . LCBRACKET arithmetic_expression RCBRACKET
    (161) boolean_factor -> . boolean_secondary
    (162) boolean_factor -> . boolean_factor AND boolean_secondary
    (140) unsigned_number -> . decimal_number
    (141) unsigned_number -> . exponential_part
    (142) unsigned_number -> . decimal_number exponential_part
    (172) variable -> . simple_variable
    (173) variable -> . subscripted_variable
    (171) function_designator -> . procedure_identifier actual_parameter_part
    (163) boolean_secondary -> . boolean_primary
    (164) boolean_secondary -> . NOT boolean_primary
    (143) decimal_number -> . unsigned_integer
    (144) decimal_number -> . decimal_fraction
    (145) decimal_number -> . unsigned_integer decimal_fraction
    (149) exponential_part -> . EREAL integer
    (174) simple_variable -> . variable_identifier
    (176) subscripted_variable -> . array_identifier LBBRACKET subscript_list RBBRACKET
    (44) procedure_identifier -> . IDENTIFIER
    (165) boolean_primary -> . logical_value
    (166) boolean_primary -> . variable
    (167) boolean_primary -> . function_designator
    (168) boolean_primary -> . relation
    (169) boolean_primary -> . LCBRACKET boolean_expression RCBRACKET
    (148) decimal_fraction -> . DOT unsigned_integer
    (175) variable_identifier -> . IDENTIFIER
    (31) array_identifier -> . IDENTIFIER
    (183) logical_value -> . TRUE
    (184) logical_value -> . FALSE
    (170) relation -> . simple_arithmetic_expression relational_operator simple_arithmetic_expression

    LCBRACKET       shift and go to state 170
    IDENTIFIER      shift and go to state 232
    PLUS            shift and go to state 102
    MINUS           shift and go to state 94
    DIGIT           shift and go to state 6
    NOT             shift and go to state 118
    EREAL           shift and go to state 115
    DOT             shift and go to state 95
    TRUE            shift and go to state 93
    FALSE           shift and go to state 100

    boolean_primary                shift and go to state 99
    procedure_identifier           shift and go to state 125
    primary                        shift and go to state 98
    boolean_factor                 shift and go to state 90
    relation                       shift and go to state 91
    simple_boolean                 shift and go to state 187
    boolean_secondary              shift and go to state 101
    label                          shift and go to state 67
    decimal_fraction               shift and go to state 103
    factor                         shift and go to state 104
    unsigned_number                shift and go to state 105
    simple_arithmetic_expression   shift and go to state 186
    simple_designational_expression shift and go to state 156
    logical_value                  shift and go to state 109
    switch_identifier              shift and go to state 68
    decimal_number                 shift and go to state 112
    boolean_term                   shift and go to state 88
    variable_identifier            shift and go to state 41
    function_designator            shift and go to state 110
    array_identifier               shift and go to state 14
    variable                       shift and go to state 161
    exponential_part               shift and go to state 92
    term                           shift and go to state 113
    switch_designator              shift and go to state 65
    subscripted_variable           shift and go to state 13
    simple_variable                shift and go to state 49
    adding_operator                shift and go to state 117
    implication                    shift and go to state 119
    unsigned_integer               shift and go to state 175

state 234

    (37) switch_declaration -> SWITCH switch_identifier ASSIGNMENT switch_list .
    (40) switch_list -> switch_list . COMMA designational_expression

    SEMICOLON       reduce using rule 37 (switch_declaration -> SWITCH switch_identifier ASSIGNMENT switch_list .)
    COMMA           shift and go to state 271


state 235

    (39) switch_list -> designational_expression .

    COMMA           reduce using rule 39 (switch_list -> designational_expression .)
    SEMICOLON       reduce using rule 39 (switch_list -> designational_expression .)


state 236

    (42) procedure_declaration -> type PROCEDURE procedure_heading procedure_body .

    SEMICOLON       reduce using rule 42 (procedure_declaration -> type PROCEDURE procedure_heading procedure_body .)


state 237

    (36) lower_bound -> arithmetic_expression .

    COLON           reduce using rule 36 (lower_bound -> arithmetic_expression .)


state 238

    (34) bound_pair -> lower_bound . COLON upper_bound

    COLON           shift and go to state 272


state 239

    (29) array_segment -> array_identifier LBBRACKET bound_pair_list . RBBRACKET
    (33) bound_pair_list -> bound_pair_list . COMMA bound_pair

    RBBRACKET       shift and go to state 273
    COMMA           shift and go to state 274


state 240

    (32) bound_pair_list -> bound_pair .

    RBBRACKET       reduce using rule 32 (bound_pair_list -> bound_pair .)
    COMMA           reduce using rule 32 (bound_pair_list -> bound_pair .)


state 241

    (30) array_segment -> array_identifier COMMA array_segment .

    COMMA           reduce using rule 30 (array_segment -> array_identifier COMMA array_segment .)
    SEMICOLON       reduce using rule 30 (array_segment -> array_identifier COMMA array_segment .)


state 242

    (28) array_list -> array_list COMMA array_segment .

    COMMA           reduce using rule 28 (array_list -> array_list COMMA array_segment .)
    SEMICOLON       reduce using rule 28 (array_list -> array_list COMMA array_segment .)


state 243

    (113) for_list -> for_list_element .

    DO              reduce using rule 113 (for_list -> for_list_element .)
    COMMA           reduce using rule 113 (for_list -> for_list_element .)


state 244

    (112) for_clause -> FOR variable ASSIGNMENT for_list . DO
    (114) for_list -> for_list . COMMA for_list_element

    DO              shift and go to state 275
    COMMA           shift and go to state 276


state 245

    (115) for_list_element -> arithmetic_expression .
    (116) for_list_element -> arithmetic_expression . STEP arithmetic_expression UNTIL arithmetic_expression
    (117) for_list_element -> arithmetic_expression . WHILE boolean_expression

    DO              reduce using rule 115 (for_list_element -> arithmetic_expression .)
    COMMA           reduce using rule 115 (for_list_element -> arithmetic_expression .)
    STEP            shift and go to state 277
    WHILE           shift and go to state 278


state 246

    (160) boolean_term -> boolean_term OR boolean_factor .
    (162) boolean_factor -> boolean_factor . AND boolean_secondary

    OR              reduce using rule 160 (boolean_term -> boolean_term OR boolean_factor .)
    IMPL            reduce using rule 160 (boolean_term -> boolean_term OR boolean_factor .)
    EQUIV           reduce using rule 160 (boolean_term -> boolean_term OR boolean_factor .)
    RCBRACKET       reduce using rule 160 (boolean_term -> boolean_term OR boolean_factor .)
    COMMA           reduce using rule 160 (boolean_term -> boolean_term OR boolean_factor .)
    ELSE            reduce using rule 160 (boolean_term -> boolean_term OR boolean_factor .)
    END             reduce using rule 160 (boolean_term -> boolean_term OR boolean_factor .)
    SEMICOLON       reduce using rule 160 (boolean_term -> boolean_term OR boolean_factor .)
    THEN            reduce using rule 160 (boolean_term -> boolean_term OR boolean_factor .)
    DO              reduce using rule 160 (boolean_term -> boolean_term OR boolean_factor .)
    AND             shift and go to state 188


state 247

    (122) arithmetic_expression -> if_clause simple_arithmetic_expression ELSE . arithmetic_expression
    (121) arithmetic_expression -> . simple_arithmetic_expression
    (122) arithmetic_expression -> . if_clause simple_arithmetic_expression ELSE arithmetic_expression
    (123) simple_arithmetic_expression -> . term
    (124) simple_arithmetic_expression -> . adding_operator term
    (125) simple_arithmetic_expression -> . simple_arithmetic_expression adding_operator term
    (109) if_clause -> . IF boolean_expression THEN
    (128) term -> . factor
    (129) term -> . term multiplying_operator factor
    (126) adding_operator -> . PLUS
    (127) adding_operator -> . MINUS
    (133) factor -> . primary
    (134) factor -> . factor
    (135) factor -> . factor POWER primary
    (136) primary -> . unsigned_number
    (137) primary -> . variable
    (138) primary -> . function_designator
    (139) primary -> . LCBRACKET arithmetic_expression RCBRACKET
    (140) unsigned_number -> . decimal_number
    (141) unsigned_number -> . exponential_part
    (142) unsigned_number -> . decimal_number exponential_part
    (172) variable -> . simple_variable
    (173) variable -> . subscripted_variable
    (171) function_designator -> . procedure_identifier actual_parameter_part
    (143) decimal_number -> . unsigned_integer
    (144) decimal_number -> . decimal_fraction
    (145) decimal_number -> . unsigned_integer decimal_fraction
    (149) exponential_part -> . EREAL integer
    (174) simple_variable -> . variable_identifier
    (176) subscripted_variable -> . array_identifier LBBRACKET subscript_list RBBRACKET
    (44) procedure_identifier -> . IDENTIFIER
    (146) unsigned_integer -> . DIGIT
    (147) unsigned_integer -> . unsigned_integer DIGIT
    (148) decimal_fraction -> . DOT unsigned_integer
    (175) variable_identifier -> . IDENTIFIER
    (31) array_identifier -> . IDENTIFIER

    IF              shift and go to state 45
    PLUS            shift and go to state 102
    MINUS           shift and go to state 94
    LCBRACKET       shift and go to state 145
    EREAL           shift and go to state 115
    IDENTIFIER      shift and go to state 106
    DIGIT           shift and go to state 6
    DOT             shift and go to state 95

    subscripted_variable           shift and go to state 13
    primary                        shift and go to state 98
    if_clause                      shift and go to state 144
    unsigned_number                shift and go to state 105
    decimal_fraction               shift and go to state 103
    factor                         shift and go to state 104
    simple_arithmetic_expression   shift and go to state 147
    arithmetic_expression          shift and go to state 279
    decimal_number                 shift and go to state 112
    variable_identifier            shift and go to state 41
    function_designator            shift and go to state 149
    array_identifier               shift and go to state 14
    variable                       shift and go to state 150
    exponential_part               shift and go to state 92
    term                           shift and go to state 113
    procedure_identifier           shift and go to state 125
    simple_variable                shift and go to state 49
    adding_operator                shift and go to state 117
    unsigned_integer               shift and go to state 120

state 248

    (154) boolean_expression -> if_clause simple_boolean ELSE . boolean_expression
    (153) boolean_expression -> . simple_boolean
    (154) boolean_expression -> . if_clause simple_boolean ELSE boolean_expression
    (155) simple_boolean -> . implication
    (156) simple_boolean -> . simple_boolean EQUIV implication
    (109) if_clause -> . IF boolean_expression THEN
    (157) implication -> . boolean_term
    (158) implication -> . implication IMPL boolean_term
    (159) boolean_term -> . boolean_factor
    (160) boolean_term -> . boolean_term OR boolean_factor
    (161) boolean_factor -> . boolean_secondary
    (162) boolean_factor -> . boolean_factor AND boolean_secondary
    (163) boolean_secondary -> . boolean_primary
    (164) boolean_secondary -> . NOT boolean_primary
    (165) boolean_primary -> . logical_value
    (166) boolean_primary -> . variable
    (167) boolean_primary -> . function_designator
    (168) boolean_primary -> . relation
    (169) boolean_primary -> . LCBRACKET boolean_expression RCBRACKET
    (183) logical_value -> . TRUE
    (184) logical_value -> . FALSE
    (172) variable -> . simple_variable
    (173) variable -> . subscripted_variable
    (171) function_designator -> . procedure_identifier actual_parameter_part
    (170) relation -> . simple_arithmetic_expression relational_operator simple_arithmetic_expression
    (174) simple_variable -> . variable_identifier
    (176) subscripted_variable -> . array_identifier LBBRACKET subscript_list RBBRACKET
    (44) procedure_identifier -> . IDENTIFIER
    (123) simple_arithmetic_expression -> . term
    (124) simple_arithmetic_expression -> . adding_operator term
    (125) simple_arithmetic_expression -> . simple_arithmetic_expression adding_operator term
    (175) variable_identifier -> . IDENTIFIER
    (31) array_identifier -> . IDENTIFIER
    (128) term -> . factor
    (129) term -> . term multiplying_operator factor
    (126) adding_operator -> . PLUS
    (127) adding_operator -> . MINUS
    (133) factor -> . primary
    (134) factor -> . factor
    (135) factor -> . factor POWER primary
    (136) primary -> . unsigned_number
    (137) primary -> . variable
    (138) primary -> . function_designator
    (139) primary -> . LCBRACKET arithmetic_expression RCBRACKET
    (140) unsigned_number -> . decimal_number
    (141) unsigned_number -> . exponential_part
    (142) unsigned_number -> . decimal_number exponential_part
    (143) decimal_number -> . unsigned_integer
    (144) decimal_number -> . decimal_fraction
    (145) decimal_number -> . unsigned_integer decimal_fraction
    (149) exponential_part -> . EREAL integer
    (146) unsigned_integer -> . DIGIT
    (147) unsigned_integer -> . unsigned_integer DIGIT
    (148) decimal_fraction -> . DOT unsigned_integer

    IF              shift and go to state 45
    NOT             shift and go to state 118
    LCBRACKET       shift and go to state 127
    TRUE            shift and go to state 93
    FALSE           shift and go to state 100
    IDENTIFIER      shift and go to state 106
    PLUS            shift and go to state 102
    MINUS           shift and go to state 94
    EREAL           shift and go to state 115
    DIGIT           shift and go to state 6
    DOT             shift and go to state 95

    subscripted_variable           shift and go to state 13
    boolean_term                   shift and go to state 88
    if_clause                      shift and go to state 126
    boolean_factor                 shift and go to state 90
    relation                       shift and go to state 91
    simple_boolean                 shift and go to state 97
    boolean_secondary              shift and go to state 101
    unsigned_number                shift and go to state 105
    decimal_fraction               shift and go to state 103
    factor                         shift and go to state 104
    simple_arithmetic_expression   shift and go to state 131
    boolean_primary                shift and go to state 99
    logical_value                  shift and go to state 109
    decimal_number                 shift and go to state 112
    primary                        shift and go to state 98
    variable_identifier            shift and go to state 41
    function_designator            shift and go to state 128
    array_identifier               shift and go to state 14
    variable                       shift and go to state 129
    exponential_part               shift and go to state 92
    term                           shift and go to state 113
    boolean_expression             shift and go to state 280
    procedure_identifier           shift and go to state 125
    simple_variable                shift and go to state 49
    adding_operator                shift and go to state 117
    implication                    shift and go to state 119
    unsigned_integer               shift and go to state 120

state 249

    (162) boolean_factor -> boolean_factor AND boolean_secondary .

    AND             reduce using rule 162 (boolean_factor -> boolean_factor AND boolean_secondary .)
    OR              reduce using rule 162 (boolean_factor -> boolean_factor AND boolean_secondary .)
    IMPL            reduce using rule 162 (boolean_factor -> boolean_factor AND boolean_secondary .)
    ELSE            reduce using rule 162 (boolean_factor -> boolean_factor AND boolean_secondary .)
    EQUIV           reduce using rule 162 (boolean_factor -> boolean_factor AND boolean_secondary .)
    END             reduce using rule 162 (boolean_factor -> boolean_factor AND boolean_secondary .)
    SEMICOLON       reduce using rule 162 (boolean_factor -> boolean_factor AND boolean_secondary .)
    THEN            reduce using rule 162 (boolean_factor -> boolean_factor AND boolean_secondary .)
    RCBRACKET       reduce using rule 162 (boolean_factor -> boolean_factor AND boolean_secondary .)
    COMMA           reduce using rule 162 (boolean_factor -> boolean_factor AND boolean_secondary .)
    DO              reduce using rule 162 (boolean_factor -> boolean_factor AND boolean_secondary .)


state 250

    (156) simple_boolean -> simple_boolean EQUIV implication .
    (158) implication -> implication . IMPL boolean_term

    EQUIV           reduce using rule 156 (simple_boolean -> simple_boolean EQUIV implication .)
    THEN            reduce using rule 156 (simple_boolean -> simple_boolean EQUIV implication .)
    RCBRACKET       reduce using rule 156 (simple_boolean -> simple_boolean EQUIV implication .)
    ELSE            reduce using rule 156 (simple_boolean -> simple_boolean EQUIV implication .)
    DO              reduce using rule 156 (simple_boolean -> simple_boolean EQUIV implication .)
    COMMA           reduce using rule 156 (simple_boolean -> simple_boolean EQUIV implication .)
    END             reduce using rule 156 (simple_boolean -> simple_boolean EQUIV implication .)
    SEMICOLON       reduce using rule 156 (simple_boolean -> simple_boolean EQUIV implication .)
    IMPL            shift and go to state 213


state 251

    (135) factor -> factor POWER primary .

    POWER           reduce using rule 135 (factor -> factor POWER primary .)
    TIMES           reduce using rule 135 (factor -> factor POWER primary .)
    DIV             reduce using rule 135 (factor -> factor POWER primary .)
    MOD             reduce using rule 135 (factor -> factor POWER primary .)
    LESS            reduce using rule 135 (factor -> factor POWER primary .)
    NOTGREATER      reduce using rule 135 (factor -> factor POWER primary .)
    EQUAL           reduce using rule 135 (factor -> factor POWER primary .)
    NOTLESS         reduce using rule 135 (factor -> factor POWER primary .)
    GREATER         reduce using rule 135 (factor -> factor POWER primary .)
    NOTEQUAL        reduce using rule 135 (factor -> factor POWER primary .)
    PLUS            reduce using rule 135 (factor -> factor POWER primary .)
    MINUS           reduce using rule 135 (factor -> factor POWER primary .)
    STEP            reduce using rule 135 (factor -> factor POWER primary .)
    WHILE           reduce using rule 135 (factor -> factor POWER primary .)
    DO              reduce using rule 135 (factor -> factor POWER primary .)
    COMMA           reduce using rule 135 (factor -> factor POWER primary .)
    RCBRACKET       reduce using rule 135 (factor -> factor POWER primary .)
    END             reduce using rule 135 (factor -> factor POWER primary .)
    SEMICOLON       reduce using rule 135 (factor -> factor POWER primary .)
    ELSE            reduce using rule 135 (factor -> factor POWER primary .)
    RBBRACKET       reduce using rule 135 (factor -> factor POWER primary .)
    COLON           reduce using rule 135 (factor -> factor POWER primary .)
    AND             reduce using rule 135 (factor -> factor POWER primary .)
    OR              reduce using rule 135 (factor -> factor POWER primary .)
    IMPL            reduce using rule 135 (factor -> factor POWER primary .)
    EQUIV           reduce using rule 135 (factor -> factor POWER primary .)
    THEN            reduce using rule 135 (factor -> factor POWER primary .)
    UNTIL           reduce using rule 135 (factor -> factor POWER primary .)


state 252

    (170) relation -> simple_arithmetic_expression relational_operator simple_arithmetic_expression .
    (125) simple_arithmetic_expression -> simple_arithmetic_expression . adding_operator term
    (126) adding_operator -> . PLUS
    (127) adding_operator -> . MINUS

    AND             reduce using rule 170 (relation -> simple_arithmetic_expression relational_operator simple_arithmetic_expression .)
    OR              reduce using rule 170 (relation -> simple_arithmetic_expression relational_operator simple_arithmetic_expression .)
    IMPL            reduce using rule 170 (relation -> simple_arithmetic_expression relational_operator simple_arithmetic_expression .)
    EQUIV           reduce using rule 170 (relation -> simple_arithmetic_expression relational_operator simple_arithmetic_expression .)
    RCBRACKET       reduce using rule 170 (relation -> simple_arithmetic_expression relational_operator simple_arithmetic_expression .)
    END             reduce using rule 170 (relation -> simple_arithmetic_expression relational_operator simple_arithmetic_expression .)
    SEMICOLON       reduce using rule 170 (relation -> simple_arithmetic_expression relational_operator simple_arithmetic_expression .)
    ELSE            reduce using rule 170 (relation -> simple_arithmetic_expression relational_operator simple_arithmetic_expression .)
    THEN            reduce using rule 170 (relation -> simple_arithmetic_expression relational_operator simple_arithmetic_expression .)
    COMMA           reduce using rule 170 (relation -> simple_arithmetic_expression relational_operator simple_arithmetic_expression .)
    DO              reduce using rule 170 (relation -> simple_arithmetic_expression relational_operator simple_arithmetic_expression .)
    PLUS            shift and go to state 102
    MINUS           shift and go to state 94

    adding_operator                shift and go to state 196

state 253

    (125) simple_arithmetic_expression -> simple_arithmetic_expression adding_operator term .
    (129) term -> term . multiplying_operator factor
    (130) multiplying_operator -> . TIMES
    (131) multiplying_operator -> . DIV
    (132) multiplying_operator -> . MOD

    ELSE            reduce using rule 125 (simple_arithmetic_expression -> simple_arithmetic_expression adding_operator term .)
    PLUS            reduce using rule 125 (simple_arithmetic_expression -> simple_arithmetic_expression adding_operator term .)
    MINUS           reduce using rule 125 (simple_arithmetic_expression -> simple_arithmetic_expression adding_operator term .)
    LESS            reduce using rule 125 (simple_arithmetic_expression -> simple_arithmetic_expression adding_operator term .)
    NOTGREATER      reduce using rule 125 (simple_arithmetic_expression -> simple_arithmetic_expression adding_operator term .)
    EQUAL           reduce using rule 125 (simple_arithmetic_expression -> simple_arithmetic_expression adding_operator term .)
    NOTLESS         reduce using rule 125 (simple_arithmetic_expression -> simple_arithmetic_expression adding_operator term .)
    GREATER         reduce using rule 125 (simple_arithmetic_expression -> simple_arithmetic_expression adding_operator term .)
    NOTEQUAL        reduce using rule 125 (simple_arithmetic_expression -> simple_arithmetic_expression adding_operator term .)
    RCBRACKET       reduce using rule 125 (simple_arithmetic_expression -> simple_arithmetic_expression adding_operator term .)
    RBBRACKET       reduce using rule 125 (simple_arithmetic_expression -> simple_arithmetic_expression adding_operator term .)
    COMMA           reduce using rule 125 (simple_arithmetic_expression -> simple_arithmetic_expression adding_operator term .)
    STEP            reduce using rule 125 (simple_arithmetic_expression -> simple_arithmetic_expression adding_operator term .)
    WHILE           reduce using rule 125 (simple_arithmetic_expression -> simple_arithmetic_expression adding_operator term .)
    DO              reduce using rule 125 (simple_arithmetic_expression -> simple_arithmetic_expression adding_operator term .)
    END             reduce using rule 125 (simple_arithmetic_expression -> simple_arithmetic_expression adding_operator term .)
    SEMICOLON       reduce using rule 125 (simple_arithmetic_expression -> simple_arithmetic_expression adding_operator term .)
    COLON           reduce using rule 125 (simple_arithmetic_expression -> simple_arithmetic_expression adding_operator term .)
    UNTIL           reduce using rule 125 (simple_arithmetic_expression -> simple_arithmetic_expression adding_operator term .)
    AND             reduce using rule 125 (simple_arithmetic_expression -> simple_arithmetic_expression adding_operator term .)
    OR              reduce using rule 125 (simple_arithmetic_expression -> simple_arithmetic_expression adding_operator term .)
    IMPL            reduce using rule 125 (simple_arithmetic_expression -> simple_arithmetic_expression adding_operator term .)
    EQUIV           reduce using rule 125 (simple_arithmetic_expression -> simple_arithmetic_expression adding_operator term .)
    THEN            reduce using rule 125 (simple_arithmetic_expression -> simple_arithmetic_expression adding_operator term .)
    TIMES           shift and go to state 201
    DIV             shift and go to state 202
    MOD             shift and go to state 204

    multiplying_operator           shift and go to state 203

state 254

    (129) term -> term multiplying_operator factor .
    (134) factor -> factor .
    (135) factor -> factor . POWER primary

  ! reduce/reduce conflict for TIMES resolved using rule 129 (term -> term multiplying_operator factor .)
  ! reduce/reduce conflict for DIV resolved using rule 129 (term -> term multiplying_operator factor .)
  ! reduce/reduce conflict for MOD resolved using rule 129 (term -> term multiplying_operator factor .)
  ! reduce/reduce conflict for PLUS resolved using rule 129 (term -> term multiplying_operator factor .)
  ! reduce/reduce conflict for MINUS resolved using rule 129 (term -> term multiplying_operator factor .)
  ! reduce/reduce conflict for LESS resolved using rule 129 (term -> term multiplying_operator factor .)
  ! reduce/reduce conflict for NOTGREATER resolved using rule 129 (term -> term multiplying_operator factor .)
  ! reduce/reduce conflict for EQUAL resolved using rule 129 (term -> term multiplying_operator factor .)
  ! reduce/reduce conflict for NOTLESS resolved using rule 129 (term -> term multiplying_operator factor .)
  ! reduce/reduce conflict for GREATER resolved using rule 129 (term -> term multiplying_operator factor .)
  ! reduce/reduce conflict for NOTEQUAL resolved using rule 129 (term -> term multiplying_operator factor .)
  ! reduce/reduce conflict for END resolved using rule 129 (term -> term multiplying_operator factor .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 129 (term -> term multiplying_operator factor .)
  ! reduce/reduce conflict for ELSE resolved using rule 129 (term -> term multiplying_operator factor .)
  ! reduce/reduce conflict for RBBRACKET resolved using rule 129 (term -> term multiplying_operator factor .)
  ! reduce/reduce conflict for COMMA resolved using rule 129 (term -> term multiplying_operator factor .)
  ! reduce/reduce conflict for RCBRACKET resolved using rule 129 (term -> term multiplying_operator factor .)
  ! reduce/reduce conflict for COLON resolved using rule 129 (term -> term multiplying_operator factor .)
  ! reduce/reduce conflict for STEP resolved using rule 129 (term -> term multiplying_operator factor .)
  ! reduce/reduce conflict for WHILE resolved using rule 129 (term -> term multiplying_operator factor .)
  ! reduce/reduce conflict for DO resolved using rule 129 (term -> term multiplying_operator factor .)
  ! reduce/reduce conflict for AND resolved using rule 129 (term -> term multiplying_operator factor .)
  ! reduce/reduce conflict for OR resolved using rule 129 (term -> term multiplying_operator factor .)
  ! reduce/reduce conflict for IMPL resolved using rule 129 (term -> term multiplying_operator factor .)
  ! reduce/reduce conflict for EQUIV resolved using rule 129 (term -> term multiplying_operator factor .)
  ! reduce/reduce conflict for THEN resolved using rule 129 (term -> term multiplying_operator factor .)
  ! reduce/reduce conflict for UNTIL resolved using rule 129 (term -> term multiplying_operator factor .)
  ! shift/reduce conflict for POWER resolved as shift
    TIMES           reduce using rule 129 (term -> term multiplying_operator factor .)
    DIV             reduce using rule 129 (term -> term multiplying_operator factor .)
    MOD             reduce using rule 129 (term -> term multiplying_operator factor .)
    ELSE            reduce using rule 129 (term -> term multiplying_operator factor .)
    PLUS            reduce using rule 129 (term -> term multiplying_operator factor .)
    MINUS           reduce using rule 129 (term -> term multiplying_operator factor .)
    LESS            reduce using rule 129 (term -> term multiplying_operator factor .)
    NOTGREATER      reduce using rule 129 (term -> term multiplying_operator factor .)
    EQUAL           reduce using rule 129 (term -> term multiplying_operator factor .)
    NOTLESS         reduce using rule 129 (term -> term multiplying_operator factor .)
    GREATER         reduce using rule 129 (term -> term multiplying_operator factor .)
    NOTEQUAL        reduce using rule 129 (term -> term multiplying_operator factor .)
    RCBRACKET       reduce using rule 129 (term -> term multiplying_operator factor .)
    END             reduce using rule 129 (term -> term multiplying_operator factor .)
    SEMICOLON       reduce using rule 129 (term -> term multiplying_operator factor .)
    RBBRACKET       reduce using rule 129 (term -> term multiplying_operator factor .)
    COMMA           reduce using rule 129 (term -> term multiplying_operator factor .)
    COLON           reduce using rule 129 (term -> term multiplying_operator factor .)
    STEP            reduce using rule 129 (term -> term multiplying_operator factor .)
    WHILE           reduce using rule 129 (term -> term multiplying_operator factor .)
    DO              reduce using rule 129 (term -> term multiplying_operator factor .)
    AND             reduce using rule 129 (term -> term multiplying_operator factor .)
    OR              reduce using rule 129 (term -> term multiplying_operator factor .)
    IMPL            reduce using rule 129 (term -> term multiplying_operator factor .)
    EQUIV           reduce using rule 129 (term -> term multiplying_operator factor .)
    THEN            reduce using rule 129 (term -> term multiplying_operator factor .)
    UNTIL           reduce using rule 129 (term -> term multiplying_operator factor .)
    POWER           shift and go to state 191

  ! POWER           [ reduce using rule 134 (factor -> factor .) ]
  ! TIMES           [ reduce using rule 134 (factor -> factor .) ]
  ! DIV             [ reduce using rule 134 (factor -> factor .) ]
  ! MOD             [ reduce using rule 134 (factor -> factor .) ]
  ! PLUS            [ reduce using rule 134 (factor -> factor .) ]
  ! MINUS           [ reduce using rule 134 (factor -> factor .) ]
  ! LESS            [ reduce using rule 134 (factor -> factor .) ]
  ! NOTGREATER      [ reduce using rule 134 (factor -> factor .) ]
  ! EQUAL           [ reduce using rule 134 (factor -> factor .) ]
  ! NOTLESS         [ reduce using rule 134 (factor -> factor .) ]
  ! GREATER         [ reduce using rule 134 (factor -> factor .) ]
  ! NOTEQUAL        [ reduce using rule 134 (factor -> factor .) ]
  ! END             [ reduce using rule 134 (factor -> factor .) ]
  ! SEMICOLON       [ reduce using rule 134 (factor -> factor .) ]
  ! ELSE            [ reduce using rule 134 (factor -> factor .) ]
  ! RBBRACKET       [ reduce using rule 134 (factor -> factor .) ]
  ! COMMA           [ reduce using rule 134 (factor -> factor .) ]
  ! RCBRACKET       [ reduce using rule 134 (factor -> factor .) ]
  ! COLON           [ reduce using rule 134 (factor -> factor .) ]
  ! STEP            [ reduce using rule 134 (factor -> factor .) ]
  ! WHILE           [ reduce using rule 134 (factor -> factor .) ]
  ! DO              [ reduce using rule 134 (factor -> factor .) ]
  ! AND             [ reduce using rule 134 (factor -> factor .) ]
  ! OR              [ reduce using rule 134 (factor -> factor .) ]
  ! IMPL            [ reduce using rule 134 (factor -> factor .) ]
  ! EQUIV           [ reduce using rule 134 (factor -> factor .) ]
  ! THEN            [ reduce using rule 134 (factor -> factor .) ]
  ! UNTIL           [ reduce using rule 134 (factor -> factor .) ]


state 255

    (151) integer -> PLUS unsigned_integer .
    (147) unsigned_integer -> unsigned_integer . DIGIT

    POWER           reduce using rule 151 (integer -> PLUS unsigned_integer .)
    TIMES           reduce using rule 151 (integer -> PLUS unsigned_integer .)
    DIV             reduce using rule 151 (integer -> PLUS unsigned_integer .)
    MOD             reduce using rule 151 (integer -> PLUS unsigned_integer .)
    PLUS            reduce using rule 151 (integer -> PLUS unsigned_integer .)
    MINUS           reduce using rule 151 (integer -> PLUS unsigned_integer .)
    LESS            reduce using rule 151 (integer -> PLUS unsigned_integer .)
    NOTGREATER      reduce using rule 151 (integer -> PLUS unsigned_integer .)
    EQUAL           reduce using rule 151 (integer -> PLUS unsigned_integer .)
    NOTLESS         reduce using rule 151 (integer -> PLUS unsigned_integer .)
    GREATER         reduce using rule 151 (integer -> PLUS unsigned_integer .)
    NOTEQUAL        reduce using rule 151 (integer -> PLUS unsigned_integer .)
    END             reduce using rule 151 (integer -> PLUS unsigned_integer .)
    SEMICOLON       reduce using rule 151 (integer -> PLUS unsigned_integer .)
    ELSE            reduce using rule 151 (integer -> PLUS unsigned_integer .)
    RBBRACKET       reduce using rule 151 (integer -> PLUS unsigned_integer .)
    COMMA           reduce using rule 151 (integer -> PLUS unsigned_integer .)
    RCBRACKET       reduce using rule 151 (integer -> PLUS unsigned_integer .)
    COLON           reduce using rule 151 (integer -> PLUS unsigned_integer .)
    STEP            reduce using rule 151 (integer -> PLUS unsigned_integer .)
    WHILE           reduce using rule 151 (integer -> PLUS unsigned_integer .)
    DO              reduce using rule 151 (integer -> PLUS unsigned_integer .)
    AND             reduce using rule 151 (integer -> PLUS unsigned_integer .)
    OR              reduce using rule 151 (integer -> PLUS unsigned_integer .)
    IMPL            reduce using rule 151 (integer -> PLUS unsigned_integer .)
    EQUIV           reduce using rule 151 (integer -> PLUS unsigned_integer .)
    THEN            reduce using rule 151 (integer -> PLUS unsigned_integer .)
    UNTIL           reduce using rule 151 (integer -> PLUS unsigned_integer .)
    DIGIT           shift and go to state 57


state 256

    (152) integer -> MINUS unsigned_integer .
    (147) unsigned_integer -> unsigned_integer . DIGIT

    POWER           reduce using rule 152 (integer -> MINUS unsigned_integer .)
    TIMES           reduce using rule 152 (integer -> MINUS unsigned_integer .)
    DIV             reduce using rule 152 (integer -> MINUS unsigned_integer .)
    MOD             reduce using rule 152 (integer -> MINUS unsigned_integer .)
    PLUS            reduce using rule 152 (integer -> MINUS unsigned_integer .)
    MINUS           reduce using rule 152 (integer -> MINUS unsigned_integer .)
    LESS            reduce using rule 152 (integer -> MINUS unsigned_integer .)
    NOTGREATER      reduce using rule 152 (integer -> MINUS unsigned_integer .)
    EQUAL           reduce using rule 152 (integer -> MINUS unsigned_integer .)
    NOTLESS         reduce using rule 152 (integer -> MINUS unsigned_integer .)
    GREATER         reduce using rule 152 (integer -> MINUS unsigned_integer .)
    NOTEQUAL        reduce using rule 152 (integer -> MINUS unsigned_integer .)
    END             reduce using rule 152 (integer -> MINUS unsigned_integer .)
    SEMICOLON       reduce using rule 152 (integer -> MINUS unsigned_integer .)
    ELSE            reduce using rule 152 (integer -> MINUS unsigned_integer .)
    RBBRACKET       reduce using rule 152 (integer -> MINUS unsigned_integer .)
    COMMA           reduce using rule 152 (integer -> MINUS unsigned_integer .)
    RCBRACKET       reduce using rule 152 (integer -> MINUS unsigned_integer .)
    COLON           reduce using rule 152 (integer -> MINUS unsigned_integer .)
    STEP            reduce using rule 152 (integer -> MINUS unsigned_integer .)
    WHILE           reduce using rule 152 (integer -> MINUS unsigned_integer .)
    DO              reduce using rule 152 (integer -> MINUS unsigned_integer .)
    AND             reduce using rule 152 (integer -> MINUS unsigned_integer .)
    OR              reduce using rule 152 (integer -> MINUS unsigned_integer .)
    IMPL            reduce using rule 152 (integer -> MINUS unsigned_integer .)
    EQUIV           reduce using rule 152 (integer -> MINUS unsigned_integer .)
    THEN            reduce using rule 152 (integer -> MINUS unsigned_integer .)
    UNTIL           reduce using rule 152 (integer -> MINUS unsigned_integer .)
    DIGIT           shift and go to state 57


state 257

    (139) primary -> LCBRACKET arithmetic_expression RCBRACKET .

    POWER           reduce using rule 139 (primary -> LCBRACKET arithmetic_expression RCBRACKET .)
    TIMES           reduce using rule 139 (primary -> LCBRACKET arithmetic_expression RCBRACKET .)
    DIV             reduce using rule 139 (primary -> LCBRACKET arithmetic_expression RCBRACKET .)
    MOD             reduce using rule 139 (primary -> LCBRACKET arithmetic_expression RCBRACKET .)
    PLUS            reduce using rule 139 (primary -> LCBRACKET arithmetic_expression RCBRACKET .)
    MINUS           reduce using rule 139 (primary -> LCBRACKET arithmetic_expression RCBRACKET .)
    LESS            reduce using rule 139 (primary -> LCBRACKET arithmetic_expression RCBRACKET .)
    NOTGREATER      reduce using rule 139 (primary -> LCBRACKET arithmetic_expression RCBRACKET .)
    EQUAL           reduce using rule 139 (primary -> LCBRACKET arithmetic_expression RCBRACKET .)
    NOTLESS         reduce using rule 139 (primary -> LCBRACKET arithmetic_expression RCBRACKET .)
    GREATER         reduce using rule 139 (primary -> LCBRACKET arithmetic_expression RCBRACKET .)
    NOTEQUAL        reduce using rule 139 (primary -> LCBRACKET arithmetic_expression RCBRACKET .)
    RCBRACKET       reduce using rule 139 (primary -> LCBRACKET arithmetic_expression RCBRACKET .)
    ELSE            reduce using rule 139 (primary -> LCBRACKET arithmetic_expression RCBRACKET .)
    RBBRACKET       reduce using rule 139 (primary -> LCBRACKET arithmetic_expression RCBRACKET .)
    COMMA           reduce using rule 139 (primary -> LCBRACKET arithmetic_expression RCBRACKET .)
    STEP            reduce using rule 139 (primary -> LCBRACKET arithmetic_expression RCBRACKET .)
    WHILE           reduce using rule 139 (primary -> LCBRACKET arithmetic_expression RCBRACKET .)
    DO              reduce using rule 139 (primary -> LCBRACKET arithmetic_expression RCBRACKET .)
    UNTIL           reduce using rule 139 (primary -> LCBRACKET arithmetic_expression RCBRACKET .)
    COLON           reduce using rule 139 (primary -> LCBRACKET arithmetic_expression RCBRACKET .)
    END             reduce using rule 139 (primary -> LCBRACKET arithmetic_expression RCBRACKET .)
    SEMICOLON       reduce using rule 139 (primary -> LCBRACKET arithmetic_expression RCBRACKET .)
    AND             reduce using rule 139 (primary -> LCBRACKET arithmetic_expression RCBRACKET .)
    OR              reduce using rule 139 (primary -> LCBRACKET arithmetic_expression RCBRACKET .)
    IMPL            reduce using rule 139 (primary -> LCBRACKET arithmetic_expression RCBRACKET .)
    EQUIV           reduce using rule 139 (primary -> LCBRACKET arithmetic_expression RCBRACKET .)
    THEN            reduce using rule 139 (primary -> LCBRACKET arithmetic_expression RCBRACKET .)


state 258

    (169) boolean_primary -> LCBRACKET boolean_expression RCBRACKET .

    AND             reduce using rule 169 (boolean_primary -> LCBRACKET boolean_expression RCBRACKET .)
    OR              reduce using rule 169 (boolean_primary -> LCBRACKET boolean_expression RCBRACKET .)
    IMPL            reduce using rule 169 (boolean_primary -> LCBRACKET boolean_expression RCBRACKET .)
    ELSE            reduce using rule 169 (boolean_primary -> LCBRACKET boolean_expression RCBRACKET .)
    EQUIV           reduce using rule 169 (boolean_primary -> LCBRACKET boolean_expression RCBRACKET .)
    END             reduce using rule 169 (boolean_primary -> LCBRACKET boolean_expression RCBRACKET .)
    SEMICOLON       reduce using rule 169 (boolean_primary -> LCBRACKET boolean_expression RCBRACKET .)
    THEN            reduce using rule 169 (boolean_primary -> LCBRACKET boolean_expression RCBRACKET .)
    RCBRACKET       reduce using rule 169 (boolean_primary -> LCBRACKET boolean_expression RCBRACKET .)
    COMMA           reduce using rule 169 (boolean_primary -> LCBRACKET boolean_expression RCBRACKET .)
    DO              reduce using rule 169 (boolean_primary -> LCBRACKET boolean_expression RCBRACKET .)


state 259

    (158) implication -> implication IMPL boolean_term .
    (160) boolean_term -> boolean_term . OR boolean_factor

    IMPL            reduce using rule 158 (implication -> implication IMPL boolean_term .)
    EQUIV           reduce using rule 158 (implication -> implication IMPL boolean_term .)
    DO              reduce using rule 158 (implication -> implication IMPL boolean_term .)
    COMMA           reduce using rule 158 (implication -> implication IMPL boolean_term .)
    ELSE            reduce using rule 158 (implication -> implication IMPL boolean_term .)
    THEN            reduce using rule 158 (implication -> implication IMPL boolean_term .)
    RCBRACKET       reduce using rule 158 (implication -> implication IMPL boolean_term .)
    END             reduce using rule 158 (implication -> implication IMPL boolean_term .)
    SEMICOLON       reduce using rule 158 (implication -> implication IMPL boolean_term .)
    OR              shift and go to state 185


state 260

    (43) procedure_heading -> procedure_identifier formal_parameter_part SEMICOLON . value_part specification_part
    (50) value_part -> .
    (51) value_part -> . TVALUE identifier_list SEMICOLON

    TSTRING         reduce using rule 50 (value_part -> .)
    TARRAY          reduce using rule 50 (value_part -> .)
    TLABEL          reduce using rule 50 (value_part -> .)
    SWITCH          reduce using rule 50 (value_part -> .)
    PROCEDURE       reduce using rule 50 (value_part -> .)
    TREAL           reduce using rule 50 (value_part -> .)
    TINTEGER        reduce using rule 50 (value_part -> .)
    TBOOLEAN        reduce using rule 50 (value_part -> .)
    IF              reduce using rule 50 (value_part -> .)
    IDENTIFIER      reduce using rule 50 (value_part -> .)
    FOR             reduce using rule 50 (value_part -> .)
    BEGIN           reduce using rule 50 (value_part -> .)
    DIGIT           reduce using rule 50 (value_part -> .)
    GOTO            reduce using rule 50 (value_part -> .)
    TVALUE          shift and go to state 281

    value_part                     shift and go to state 282

state 261

    (46) formal_parameter_part -> LCBRACKET formal_parameter_list . RCBRACKET
    (48) formal_parameter_list -> formal_parameter_list . parameter_delimiter formal_parameter
    (97) parameter_delimiter -> . COMMA
    (98) parameter_delimiter -> . RCBRACKET letter_string COLON LCBRACKET

    RCBRACKET       shift and go to state 283
    COMMA           shift and go to state 231

    parameter_delimiter            shift and go to state 284

state 262

    (47) formal_parameter_list -> formal_parameter .

    RCBRACKET       reduce using rule 47 (formal_parameter_list -> formal_parameter .)
    COMMA           reduce using rule 47 (formal_parameter_list -> formal_parameter .)


state 263

    (49) formal_parameter -> IDENTIFIER .

    RCBRACKET       reduce using rule 49 (formal_parameter -> IDENTIFIER .)
    COMMA           reduce using rule 49 (formal_parameter -> IDENTIFIER .)


state 264

    (24) type_list -> simple_variable COMMA type_list .

    SEMICOLON       reduce using rule 24 (type_list -> simple_variable COMMA type_list .)


state 265

    (178) subscript_list -> subscript_list COMMA subscript_expression .

    RBBRACKET       reduce using rule 178 (subscript_list -> subscript_list COMMA subscript_expression .)
    COMMA           reduce using rule 178 (subscript_list -> subscript_list COMMA subscript_expression .)


state 266

    (87) designational_expression -> if_clause simple_designational_expression ELSE designational_expression .

    END             reduce using rule 87 (designational_expression -> if_clause simple_designational_expression ELSE designational_expression .)
    SEMICOLON       reduce using rule 87 (designational_expression -> if_clause simple_designational_expression ELSE designational_expression .)
    ELSE            reduce using rule 87 (designational_expression -> if_clause simple_designational_expression ELSE designational_expression .)
    RCBRACKET       reduce using rule 87 (designational_expression -> if_clause simple_designational_expression ELSE designational_expression .)
    COMMA           reduce using rule 87 (designational_expression -> if_clause simple_designational_expression ELSE designational_expression .)


state 267

    (91) switch_designator -> switch_identifier LBBRACKET subscript_expression RBBRACKET .

    RCBRACKET       reduce using rule 91 (switch_designator -> switch_identifier LBBRACKET subscript_expression RBBRACKET .)
    COMMA           reduce using rule 91 (switch_designator -> switch_identifier LBBRACKET subscript_expression RBBRACKET .)
    ELSE            reduce using rule 91 (switch_designator -> switch_identifier LBBRACKET subscript_expression RBBRACKET .)
    SEMICOLON       reduce using rule 91 (switch_designator -> switch_identifier LBBRACKET subscript_expression RBBRACKET .)
    END             reduce using rule 91 (switch_designator -> switch_identifier LBBRACKET subscript_expression RBBRACKET .)


state 268

    (98) parameter_delimiter -> RCBRACKET letter_string . COLON LCBRACKET
    (182) letter_string -> letter_string . LETTER

    COLON           shift and go to state 285
    LETTER          shift and go to state 286


state 269

    (181) letter_string -> LETTER .

    COLON           reduce using rule 181 (letter_string -> LETTER .)
    LETTER          reduce using rule 181 (letter_string -> LETTER .)


state 270

    (96) actual_parameter_list -> actual_parameter_list parameter_delimiter actual_parameter .

    RCBRACKET       reduce using rule 96 (actual_parameter_list -> actual_parameter_list parameter_delimiter actual_parameter .)
    COMMA           reduce using rule 96 (actual_parameter_list -> actual_parameter_list parameter_delimiter actual_parameter .)


state 271

    (40) switch_list -> switch_list COMMA . designational_expression
    (86) designational_expression -> . simple_designational_expression
    (87) designational_expression -> . if_clause simple_designational_expression ELSE designational_expression
    (88) simple_designational_expression -> . label
    (89) simple_designational_expression -> . switch_designator
    (90) simple_designational_expression -> . LCBRACKET designational_expression RCBRACKET
    (109) if_clause -> . IF boolean_expression THEN
    (74) label -> . IDENTIFIER
    (75) label -> . unsigned_integer
    (91) switch_designator -> . switch_identifier LBBRACKET subscript_expression RBBRACKET
    (146) unsigned_integer -> . DIGIT
    (147) unsigned_integer -> . unsigned_integer DIGIT
    (38) switch_identifier -> . IDENTIFIER

    LCBRACKET       shift and go to state 69
    IF              shift and go to state 45
    IDENTIFIER      shift and go to state 70
    DIGIT           shift and go to state 6

    designational_expression       shift and go to state 287
    simple_designational_expression shift and go to state 71
    switch_designator              shift and go to state 65
    if_clause                      shift and go to state 66
    label                          shift and go to state 67
    switch_identifier              shift and go to state 68
    unsigned_integer               shift and go to state 9

state 272

    (34) bound_pair -> lower_bound COLON . upper_bound
    (35) upper_bound -> . arithmetic_expression
    (121) arithmetic_expression -> . simple_arithmetic_expression
    (122) arithmetic_expression -> . if_clause simple_arithmetic_expression ELSE arithmetic_expression
    (123) simple_arithmetic_expression -> . term
    (124) simple_arithmetic_expression -> . adding_operator term
    (125) simple_arithmetic_expression -> . simple_arithmetic_expression adding_operator term
    (109) if_clause -> . IF boolean_expression THEN
    (128) term -> . factor
    (129) term -> . term multiplying_operator factor
    (126) adding_operator -> . PLUS
    (127) adding_operator -> . MINUS
    (133) factor -> . primary
    (134) factor -> . factor
    (135) factor -> . factor POWER primary
    (136) primary -> . unsigned_number
    (137) primary -> . variable
    (138) primary -> . function_designator
    (139) primary -> . LCBRACKET arithmetic_expression RCBRACKET
    (140) unsigned_number -> . decimal_number
    (141) unsigned_number -> . exponential_part
    (142) unsigned_number -> . decimal_number exponential_part
    (172) variable -> . simple_variable
    (173) variable -> . subscripted_variable
    (171) function_designator -> . procedure_identifier actual_parameter_part
    (143) decimal_number -> . unsigned_integer
    (144) decimal_number -> . decimal_fraction
    (145) decimal_number -> . unsigned_integer decimal_fraction
    (149) exponential_part -> . EREAL integer
    (174) simple_variable -> . variable_identifier
    (176) subscripted_variable -> . array_identifier LBBRACKET subscript_list RBBRACKET
    (44) procedure_identifier -> . IDENTIFIER
    (146) unsigned_integer -> . DIGIT
    (147) unsigned_integer -> . unsigned_integer DIGIT
    (148) decimal_fraction -> . DOT unsigned_integer
    (175) variable_identifier -> . IDENTIFIER
    (31) array_identifier -> . IDENTIFIER

    IF              shift and go to state 45
    PLUS            shift and go to state 102
    MINUS           shift and go to state 94
    LCBRACKET       shift and go to state 145
    EREAL           shift and go to state 115
    IDENTIFIER      shift and go to state 106
    DIGIT           shift and go to state 6
    DOT             shift and go to state 95

    subscripted_variable           shift and go to state 13
    primary                        shift and go to state 98
    if_clause                      shift and go to state 144
    unsigned_number                shift and go to state 105
    decimal_fraction               shift and go to state 103
    factor                         shift and go to state 104
    simple_arithmetic_expression   shift and go to state 147
    arithmetic_expression          shift and go to state 288
    decimal_number                 shift and go to state 112
    variable_identifier            shift and go to state 41
    function_designator            shift and go to state 149
    array_identifier               shift and go to state 14
    variable                       shift and go to state 150
    exponential_part               shift and go to state 92
    term                           shift and go to state 113
    upper_bound                    shift and go to state 289
    procedure_identifier           shift and go to state 125
    simple_variable                shift and go to state 49
    adding_operator                shift and go to state 117
    unsigned_integer               shift and go to state 120

state 273

    (29) array_segment -> array_identifier LBBRACKET bound_pair_list RBBRACKET .

    COMMA           reduce using rule 29 (array_segment -> array_identifier LBBRACKET bound_pair_list RBBRACKET .)
    SEMICOLON       reduce using rule 29 (array_segment -> array_identifier LBBRACKET bound_pair_list RBBRACKET .)


state 274

    (33) bound_pair_list -> bound_pair_list COMMA . bound_pair
    (34) bound_pair -> . lower_bound COLON upper_bound
    (36) lower_bound -> . arithmetic_expression
    (121) arithmetic_expression -> . simple_arithmetic_expression
    (122) arithmetic_expression -> . if_clause simple_arithmetic_expression ELSE arithmetic_expression
    (123) simple_arithmetic_expression -> . term
    (124) simple_arithmetic_expression -> . adding_operator term
    (125) simple_arithmetic_expression -> . simple_arithmetic_expression adding_operator term
    (109) if_clause -> . IF boolean_expression THEN
    (128) term -> . factor
    (129) term -> . term multiplying_operator factor
    (126) adding_operator -> . PLUS
    (127) adding_operator -> . MINUS
    (133) factor -> . primary
    (134) factor -> . factor
    (135) factor -> . factor POWER primary
    (136) primary -> . unsigned_number
    (137) primary -> . variable
    (138) primary -> . function_designator
    (139) primary -> . LCBRACKET arithmetic_expression RCBRACKET
    (140) unsigned_number -> . decimal_number
    (141) unsigned_number -> . exponential_part
    (142) unsigned_number -> . decimal_number exponential_part
    (172) variable -> . simple_variable
    (173) variable -> . subscripted_variable
    (171) function_designator -> . procedure_identifier actual_parameter_part
    (143) decimal_number -> . unsigned_integer
    (144) decimal_number -> . decimal_fraction
    (145) decimal_number -> . unsigned_integer decimal_fraction
    (149) exponential_part -> . EREAL integer
    (174) simple_variable -> . variable_identifier
    (176) subscripted_variable -> . array_identifier LBBRACKET subscript_list RBBRACKET
    (44) procedure_identifier -> . IDENTIFIER
    (146) unsigned_integer -> . DIGIT
    (147) unsigned_integer -> . unsigned_integer DIGIT
    (148) decimal_fraction -> . DOT unsigned_integer
    (175) variable_identifier -> . IDENTIFIER
    (31) array_identifier -> . IDENTIFIER

    IF              shift and go to state 45
    PLUS            shift and go to state 102
    MINUS           shift and go to state 94
    LCBRACKET       shift and go to state 145
    EREAL           shift and go to state 115
    IDENTIFIER      shift and go to state 106
    DIGIT           shift and go to state 6
    DOT             shift and go to state 95

    subscripted_variable           shift and go to state 13
    primary                        shift and go to state 98
    if_clause                      shift and go to state 144
    unsigned_number                shift and go to state 105
    decimal_fraction               shift and go to state 103
    factor                         shift and go to state 104
    simple_arithmetic_expression   shift and go to state 147
    arithmetic_expression          shift and go to state 237
    lower_bound                    shift and go to state 238
    decimal_number                 shift and go to state 112
    variable_identifier            shift and go to state 41
    function_designator            shift and go to state 149
    array_identifier               shift and go to state 14
    variable                       shift and go to state 150
    exponential_part               shift and go to state 92
    term                           shift and go to state 113
    procedure_identifier           shift and go to state 125
    simple_variable                shift and go to state 49
    bound_pair                     shift and go to state 290
    adding_operator                shift and go to state 117
    unsigned_integer               shift and go to state 120

state 275

    (112) for_clause -> FOR variable ASSIGNMENT for_list DO .

    TLABEL          reduce using rule 112 (for_clause -> FOR variable ASSIGNMENT for_list DO .)
    IF              reduce using rule 112 (for_clause -> FOR variable ASSIGNMENT for_list DO .)
    IDENTIFIER      reduce using rule 112 (for_clause -> FOR variable ASSIGNMENT for_list DO .)
    FOR             reduce using rule 112 (for_clause -> FOR variable ASSIGNMENT for_list DO .)
    BEGIN           reduce using rule 112 (for_clause -> FOR variable ASSIGNMENT for_list DO .)
    DIGIT           reduce using rule 112 (for_clause -> FOR variable ASSIGNMENT for_list DO .)
    GOTO            reduce using rule 112 (for_clause -> FOR variable ASSIGNMENT for_list DO .)


state 276

    (114) for_list -> for_list COMMA . for_list_element
    (115) for_list_element -> . arithmetic_expression
    (116) for_list_element -> . arithmetic_expression STEP arithmetic_expression UNTIL arithmetic_expression
    (117) for_list_element -> . arithmetic_expression WHILE boolean_expression
    (121) arithmetic_expression -> . simple_arithmetic_expression
    (122) arithmetic_expression -> . if_clause simple_arithmetic_expression ELSE arithmetic_expression
    (123) simple_arithmetic_expression -> . term
    (124) simple_arithmetic_expression -> . adding_operator term
    (125) simple_arithmetic_expression -> . simple_arithmetic_expression adding_operator term
    (109) if_clause -> . IF boolean_expression THEN
    (128) term -> . factor
    (129) term -> . term multiplying_operator factor
    (126) adding_operator -> . PLUS
    (127) adding_operator -> . MINUS
    (133) factor -> . primary
    (134) factor -> . factor
    (135) factor -> . factor POWER primary
    (136) primary -> . unsigned_number
    (137) primary -> . variable
    (138) primary -> . function_designator
    (139) primary -> . LCBRACKET arithmetic_expression RCBRACKET
    (140) unsigned_number -> . decimal_number
    (141) unsigned_number -> . exponential_part
    (142) unsigned_number -> . decimal_number exponential_part
    (172) variable -> . simple_variable
    (173) variable -> . subscripted_variable
    (171) function_designator -> . procedure_identifier actual_parameter_part
    (143) decimal_number -> . unsigned_integer
    (144) decimal_number -> . decimal_fraction
    (145) decimal_number -> . unsigned_integer decimal_fraction
    (149) exponential_part -> . EREAL integer
    (174) simple_variable -> . variable_identifier
    (176) subscripted_variable -> . array_identifier LBBRACKET subscript_list RBBRACKET
    (44) procedure_identifier -> . IDENTIFIER
    (146) unsigned_integer -> . DIGIT
    (147) unsigned_integer -> . unsigned_integer DIGIT
    (148) decimal_fraction -> . DOT unsigned_integer
    (175) variable_identifier -> . IDENTIFIER
    (31) array_identifier -> . IDENTIFIER

    IF              shift and go to state 45
    PLUS            shift and go to state 102
    MINUS           shift and go to state 94
    LCBRACKET       shift and go to state 145
    EREAL           shift and go to state 115
    IDENTIFIER      shift and go to state 106
    DIGIT           shift and go to state 6
    DOT             shift and go to state 95

    subscripted_variable           shift and go to state 13
    for_list_element               shift and go to state 291
    if_clause                      shift and go to state 144
    unsigned_number                shift and go to state 105
    decimal_fraction               shift and go to state 103
    factor                         shift and go to state 104
    simple_arithmetic_expression   shift and go to state 147
    arithmetic_expression          shift and go to state 245
    decimal_number                 shift and go to state 112
    primary                        shift and go to state 98
    variable_identifier            shift and go to state 41
    function_designator            shift and go to state 149
    array_identifier               shift and go to state 14
    variable                       shift and go to state 150
    exponential_part               shift and go to state 92
    term                           shift and go to state 113
    procedure_identifier           shift and go to state 125
    simple_variable                shift and go to state 49
    adding_operator                shift and go to state 117
    unsigned_integer               shift and go to state 120

state 277

    (116) for_list_element -> arithmetic_expression STEP . arithmetic_expression UNTIL arithmetic_expression
    (121) arithmetic_expression -> . simple_arithmetic_expression
    (122) arithmetic_expression -> . if_clause simple_arithmetic_expression ELSE arithmetic_expression
    (123) simple_arithmetic_expression -> . term
    (124) simple_arithmetic_expression -> . adding_operator term
    (125) simple_arithmetic_expression -> . simple_arithmetic_expression adding_operator term
    (109) if_clause -> . IF boolean_expression THEN
    (128) term -> . factor
    (129) term -> . term multiplying_operator factor
    (126) adding_operator -> . PLUS
    (127) adding_operator -> . MINUS
    (133) factor -> . primary
    (134) factor -> . factor
    (135) factor -> . factor POWER primary
    (136) primary -> . unsigned_number
    (137) primary -> . variable
    (138) primary -> . function_designator
    (139) primary -> . LCBRACKET arithmetic_expression RCBRACKET
    (140) unsigned_number -> . decimal_number
    (141) unsigned_number -> . exponential_part
    (142) unsigned_number -> . decimal_number exponential_part
    (172) variable -> . simple_variable
    (173) variable -> . subscripted_variable
    (171) function_designator -> . procedure_identifier actual_parameter_part
    (143) decimal_number -> . unsigned_integer
    (144) decimal_number -> . decimal_fraction
    (145) decimal_number -> . unsigned_integer decimal_fraction
    (149) exponential_part -> . EREAL integer
    (174) simple_variable -> . variable_identifier
    (176) subscripted_variable -> . array_identifier LBBRACKET subscript_list RBBRACKET
    (44) procedure_identifier -> . IDENTIFIER
    (146) unsigned_integer -> . DIGIT
    (147) unsigned_integer -> . unsigned_integer DIGIT
    (148) decimal_fraction -> . DOT unsigned_integer
    (175) variable_identifier -> . IDENTIFIER
    (31) array_identifier -> . IDENTIFIER

    IF              shift and go to state 45
    PLUS            shift and go to state 102
    MINUS           shift and go to state 94
    LCBRACKET       shift and go to state 145
    EREAL           shift and go to state 115
    IDENTIFIER      shift and go to state 106
    DIGIT           shift and go to state 6
    DOT             shift and go to state 95

    subscripted_variable           shift and go to state 13
    primary                        shift and go to state 98
    if_clause                      shift and go to state 144
    unsigned_number                shift and go to state 105
    decimal_fraction               shift and go to state 103
    factor                         shift and go to state 104
    simple_arithmetic_expression   shift and go to state 147
    arithmetic_expression          shift and go to state 292
    decimal_number                 shift and go to state 112
    variable_identifier            shift and go to state 41
    function_designator            shift and go to state 149
    array_identifier               shift and go to state 14
    variable                       shift and go to state 150
    exponential_part               shift and go to state 92
    term                           shift and go to state 113
    procedure_identifier           shift and go to state 125
    simple_variable                shift and go to state 49
    adding_operator                shift and go to state 117
    unsigned_integer               shift and go to state 120

state 278

    (117) for_list_element -> arithmetic_expression WHILE . boolean_expression
    (153) boolean_expression -> . simple_boolean
    (154) boolean_expression -> . if_clause simple_boolean ELSE boolean_expression
    (155) simple_boolean -> . implication
    (156) simple_boolean -> . simple_boolean EQUIV implication
    (109) if_clause -> . IF boolean_expression THEN
    (157) implication -> . boolean_term
    (158) implication -> . implication IMPL boolean_term
    (159) boolean_term -> . boolean_factor
    (160) boolean_term -> . boolean_term OR boolean_factor
    (161) boolean_factor -> . boolean_secondary
    (162) boolean_factor -> . boolean_factor AND boolean_secondary
    (163) boolean_secondary -> . boolean_primary
    (164) boolean_secondary -> . NOT boolean_primary
    (165) boolean_primary -> . logical_value
    (166) boolean_primary -> . variable
    (167) boolean_primary -> . function_designator
    (168) boolean_primary -> . relation
    (169) boolean_primary -> . LCBRACKET boolean_expression RCBRACKET
    (183) logical_value -> . TRUE
    (184) logical_value -> . FALSE
    (172) variable -> . simple_variable
    (173) variable -> . subscripted_variable
    (171) function_designator -> . procedure_identifier actual_parameter_part
    (170) relation -> . simple_arithmetic_expression relational_operator simple_arithmetic_expression
    (174) simple_variable -> . variable_identifier
    (176) subscripted_variable -> . array_identifier LBBRACKET subscript_list RBBRACKET
    (44) procedure_identifier -> . IDENTIFIER
    (123) simple_arithmetic_expression -> . term
    (124) simple_arithmetic_expression -> . adding_operator term
    (125) simple_arithmetic_expression -> . simple_arithmetic_expression adding_operator term
    (175) variable_identifier -> . IDENTIFIER
    (31) array_identifier -> . IDENTIFIER
    (128) term -> . factor
    (129) term -> . term multiplying_operator factor
    (126) adding_operator -> . PLUS
    (127) adding_operator -> . MINUS
    (133) factor -> . primary
    (134) factor -> . factor
    (135) factor -> . factor POWER primary
    (136) primary -> . unsigned_number
    (137) primary -> . variable
    (138) primary -> . function_designator
    (139) primary -> . LCBRACKET arithmetic_expression RCBRACKET
    (140) unsigned_number -> . decimal_number
    (141) unsigned_number -> . exponential_part
    (142) unsigned_number -> . decimal_number exponential_part
    (143) decimal_number -> . unsigned_integer
    (144) decimal_number -> . decimal_fraction
    (145) decimal_number -> . unsigned_integer decimal_fraction
    (149) exponential_part -> . EREAL integer
    (146) unsigned_integer -> . DIGIT
    (147) unsigned_integer -> . unsigned_integer DIGIT
    (148) decimal_fraction -> . DOT unsigned_integer

    IF              shift and go to state 45
    NOT             shift and go to state 118
    LCBRACKET       shift and go to state 127
    TRUE            shift and go to state 93
    FALSE           shift and go to state 100
    IDENTIFIER      shift and go to state 106
    PLUS            shift and go to state 102
    MINUS           shift and go to state 94
    EREAL           shift and go to state 115
    DIGIT           shift and go to state 6
    DOT             shift and go to state 95

    boolean_primary                shift and go to state 99
    subscripted_variable           shift and go to state 13
    boolean_term                   shift and go to state 88
    if_clause                      shift and go to state 126
    boolean_factor                 shift and go to state 90
    relation                       shift and go to state 91
    simple_boolean                 shift and go to state 97
    boolean_secondary              shift and go to state 101
    unsigned_number                shift and go to state 105
    decimal_fraction               shift and go to state 103
    factor                         shift and go to state 104
    simple_arithmetic_expression   shift and go to state 131
    logical_value                  shift and go to state 109
    decimal_number                 shift and go to state 112
    primary                        shift and go to state 98
    variable_identifier            shift and go to state 41
    function_designator            shift and go to state 128
    array_identifier               shift and go to state 14
    variable                       shift and go to state 129
    exponential_part               shift and go to state 92
    term                           shift and go to state 113
    boolean_expression             shift and go to state 293
    procedure_identifier           shift and go to state 125
    simple_variable                shift and go to state 49
    adding_operator                shift and go to state 117
    implication                    shift and go to state 119
    unsigned_integer               shift and go to state 120

state 279

    (122) arithmetic_expression -> if_clause simple_arithmetic_expression ELSE arithmetic_expression .

    UNTIL           reduce using rule 122 (arithmetic_expression -> if_clause simple_arithmetic_expression ELSE arithmetic_expression .)
    COLON           reduce using rule 122 (arithmetic_expression -> if_clause simple_arithmetic_expression ELSE arithmetic_expression .)
    RBBRACKET       reduce using rule 122 (arithmetic_expression -> if_clause simple_arithmetic_expression ELSE arithmetic_expression .)
    COMMA           reduce using rule 122 (arithmetic_expression -> if_clause simple_arithmetic_expression ELSE arithmetic_expression .)
    RCBRACKET       reduce using rule 122 (arithmetic_expression -> if_clause simple_arithmetic_expression ELSE arithmetic_expression .)
    END             reduce using rule 122 (arithmetic_expression -> if_clause simple_arithmetic_expression ELSE arithmetic_expression .)
    SEMICOLON       reduce using rule 122 (arithmetic_expression -> if_clause simple_arithmetic_expression ELSE arithmetic_expression .)
    ELSE            reduce using rule 122 (arithmetic_expression -> if_clause simple_arithmetic_expression ELSE arithmetic_expression .)
    DO              reduce using rule 122 (arithmetic_expression -> if_clause simple_arithmetic_expression ELSE arithmetic_expression .)
    STEP            reduce using rule 122 (arithmetic_expression -> if_clause simple_arithmetic_expression ELSE arithmetic_expression .)
    WHILE           reduce using rule 122 (arithmetic_expression -> if_clause simple_arithmetic_expression ELSE arithmetic_expression .)


state 280

    (154) boolean_expression -> if_clause simple_boolean ELSE boolean_expression .

    END             reduce using rule 154 (boolean_expression -> if_clause simple_boolean ELSE boolean_expression .)
    SEMICOLON       reduce using rule 154 (boolean_expression -> if_clause simple_boolean ELSE boolean_expression .)
    ELSE            reduce using rule 154 (boolean_expression -> if_clause simple_boolean ELSE boolean_expression .)
    THEN            reduce using rule 154 (boolean_expression -> if_clause simple_boolean ELSE boolean_expression .)
    RCBRACKET       reduce using rule 154 (boolean_expression -> if_clause simple_boolean ELSE boolean_expression .)
    COMMA           reduce using rule 154 (boolean_expression -> if_clause simple_boolean ELSE boolean_expression .)
    DO              reduce using rule 154 (boolean_expression -> if_clause simple_boolean ELSE boolean_expression .)


state 281

    (51) value_part -> TVALUE . identifier_list SEMICOLON
    (63) identifier_list -> . IDENTIFIER
    (64) identifier_list -> . identifier_list COMMA IDENTIFIER

    IDENTIFIER      shift and go to state 294

    identifier_list                shift and go to state 295

state 282

    (43) procedure_heading -> procedure_identifier formal_parameter_part SEMICOLON value_part . specification_part
    (52) specification_part -> .
    (53) specification_part -> . specifier identifier_list SEMICOLON
    (54) specification_part -> . specification_part specifier identifier_list
    (55) specifier -> . TSTRING
    (56) specifier -> . type
    (57) specifier -> . TARRAY
    (58) specifier -> . type TARRAY
    (59) specifier -> . TLABEL
    (60) specifier -> . SWITCH
    (61) specifier -> . PROCEDURE
    (62) specifier -> . type PROCEDURE
    (20) type -> . TREAL
    (21) type -> . TINTEGER
    (22) type -> . TBOOLEAN

  ! shift/reduce conflict for TSTRING resolved as shift
  ! shift/reduce conflict for TARRAY resolved as shift
  ! shift/reduce conflict for TLABEL resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for PROCEDURE resolved as shift
  ! shift/reduce conflict for TREAL resolved as shift
  ! shift/reduce conflict for TINTEGER resolved as shift
  ! shift/reduce conflict for TBOOLEAN resolved as shift
    IF              reduce using rule 52 (specification_part -> .)
    IDENTIFIER      reduce using rule 52 (specification_part -> .)
    FOR             reduce using rule 52 (specification_part -> .)
    BEGIN           reduce using rule 52 (specification_part -> .)
    DIGIT           reduce using rule 52 (specification_part -> .)
    GOTO            reduce using rule 52 (specification_part -> .)
    TSTRING         shift and go to state 299
    TARRAY          shift and go to state 301
    TLABEL          shift and go to state 297
    SWITCH          shift and go to state 298
    PROCEDURE       shift and go to state 302
    TREAL           shift and go to state 15
    TINTEGER        shift and go to state 18
    TBOOLEAN        shift and go to state 26

  ! TSTRING         [ reduce using rule 52 (specification_part -> .) ]
  ! TARRAY          [ reduce using rule 52 (specification_part -> .) ]
  ! TLABEL          [ reduce using rule 52 (specification_part -> .) ]
  ! SWITCH          [ reduce using rule 52 (specification_part -> .) ]
  ! PROCEDURE       [ reduce using rule 52 (specification_part -> .) ]
  ! TREAL           [ reduce using rule 52 (specification_part -> .) ]
  ! TINTEGER        [ reduce using rule 52 (specification_part -> .) ]
  ! TBOOLEAN        [ reduce using rule 52 (specification_part -> .) ]

    specifier                      shift and go to state 296
    type                           shift and go to state 300
    specification_part             shift and go to state 303

state 283

    (46) formal_parameter_part -> LCBRACKET formal_parameter_list RCBRACKET .
    (98) parameter_delimiter -> RCBRACKET . letter_string COLON LCBRACKET
    (181) letter_string -> . LETTER
    (182) letter_string -> . letter_string LETTER

    SEMICOLON       reduce using rule 46 (formal_parameter_part -> LCBRACKET formal_parameter_list RCBRACKET .)
    LETTER          shift and go to state 269

    letter_string                  shift and go to state 268

state 284

    (48) formal_parameter_list -> formal_parameter_list parameter_delimiter . formal_parameter
    (49) formal_parameter -> . IDENTIFIER

    IDENTIFIER      shift and go to state 263

    formal_parameter               shift and go to state 304

state 285

    (98) parameter_delimiter -> RCBRACKET letter_string COLON . LCBRACKET

    LCBRACKET       shift and go to state 305


state 286

    (182) letter_string -> letter_string LETTER .

    COLON           reduce using rule 182 (letter_string -> letter_string LETTER .)
    LETTER          reduce using rule 182 (letter_string -> letter_string LETTER .)


state 287

    (40) switch_list -> switch_list COMMA designational_expression .

    COMMA           reduce using rule 40 (switch_list -> switch_list COMMA designational_expression .)
    SEMICOLON       reduce using rule 40 (switch_list -> switch_list COMMA designational_expression .)


state 288

    (35) upper_bound -> arithmetic_expression .

    RBBRACKET       reduce using rule 35 (upper_bound -> arithmetic_expression .)
    COMMA           reduce using rule 35 (upper_bound -> arithmetic_expression .)


state 289

    (34) bound_pair -> lower_bound COLON upper_bound .

    RBBRACKET       reduce using rule 34 (bound_pair -> lower_bound COLON upper_bound .)
    COMMA           reduce using rule 34 (bound_pair -> lower_bound COLON upper_bound .)


state 290

    (33) bound_pair_list -> bound_pair_list COMMA bound_pair .

    RBBRACKET       reduce using rule 33 (bound_pair_list -> bound_pair_list COMMA bound_pair .)
    COMMA           reduce using rule 33 (bound_pair_list -> bound_pair_list COMMA bound_pair .)


state 291

    (114) for_list -> for_list COMMA for_list_element .

    DO              reduce using rule 114 (for_list -> for_list COMMA for_list_element .)
    COMMA           reduce using rule 114 (for_list -> for_list COMMA for_list_element .)


state 292

    (116) for_list_element -> arithmetic_expression STEP arithmetic_expression . UNTIL arithmetic_expression

    UNTIL           shift and go to state 306


state 293

    (117) for_list_element -> arithmetic_expression WHILE boolean_expression .

    DO              reduce using rule 117 (for_list_element -> arithmetic_expression WHILE boolean_expression .)
    COMMA           reduce using rule 117 (for_list_element -> arithmetic_expression WHILE boolean_expression .)


state 294

    (63) identifier_list -> IDENTIFIER .

    COMMA           reduce using rule 63 (identifier_list -> IDENTIFIER .)
    TSTRING         reduce using rule 63 (identifier_list -> IDENTIFIER .)
    TARRAY          reduce using rule 63 (identifier_list -> IDENTIFIER .)
    TLABEL          reduce using rule 63 (identifier_list -> IDENTIFIER .)
    SWITCH          reduce using rule 63 (identifier_list -> IDENTIFIER .)
    PROCEDURE       reduce using rule 63 (identifier_list -> IDENTIFIER .)
    TREAL           reduce using rule 63 (identifier_list -> IDENTIFIER .)
    TINTEGER        reduce using rule 63 (identifier_list -> IDENTIFIER .)
    TBOOLEAN        reduce using rule 63 (identifier_list -> IDENTIFIER .)
    IF              reduce using rule 63 (identifier_list -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 63 (identifier_list -> IDENTIFIER .)
    FOR             reduce using rule 63 (identifier_list -> IDENTIFIER .)
    BEGIN           reduce using rule 63 (identifier_list -> IDENTIFIER .)
    DIGIT           reduce using rule 63 (identifier_list -> IDENTIFIER .)
    GOTO            reduce using rule 63 (identifier_list -> IDENTIFIER .)
    SEMICOLON       reduce using rule 63 (identifier_list -> IDENTIFIER .)


state 295

    (51) value_part -> TVALUE identifier_list . SEMICOLON
    (64) identifier_list -> identifier_list . COMMA IDENTIFIER

    SEMICOLON       shift and go to state 308
    COMMA           shift and go to state 307


state 296

    (53) specification_part -> specifier . identifier_list SEMICOLON
    (63) identifier_list -> . IDENTIFIER
    (64) identifier_list -> . identifier_list COMMA IDENTIFIER

    IDENTIFIER      shift and go to state 294

    identifier_list                shift and go to state 309

state 297

    (59) specifier -> TLABEL .

    IDENTIFIER      reduce using rule 59 (specifier -> TLABEL .)


state 298

    (60) specifier -> SWITCH .

    IDENTIFIER      reduce using rule 60 (specifier -> SWITCH .)


state 299

    (55) specifier -> TSTRING .

    IDENTIFIER      reduce using rule 55 (specifier -> TSTRING .)


state 300

    (56) specifier -> type .
    (58) specifier -> type . TARRAY
    (62) specifier -> type . PROCEDURE

    IDENTIFIER      reduce using rule 56 (specifier -> type .)
    TARRAY          shift and go to state 310
    PROCEDURE       shift and go to state 311


state 301

    (57) specifier -> TARRAY .

    IDENTIFIER      reduce using rule 57 (specifier -> TARRAY .)


state 302

    (61) specifier -> PROCEDURE .

    IDENTIFIER      reduce using rule 61 (specifier -> PROCEDURE .)


state 303

    (43) procedure_heading -> procedure_identifier formal_parameter_part SEMICOLON value_part specification_part .
    (54) specification_part -> specification_part . specifier identifier_list
    (55) specifier -> . TSTRING
    (56) specifier -> . type
    (57) specifier -> . TARRAY
    (58) specifier -> . type TARRAY
    (59) specifier -> . TLABEL
    (60) specifier -> . SWITCH
    (61) specifier -> . PROCEDURE
    (62) specifier -> . type PROCEDURE
    (20) type -> . TREAL
    (21) type -> . TINTEGER
    (22) type -> . TBOOLEAN

  ! shift/reduce conflict for TLABEL resolved as shift
    IF              reduce using rule 43 (procedure_heading -> procedure_identifier formal_parameter_part SEMICOLON value_part specification_part .)
    IDENTIFIER      reduce using rule 43 (procedure_heading -> procedure_identifier formal_parameter_part SEMICOLON value_part specification_part .)
    FOR             reduce using rule 43 (procedure_heading -> procedure_identifier formal_parameter_part SEMICOLON value_part specification_part .)
    BEGIN           reduce using rule 43 (procedure_heading -> procedure_identifier formal_parameter_part SEMICOLON value_part specification_part .)
    DIGIT           reduce using rule 43 (procedure_heading -> procedure_identifier formal_parameter_part SEMICOLON value_part specification_part .)
    GOTO            reduce using rule 43 (procedure_heading -> procedure_identifier formal_parameter_part SEMICOLON value_part specification_part .)
    TSTRING         shift and go to state 299
    TARRAY          shift and go to state 301
    TLABEL          shift and go to state 297
    SWITCH          shift and go to state 298
    PROCEDURE       shift and go to state 302
    TREAL           shift and go to state 15
    TINTEGER        shift and go to state 18
    TBOOLEAN        shift and go to state 26

  ! TLABEL          [ reduce using rule 43 (procedure_heading -> procedure_identifier formal_parameter_part SEMICOLON value_part specification_part .) ]

    specifier                      shift and go to state 312
    type                           shift and go to state 300

state 304

    (48) formal_parameter_list -> formal_parameter_list parameter_delimiter formal_parameter .

    RCBRACKET       reduce using rule 48 (formal_parameter_list -> formal_parameter_list parameter_delimiter formal_parameter .)
    COMMA           reduce using rule 48 (formal_parameter_list -> formal_parameter_list parameter_delimiter formal_parameter .)


state 305

    (98) parameter_delimiter -> RCBRACKET letter_string COLON LCBRACKET .

    IDENTIFIER      reduce using rule 98 (parameter_delimiter -> RCBRACKET letter_string COLON LCBRACKET .)
    STRING          reduce using rule 98 (parameter_delimiter -> RCBRACKET letter_string COLON LCBRACKET .)
    IF              reduce using rule 98 (parameter_delimiter -> RCBRACKET letter_string COLON LCBRACKET .)
    LCBRACKET       reduce using rule 98 (parameter_delimiter -> RCBRACKET letter_string COLON LCBRACKET .)
    PLUS            reduce using rule 98 (parameter_delimiter -> RCBRACKET letter_string COLON LCBRACKET .)
    MINUS           reduce using rule 98 (parameter_delimiter -> RCBRACKET letter_string COLON LCBRACKET .)
    DIGIT           reduce using rule 98 (parameter_delimiter -> RCBRACKET letter_string COLON LCBRACKET .)
    NOT             reduce using rule 98 (parameter_delimiter -> RCBRACKET letter_string COLON LCBRACKET .)
    EREAL           reduce using rule 98 (parameter_delimiter -> RCBRACKET letter_string COLON LCBRACKET .)
    DOT             reduce using rule 98 (parameter_delimiter -> RCBRACKET letter_string COLON LCBRACKET .)
    TRUE            reduce using rule 98 (parameter_delimiter -> RCBRACKET letter_string COLON LCBRACKET .)
    FALSE           reduce using rule 98 (parameter_delimiter -> RCBRACKET letter_string COLON LCBRACKET .)


state 306

    (116) for_list_element -> arithmetic_expression STEP arithmetic_expression UNTIL . arithmetic_expression
    (121) arithmetic_expression -> . simple_arithmetic_expression
    (122) arithmetic_expression -> . if_clause simple_arithmetic_expression ELSE arithmetic_expression
    (123) simple_arithmetic_expression -> . term
    (124) simple_arithmetic_expression -> . adding_operator term
    (125) simple_arithmetic_expression -> . simple_arithmetic_expression adding_operator term
    (109) if_clause -> . IF boolean_expression THEN
    (128) term -> . factor
    (129) term -> . term multiplying_operator factor
    (126) adding_operator -> . PLUS
    (127) adding_operator -> . MINUS
    (133) factor -> . primary
    (134) factor -> . factor
    (135) factor -> . factor POWER primary
    (136) primary -> . unsigned_number
    (137) primary -> . variable
    (138) primary -> . function_designator
    (139) primary -> . LCBRACKET arithmetic_expression RCBRACKET
    (140) unsigned_number -> . decimal_number
    (141) unsigned_number -> . exponential_part
    (142) unsigned_number -> . decimal_number exponential_part
    (172) variable -> . simple_variable
    (173) variable -> . subscripted_variable
    (171) function_designator -> . procedure_identifier actual_parameter_part
    (143) decimal_number -> . unsigned_integer
    (144) decimal_number -> . decimal_fraction
    (145) decimal_number -> . unsigned_integer decimal_fraction
    (149) exponential_part -> . EREAL integer
    (174) simple_variable -> . variable_identifier
    (176) subscripted_variable -> . array_identifier LBBRACKET subscript_list RBBRACKET
    (44) procedure_identifier -> . IDENTIFIER
    (146) unsigned_integer -> . DIGIT
    (147) unsigned_integer -> . unsigned_integer DIGIT
    (148) decimal_fraction -> . DOT unsigned_integer
    (175) variable_identifier -> . IDENTIFIER
    (31) array_identifier -> . IDENTIFIER

    IF              shift and go to state 45
    PLUS            shift and go to state 102
    MINUS           shift and go to state 94
    LCBRACKET       shift and go to state 145
    EREAL           shift and go to state 115
    IDENTIFIER      shift and go to state 106
    DIGIT           shift and go to state 6
    DOT             shift and go to state 95

    subscripted_variable           shift and go to state 13
    primary                        shift and go to state 98
    if_clause                      shift and go to state 144
    unsigned_number                shift and go to state 105
    decimal_fraction               shift and go to state 103
    factor                         shift and go to state 104
    simple_arithmetic_expression   shift and go to state 147
    arithmetic_expression          shift and go to state 313
    decimal_number                 shift and go to state 112
    variable_identifier            shift and go to state 41
    function_designator            shift and go to state 149
    array_identifier               shift and go to state 14
    variable                       shift and go to state 150
    exponential_part               shift and go to state 92
    term                           shift and go to state 113
    procedure_identifier           shift and go to state 125
    simple_variable                shift and go to state 49
    adding_operator                shift and go to state 117
    unsigned_integer               shift and go to state 120

state 307

    (64) identifier_list -> identifier_list COMMA . IDENTIFIER

    IDENTIFIER      shift and go to state 314


state 308

    (51) value_part -> TVALUE identifier_list SEMICOLON .

    TSTRING         reduce using rule 51 (value_part -> TVALUE identifier_list SEMICOLON .)
    TARRAY          reduce using rule 51 (value_part -> TVALUE identifier_list SEMICOLON .)
    TLABEL          reduce using rule 51 (value_part -> TVALUE identifier_list SEMICOLON .)
    SWITCH          reduce using rule 51 (value_part -> TVALUE identifier_list SEMICOLON .)
    PROCEDURE       reduce using rule 51 (value_part -> TVALUE identifier_list SEMICOLON .)
    TREAL           reduce using rule 51 (value_part -> TVALUE identifier_list SEMICOLON .)
    TINTEGER        reduce using rule 51 (value_part -> TVALUE identifier_list SEMICOLON .)
    TBOOLEAN        reduce using rule 51 (value_part -> TVALUE identifier_list SEMICOLON .)
    IF              reduce using rule 51 (value_part -> TVALUE identifier_list SEMICOLON .)
    IDENTIFIER      reduce using rule 51 (value_part -> TVALUE identifier_list SEMICOLON .)
    FOR             reduce using rule 51 (value_part -> TVALUE identifier_list SEMICOLON .)
    BEGIN           reduce using rule 51 (value_part -> TVALUE identifier_list SEMICOLON .)
    DIGIT           reduce using rule 51 (value_part -> TVALUE identifier_list SEMICOLON .)
    GOTO            reduce using rule 51 (value_part -> TVALUE identifier_list SEMICOLON .)


state 309

    (53) specification_part -> specifier identifier_list . SEMICOLON
    (64) identifier_list -> identifier_list . COMMA IDENTIFIER

    SEMICOLON       shift and go to state 315
    COMMA           shift and go to state 307


state 310

    (58) specifier -> type TARRAY .

    IDENTIFIER      reduce using rule 58 (specifier -> type TARRAY .)


state 311

    (62) specifier -> type PROCEDURE .

    IDENTIFIER      reduce using rule 62 (specifier -> type PROCEDURE .)


state 312

    (54) specification_part -> specification_part specifier . identifier_list
    (63) identifier_list -> . IDENTIFIER
    (64) identifier_list -> . identifier_list COMMA IDENTIFIER

    IDENTIFIER      shift and go to state 294

    identifier_list                shift and go to state 316

state 313

    (116) for_list_element -> arithmetic_expression STEP arithmetic_expression UNTIL arithmetic_expression .

    DO              reduce using rule 116 (for_list_element -> arithmetic_expression STEP arithmetic_expression UNTIL arithmetic_expression .)
    COMMA           reduce using rule 116 (for_list_element -> arithmetic_expression STEP arithmetic_expression UNTIL arithmetic_expression .)


state 314

    (64) identifier_list -> identifier_list COMMA IDENTIFIER .

    COMMA           reduce using rule 64 (identifier_list -> identifier_list COMMA IDENTIFIER .)
    TSTRING         reduce using rule 64 (identifier_list -> identifier_list COMMA IDENTIFIER .)
    TARRAY          reduce using rule 64 (identifier_list -> identifier_list COMMA IDENTIFIER .)
    TLABEL          reduce using rule 64 (identifier_list -> identifier_list COMMA IDENTIFIER .)
    SWITCH          reduce using rule 64 (identifier_list -> identifier_list COMMA IDENTIFIER .)
    PROCEDURE       reduce using rule 64 (identifier_list -> identifier_list COMMA IDENTIFIER .)
    TREAL           reduce using rule 64 (identifier_list -> identifier_list COMMA IDENTIFIER .)
    TINTEGER        reduce using rule 64 (identifier_list -> identifier_list COMMA IDENTIFIER .)
    TBOOLEAN        reduce using rule 64 (identifier_list -> identifier_list COMMA IDENTIFIER .)
    IF              reduce using rule 64 (identifier_list -> identifier_list COMMA IDENTIFIER .)
    IDENTIFIER      reduce using rule 64 (identifier_list -> identifier_list COMMA IDENTIFIER .)
    FOR             reduce using rule 64 (identifier_list -> identifier_list COMMA IDENTIFIER .)
    BEGIN           reduce using rule 64 (identifier_list -> identifier_list COMMA IDENTIFIER .)
    DIGIT           reduce using rule 64 (identifier_list -> identifier_list COMMA IDENTIFIER .)
    GOTO            reduce using rule 64 (identifier_list -> identifier_list COMMA IDENTIFIER .)
    SEMICOLON       reduce using rule 64 (identifier_list -> identifier_list COMMA IDENTIFIER .)


state 315

    (53) specification_part -> specifier identifier_list SEMICOLON .

    TSTRING         reduce using rule 53 (specification_part -> specifier identifier_list SEMICOLON .)
    TARRAY          reduce using rule 53 (specification_part -> specifier identifier_list SEMICOLON .)
    TLABEL          reduce using rule 53 (specification_part -> specifier identifier_list SEMICOLON .)
    SWITCH          reduce using rule 53 (specification_part -> specifier identifier_list SEMICOLON .)
    PROCEDURE       reduce using rule 53 (specification_part -> specifier identifier_list SEMICOLON .)
    TREAL           reduce using rule 53 (specification_part -> specifier identifier_list SEMICOLON .)
    TINTEGER        reduce using rule 53 (specification_part -> specifier identifier_list SEMICOLON .)
    TBOOLEAN        reduce using rule 53 (specification_part -> specifier identifier_list SEMICOLON .)
    IF              reduce using rule 53 (specification_part -> specifier identifier_list SEMICOLON .)
    IDENTIFIER      reduce using rule 53 (specification_part -> specifier identifier_list SEMICOLON .)
    FOR             reduce using rule 53 (specification_part -> specifier identifier_list SEMICOLON .)
    BEGIN           reduce using rule 53 (specification_part -> specifier identifier_list SEMICOLON .)
    DIGIT           reduce using rule 53 (specification_part -> specifier identifier_list SEMICOLON .)
    GOTO            reduce using rule 53 (specification_part -> specifier identifier_list SEMICOLON .)


state 316

    (54) specification_part -> specification_part specifier identifier_list .
    (64) identifier_list -> identifier_list . COMMA IDENTIFIER

    TSTRING         reduce using rule 54 (specification_part -> specification_part specifier identifier_list .)
    TARRAY          reduce using rule 54 (specification_part -> specification_part specifier identifier_list .)
    TLABEL          reduce using rule 54 (specification_part -> specification_part specifier identifier_list .)
    SWITCH          reduce using rule 54 (specification_part -> specification_part specifier identifier_list .)
    PROCEDURE       reduce using rule 54 (specification_part -> specification_part specifier identifier_list .)
    TREAL           reduce using rule 54 (specification_part -> specification_part specifier identifier_list .)
    TINTEGER        reduce using rule 54 (specification_part -> specification_part specifier identifier_list .)
    TBOOLEAN        reduce using rule 54 (specification_part -> specification_part specifier identifier_list .)
    IF              reduce using rule 54 (specification_part -> specification_part specifier identifier_list .)
    IDENTIFIER      reduce using rule 54 (specification_part -> specification_part specifier identifier_list .)
    FOR             reduce using rule 54 (specification_part -> specification_part specifier identifier_list .)
    BEGIN           reduce using rule 54 (specification_part -> specification_part specifier identifier_list .)
    DIGIT           reduce using rule 54 (specification_part -> specification_part specifier identifier_list .)
    GOTO            reduce using rule 54 (specification_part -> specification_part specifier identifier_list .)
    COMMA           shift and go to state 307

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for POWER in state 104 resolved as shift
WARNING: shift/reduce conflict for POWER in state 254 resolved as shift
WARNING: shift/reduce conflict for TSTRING in state 282 resolved as shift
WARNING: shift/reduce conflict for TARRAY in state 282 resolved as shift
WARNING: shift/reduce conflict for TLABEL in state 282 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 282 resolved as shift
WARNING: shift/reduce conflict for PROCEDURE in state 282 resolved as shift
WARNING: shift/reduce conflict for TREAL in state 282 resolved as shift
WARNING: shift/reduce conflict for TINTEGER in state 282 resolved as shift
WARNING: shift/reduce conflict for TBOOLEAN in state 282 resolved as shift
WARNING: shift/reduce conflict for TLABEL in state 303 resolved as shift
WARNING: reduce/reduce conflict in state 47 resolved using rule (procedure_identifier -> IDENTIFIER)
WARNING: rejected rule (variable_identifier -> IDENTIFIER) in state 47
WARNING: reduce/reduce conflict in state 104 resolved using rule (term -> factor)
WARNING: rejected rule (factor -> factor) in state 104
WARNING: reduce/reduce conflict in state 106 resolved using rule (procedure_identifier -> IDENTIFIER)
WARNING: rejected rule (variable_identifier -> IDENTIFIER) in state 106
WARNING: reduce/reduce conflict in state 110 resolved using rule (primary -> function_designator)
WARNING: rejected rule (boolean_primary -> function_designator) in state 110
WARNING: reduce/reduce conflict in state 111 resolved using rule (primary -> variable)
WARNING: rejected rule (boolean_primary -> variable) in state 111
WARNING: reduce/reduce conflict in state 161 resolved using rule (primary -> variable)
WARNING: rejected rule (boolean_primary -> variable) in state 161
WARNING: reduce/reduce conflict in state 166 resolved using rule (array_identifier -> IDENTIFIER)
WARNING: rejected rule (switch_identifier -> IDENTIFIER) in state 166
WARNING: reduce/reduce conflict in state 166 resolved using rule (array_identifier -> IDENTIFIER)
WARNING: rejected rule (procedure_identifier -> IDENTIFIER) in state 166
WARNING: reduce/reduce conflict in state 166 resolved using rule (array_identifier -> IDENTIFIER)
WARNING: rejected rule (label -> IDENTIFIER) in state 166
WARNING: reduce/reduce conflict in state 166 resolved using rule (array_identifier -> IDENTIFIER)
WARNING: rejected rule (variable_identifier -> IDENTIFIER) in state 166
WARNING: reduce/reduce conflict in state 175 resolved using rule (label -> unsigned_integer)
WARNING: rejected rule (decimal_number -> unsigned_integer) in state 175
WARNING: reduce/reduce conflict in state 232 resolved using rule (label -> IDENTIFIER)
WARNING: rejected rule (variable_identifier -> IDENTIFIER) in state 232
WARNING: reduce/reduce conflict in state 232 resolved using rule (array_identifier -> IDENTIFIER)
WARNING: rejected rule (switch_identifier -> IDENTIFIER) in state 232
WARNING: reduce/reduce conflict in state 254 resolved using rule (term -> term multiplying_operator factor)
WARNING: rejected rule (factor -> factor) in state 254
WARNING: Rule (factor -> factor) is never reduced
