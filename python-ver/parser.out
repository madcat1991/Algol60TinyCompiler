Created by PLY version 3.4 (http://www.dabeaz.com/ply)

Unused terminals:

    COMMENT

Grammar

Rule 0     S' -> program
Rule 1     program -> block
Rule 2     program -> compound_statement
Rule 3     block -> unlabelled_block
Rule 4     block -> TLABEL COLON block
Rule 5     unlabelled_block -> block_head SEMICOLON compound_tail
Rule 6     block_head -> BEGIN declaration
Rule 7     block_head -> block_head SEMICOLON declaration
Rule 8     compound_statement -> unlabelled_compound
Rule 9     compound_statement -> label COLON compound_statement
Rule 10    unlabelled_compound -> BEGIN compound_tail
Rule 11    compound_tail -> statement END
Rule 12    compound_tail -> statement SEMICOLON compound_tail
Rule 13    declaration -> type_declaration
Rule 14    declaration -> array_declaration
Rule 15    declaration -> switch_declaration
Rule 16    declaration -> procedure_declaration
Rule 17    type_declaration -> local_or_own_type type_list
Rule 18    local_or_own_type -> type
Rule 19    local_or_own_type -> TOWN type
Rule 20    type -> TREAL
Rule 21    type -> TINTEGER
Rule 22    type -> TBOOLEAN
Rule 23    type_list -> simple_variable
Rule 24    type_list -> simple_variable COMMA type_list
Rule 25    array_declaration -> TARRAY array_list
Rule 26    array_declaration -> local_or_own_type TARRAY array_list
Rule 27    array_list -> array_segment
Rule 28    array_list -> array_list COMMA array_segment
Rule 29    array_segment -> array_identifier LBBRACKET bound_pair_list RBBRACKET
Rule 30    array_segment -> array_identifier COMMA array_segment
Rule 31    array_identifier -> IDENTIFIER
Rule 32    bound_pair_list -> bound_pair
Rule 33    bound_pair_list -> bound_pair_list COMMA bound_pair
Rule 34    bound_pair -> lower_bound COLON upper_bound
Rule 35    upper_bound -> arithmetic_expression
Rule 36    lower_bound -> arithmetic_expression
Rule 37    switch_declaration -> SWITCH switch_identifier ASSIGNMENT switch_list
Rule 38    switch_identifier -> IDENTIFIER
Rule 39    switch_list -> designational_expression
Rule 40    switch_list -> switch_list COMMA designational_expression
Rule 41    procedure_declaration -> PROCEDURE procedure_heading procedure_body
Rule 42    procedure_declaration -> type PROCEDURE procedure_heading procedure_body
Rule 43    procedure_heading -> procedure_identifier formal_parameter_part SEMICOLON value_part specification_part
Rule 44    procedure_identifier -> IDENTIFIER
Rule 45    formal_parameter_part -> <empty>
Rule 46    formal_parameter_part -> LCBRACKET formal_parameter_list RCBRACKET
Rule 47    formal_parameter_list -> formal_parameter
Rule 48    formal_parameter_list -> formal_parameter_list parameter_delimiter formal_parameter
Rule 49    formal_parameter -> IDENTIFIER
Rule 50    value_part -> <empty>
Rule 51    value_part -> TVALUE identifier_list SEMICOLON
Rule 52    specification_part -> <empty>
Rule 53    specification_part -> specifier identifier_list SEMICOLON
Rule 54    specification_part -> specification_part specifier identifier_list
Rule 55    specifier -> TSTRING
Rule 56    specifier -> type
Rule 57    specifier -> TARRAY
Rule 58    specifier -> type TARRAY
Rule 59    specifier -> TLABEL
Rule 60    specifier -> SWITCH
Rule 61    specifier -> PROCEDURE
Rule 62    specifier -> type PROCEDURE
Rule 63    identifier_list -> IDENTIFIER
Rule 64    identifier_list -> identifier_list COMMA IDENTIFIER
Rule 65    procedure_body -> statement
Rule 66    statement -> unconditional_statement
Rule 67    statement -> conditional_statement
Rule 68    statement -> for_statement
Rule 69    unconditional_statement -> basic_statement
Rule 70    unconditional_statement -> compound_statement
Rule 71    unconditional_statement -> block
Rule 72    basic_statement -> unlabelled_basic_statement
Rule 73    basic_statement -> label COLON basic_statement
Rule 74    label -> IDENTIFIER
Rule 75    label -> unsigned_integer
Rule 76    unlabelled_basic_statement -> <empty>
Rule 77    unlabelled_basic_statement -> assignment_statement
Rule 78    unlabelled_basic_statement -> go_to_statement
Rule 79    unlabelled_basic_statement -> procedure_statement
Rule 80    assignment_statement -> left_part_list arithmetic_expression
Rule 81    assignment_statement -> left_part_list boolean_expression
Rule 82    left_part_list -> left_part
Rule 83    left_part_list -> left_part_list left_part
Rule 84    left_part -> variable ASSIGNMENT
Rule 85    left_part -> procedure_identifier ASSIGNMENT
Rule 86    go_to_statement -> GOTO designational_expression
Rule 87    designational_expression -> simple_designational_expression
Rule 88    designational_expression -> if_clause simple_designational_expression ELSE designational_expression
Rule 89    simple_designational_expression -> label
Rule 90    simple_designational_expression -> switch_designator
Rule 91    simple_designational_expression -> LCBRACKET designational_expression RCBRACKET
Rule 92    switch_designator -> switch_identifier LBBRACKET subscript_expression RBBRACKET
Rule 93    procedure_statement -> procedure_identifier actual_parameter_part
Rule 94    actual_parameter_part -> <empty>
Rule 95    actual_parameter_part -> LCBRACKET actual_parameter_list RCBRACKET
Rule 96    actual_parameter_list -> actual_parameter
Rule 97    actual_parameter_list -> actual_parameter_list parameter_delimiter actual_parameter
Rule 98    parameter_delimiter -> COMMA
Rule 99    parameter_delimiter -> RCBRACKET letter_string COLON LCBRACKET
Rule 100   actual_parameter -> string
Rule 101   actual_parameter -> expression
Rule 102   actual_parameter -> array_identifier
Rule 103   actual_parameter -> switch_identifier
Rule 104   actual_parameter -> procedure_identifier
Rule 105   conditional_statement -> if_statement
Rule 106   conditional_statement -> if_statement ELSE statement
Rule 107   conditional_statement -> if_clause for_statement
Rule 108   conditional_statement -> label COLON conditional_statement
Rule 109   if_statement -> if_clause unconditional_statement
Rule 110   if_clause -> IF boolean_expression THEN
Rule 111   for_statement -> for_clause statement
Rule 112   for_statement -> label COLON for_statement
Rule 113   for_clause -> FOR variable ASSIGNMENT for_list DO
Rule 114   for_list -> for_list_element
Rule 115   for_list -> for_list COMMA for_list_element
Rule 116   for_list_element -> arithmetic_expression
Rule 117   for_list_element -> arithmetic_expression STEP arithmetic_expression UNTIL arithmetic_expression
Rule 118   for_list_element -> arithmetic_expression WHILE boolean_expression
Rule 119   expression -> arithmetic_expression
Rule 120   expression -> boolean_expression
Rule 121   expression -> designational_expression
Rule 122   arithmetic_expression -> simple_arithmetic_expression
Rule 123   arithmetic_expression -> if_clause simple_arithmetic_expression ELSE arithmetic_expression
Rule 124   simple_arithmetic_expression -> term
Rule 125   simple_arithmetic_expression -> adding_operator term
Rule 126   simple_arithmetic_expression -> simple_arithmetic_expression adding_operator term
Rule 127   adding_operator -> PLUS
Rule 128   adding_operator -> MINUS
Rule 129   term -> factor
Rule 130   term -> term multiplying_operator factor
Rule 131   multiplying_operator -> TIMES
Rule 132   multiplying_operator -> DIV
Rule 133   multiplying_operator -> MOD
Rule 134   factor -> primary
Rule 135   factor -> factor
Rule 136   factor -> factor POWER primary
Rule 137   primary -> unsigned_number
Rule 138   primary -> variable
Rule 139   primary -> function_designator
Rule 140   primary -> LCBRACKET arithmetic_expression RCBRACKET
Rule 141   unsigned_number -> decimal_number
Rule 142   unsigned_number -> exponential_part
Rule 143   unsigned_number -> decimal_number exponential_part
Rule 144   decimal_number -> unsigned_integer
Rule 145   decimal_number -> decimal_fraction
Rule 146   decimal_number -> unsigned_integer decimal_fraction
Rule 147   unsigned_integer -> DIGIT
Rule 148   unsigned_integer -> unsigned_integer DIGIT
Rule 149   decimal_fraction -> DOT unsigned_integer
Rule 150   exponential_part -> EREAL integer
Rule 151   integer -> unsigned_integer
Rule 152   integer -> PLUS unsigned_integer
Rule 153   integer -> MINUS unsigned_integer
Rule 154   boolean_expression -> simple_boolean
Rule 155   boolean_expression -> if_clause simple_boolean ELSE boolean_expression
Rule 156   simple_boolean -> implication
Rule 157   simple_boolean -> simple_boolean EQUIV implication
Rule 158   implication -> boolean_term
Rule 159   implication -> implication IMPL boolean_term
Rule 160   boolean_term -> boolean_factor
Rule 161   boolean_term -> boolean_term OR boolean_factor
Rule 162   boolean_factor -> boolean_secondary
Rule 163   boolean_factor -> boolean_factor AND boolean_secondary
Rule 164   boolean_secondary -> boolean_primary
Rule 165   boolean_secondary -> NOT boolean_primary
Rule 166   boolean_primary -> logical_value
Rule 167   boolean_primary -> variable
Rule 168   boolean_primary -> function_designator
Rule 169   boolean_primary -> relation
Rule 170   boolean_primary -> LCBRACKET boolean_expression RCBRACKET
Rule 171   relation -> simple_arithmetic_expression relational_operator simple_arithmetic_expression
Rule 172   function_designator -> procedure_identifier actual_parameter_part
Rule 173   variable -> simple_variable
Rule 174   variable -> subscripted_variable
Rule 175   simple_variable -> variable_identifier
Rule 176   variable_identifier -> IDENTIFIER
Rule 177   subscripted_variable -> array_identifier LBBRACKET subscript_list RBBRACKET
Rule 178   subscript_list -> subscript_expression
Rule 179   subscript_list -> subscript_list COMMA subscript_expression
Rule 180   subscript_expression -> arithmetic_expression
Rule 181   string -> STRING
Rule 182   letter_string -> LETTER
Rule 183   letter_string -> letter_string LETTER
Rule 184   logical_value -> TRUE
Rule 185   logical_value -> FALSE
Rule 186   relational_operator -> LESS
Rule 187   relational_operator -> NOTGREATER
Rule 188   relational_operator -> EQUAL
Rule 189   relational_operator -> NOTLESS
Rule 190   relational_operator -> GREATER
Rule 191   relational_operator -> NOTEQUAL

Terminals, with rules where they appear

AND                  : 163
ASSIGNMENT           : 37 84 85 113
BEGIN                : 6 10
COLON                : 4 9 34 73 99 108 112
COMMA                : 24 28 30 33 40 64 98 115 179
COMMENT              : 
DIGIT                : 147 148
DIV                  : 132
DO                   : 113
DOT                  : 149
ELSE                 : 88 106 123 155
END                  : 11
EQUAL                : 188
EQUIV                : 157
EREAL                : 150
FALSE                : 185
FOR                  : 113
GOTO                 : 86
GREATER              : 190
IDENTIFIER           : 31 38 44 49 63 64 74 176
IF                   : 110
IMPL                 : 159
LBBRACKET            : 29 92 177
LCBRACKET            : 46 91 95 99 140 170
LESS                 : 186
LETTER               : 182 183
MINUS                : 128 153
MOD                  : 133
NOT                  : 165
NOTEQUAL             : 191
NOTGREATER           : 187
NOTLESS              : 189
OR                   : 161
PLUS                 : 127 152
POWER                : 136
PROCEDURE            : 41 42 61 62
RBBRACKET            : 29 92 177
RCBRACKET            : 46 91 95 99 140 170
SEMICOLON            : 5 7 12 43 51 53
STEP                 : 117
STRING               : 181
SWITCH               : 37 60
TARRAY               : 25 26 57 58
TBOOLEAN             : 22
THEN                 : 110
TIMES                : 131
TINTEGER             : 21
TLABEL               : 4 59
TOWN                 : 19
TREAL                : 20
TRUE                 : 184
TSTRING              : 55
TVALUE               : 51
UNTIL                : 117
WHILE                : 118
error                : 

Nonterminals, with rules where they appear

actual_parameter     : 96 97
actual_parameter_list : 95 97
actual_parameter_part : 93 172
adding_operator      : 125 126
arithmetic_expression : 35 36 80 116 117 117 117 118 119 123 140 180
array_declaration    : 14
array_identifier     : 29 30 102 177
array_list           : 25 26 28
array_segment        : 27 28 30
assignment_statement : 77
basic_statement      : 69 73
block                : 1 4 71
block_head           : 5 7
boolean_expression   : 81 110 118 120 155 170
boolean_factor       : 160 161 163
boolean_primary      : 164 165
boolean_secondary    : 162 163
boolean_term         : 158 159 161
bound_pair           : 32 33
bound_pair_list      : 29 33
compound_statement   : 2 9 70
compound_tail        : 5 10 12
conditional_statement : 67 108
decimal_fraction     : 145 146
decimal_number       : 141 143
declaration          : 6 7
designational_expression : 39 40 86 88 91 121
exponential_part     : 142 143
expression           : 101
factor               : 129 130 135 136
for_clause           : 111
for_list             : 113 115
for_list_element     : 114 115
for_statement        : 68 107 112
formal_parameter     : 47 48
formal_parameter_list : 46 48
formal_parameter_part : 43
function_designator  : 139 168
go_to_statement      : 78
identifier_list      : 51 53 54 64
if_clause            : 88 107 109 123 155
if_statement         : 105 106
implication          : 156 157 159
integer              : 150
label                : 9 73 89 108 112
left_part            : 82 83
left_part_list       : 80 81 83
letter_string        : 99 183
local_or_own_type    : 17 26
logical_value        : 166
lower_bound          : 34
multiplying_operator : 130
parameter_delimiter  : 48 97
primary              : 134 136
procedure_body       : 41 42
procedure_declaration : 16
procedure_heading    : 41 42
procedure_identifier : 43 85 93 104 172
procedure_statement  : 79
program              : 0
relation             : 169
relational_operator  : 171
simple_arithmetic_expression : 122 123 126 171 171
simple_boolean       : 154 155 157
simple_designational_expression : 87 88
simple_variable      : 23 24 173
specification_part   : 43 54
specifier            : 53 54
statement            : 11 12 65 106 111
string               : 100
subscript_expression : 92 178 179
subscript_list       : 177 179
subscripted_variable : 174
switch_declaration   : 15
switch_designator    : 90
switch_identifier    : 37 92 103
switch_list          : 37 40
term                 : 124 125 126 130
type                 : 18 19 42 56 58 62
type_declaration     : 13
type_list            : 17 24
unconditional_statement : 66 109
unlabelled_basic_statement : 72
unlabelled_block     : 3
unlabelled_compound  : 8
unsigned_integer     : 75 144 146 148 149 151 152 153
unsigned_number      : 137
upper_bound          : 34
value_part           : 43
variable             : 84 113 138 167
variable_identifier  : 175

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . block
    (2) program -> . compound_statement
    (3) block -> . unlabelled_block
    (4) block -> . TLABEL COLON block
    (8) compound_statement -> . unlabelled_compound
    (9) compound_statement -> . label COLON compound_statement
    (5) unlabelled_block -> . block_head SEMICOLON compound_tail
    (10) unlabelled_compound -> . BEGIN compound_tail
    (74) label -> . IDENTIFIER
    (75) label -> . unsigned_integer
    (6) block_head -> . BEGIN declaration
    (7) block_head -> . block_head SEMICOLON declaration
    (147) unsigned_integer -> . DIGIT
    (148) unsigned_integer -> . unsigned_integer DIGIT

    TLABEL          shift and go to state 4
    BEGIN           shift and go to state 1
    IDENTIFIER      shift and go to state 11
    DIGIT           shift and go to state 6

    unlabelled_compound            shift and go to state 2
    compound_statement             shift and go to state 3
    unlabelled_block               shift and go to state 5
    label                          shift and go to state 7
    program                        shift and go to state 8
    unsigned_integer               shift and go to state 9
    block_head                     shift and go to state 10
    block                          shift and go to state 12

state 1

    (10) unlabelled_compound -> BEGIN . compound_tail
    (6) block_head -> BEGIN . declaration
    (11) compound_tail -> . statement END
    (12) compound_tail -> . statement SEMICOLON compound_tail
    (13) declaration -> . type_declaration
    (14) declaration -> . array_declaration
    (15) declaration -> . switch_declaration
    (16) declaration -> . procedure_declaration
    (66) statement -> . unconditional_statement
    (67) statement -> . conditional_statement
    (68) statement -> . for_statement
    (17) type_declaration -> . local_or_own_type type_list
    (25) array_declaration -> . TARRAY array_list
    (26) array_declaration -> . local_or_own_type TARRAY array_list
    (37) switch_declaration -> . SWITCH switch_identifier ASSIGNMENT switch_list
    (41) procedure_declaration -> . PROCEDURE procedure_heading procedure_body
    (42) procedure_declaration -> . type PROCEDURE procedure_heading procedure_body
    (69) unconditional_statement -> . basic_statement
    (70) unconditional_statement -> . compound_statement
    (71) unconditional_statement -> . block
    (105) conditional_statement -> . if_statement
    (106) conditional_statement -> . if_statement ELSE statement
    (107) conditional_statement -> . if_clause for_statement
    (108) conditional_statement -> . label COLON conditional_statement
    (111) for_statement -> . for_clause statement
    (112) for_statement -> . label COLON for_statement
    (18) local_or_own_type -> . type
    (19) local_or_own_type -> . TOWN type
    (20) type -> . TREAL
    (21) type -> . TINTEGER
    (22) type -> . TBOOLEAN
    (72) basic_statement -> . unlabelled_basic_statement
    (73) basic_statement -> . label COLON basic_statement
    (8) compound_statement -> . unlabelled_compound
    (9) compound_statement -> . label COLON compound_statement
    (3) block -> . unlabelled_block
    (4) block -> . TLABEL COLON block
    (109) if_statement -> . if_clause unconditional_statement
    (110) if_clause -> . IF boolean_expression THEN
    (74) label -> . IDENTIFIER
    (75) label -> . unsigned_integer
    (113) for_clause -> . FOR variable ASSIGNMENT for_list DO
    (76) unlabelled_basic_statement -> .
    (77) unlabelled_basic_statement -> . assignment_statement
    (78) unlabelled_basic_statement -> . go_to_statement
    (79) unlabelled_basic_statement -> . procedure_statement
    (10) unlabelled_compound -> . BEGIN compound_tail
    (5) unlabelled_block -> . block_head SEMICOLON compound_tail
    (147) unsigned_integer -> . DIGIT
    (148) unsigned_integer -> . unsigned_integer DIGIT
    (80) assignment_statement -> . left_part_list arithmetic_expression
    (81) assignment_statement -> . left_part_list boolean_expression
    (86) go_to_statement -> . GOTO designational_expression
    (93) procedure_statement -> . procedure_identifier actual_parameter_part
    (6) block_head -> . BEGIN declaration
    (7) block_head -> . block_head SEMICOLON declaration
    (82) left_part_list -> . left_part
    (83) left_part_list -> . left_part_list left_part
    (44) procedure_identifier -> . IDENTIFIER
    (84) left_part -> . variable ASSIGNMENT
    (85) left_part -> . procedure_identifier ASSIGNMENT
    (173) variable -> . simple_variable
    (174) variable -> . subscripted_variable
    (175) simple_variable -> . variable_identifier
    (177) subscripted_variable -> . array_identifier LBBRACKET subscript_list RBBRACKET
    (176) variable_identifier -> . IDENTIFIER
    (31) array_identifier -> . IDENTIFIER

    TARRAY          shift and go to state 32
    SWITCH          shift and go to state 27
    PROCEDURE       shift and go to state 44
    TOWN            shift and go to state 46
    TREAL           shift and go to state 15
    TINTEGER        shift and go to state 18
    TBOOLEAN        shift and go to state 26
    TLABEL          shift and go to state 4
    IF              shift and go to state 45
    IDENTIFIER      shift and go to state 47
    FOR             shift and go to state 37
    END             reduce using rule 76 (unlabelled_basic_statement -> .)
    SEMICOLON       reduce using rule 76 (unlabelled_basic_statement -> .)
    BEGIN           shift and go to state 1
    DIGIT           shift and go to state 6
    GOTO            shift and go to state 20

    subscripted_variable           shift and go to state 13
    procedure_identifier           shift and go to state 21
    unlabelled_compound            shift and go to state 2
    array_identifier               shift and go to state 14
    unsigned_integer               shift and go to state 9
    if_clause                      shift and go to state 16
    type_declaration               shift and go to state 17
    block_head                     shift and go to state 10
    label                          shift and go to state 19
    left_part                      shift and go to state 34
    left_part_list                 shift and go to state 40
    compound_statement             shift and go to state 22
    assignment_statement           shift and go to state 23
    procedure_statement            shift and go to state 24
    conditional_statement          shift and go to state 25
    statement                      shift and go to state 29
    switch_declaration             shift and go to state 39
    if_statement                   shift and go to state 30
    type                           shift and go to state 31
    basic_statement                shift and go to state 33
    for_statement                  shift and go to state 35
    compound_tail                  shift and go to state 36
    go_to_statement                shift and go to state 38
    variable_identifier            shift and go to state 41
    declaration                    shift and go to state 42
    variable                       shift and go to state 43
    unconditional_statement        shift and go to state 28
    procedure_declaration          shift and go to state 48
    unlabelled_block               shift and go to state 5
    simple_variable                shift and go to state 49
    unlabelled_basic_statement     shift and go to state 50
    local_or_own_type              shift and go to state 51
    for_clause                     shift and go to state 52
    array_declaration              shift and go to state 53
    block                          shift and go to state 54

state 2

    (8) compound_statement -> unlabelled_compound .

    END             reduce using rule 8 (compound_statement -> unlabelled_compound .)
    SEMICOLON       reduce using rule 8 (compound_statement -> unlabelled_compound .)
    $end            reduce using rule 8 (compound_statement -> unlabelled_compound .)
    ELSE            reduce using rule 8 (compound_statement -> unlabelled_compound .)


state 3

    (2) program -> compound_statement .

    $end            reduce using rule 2 (program -> compound_statement .)


state 4

    (4) block -> TLABEL . COLON block

    COLON           shift and go to state 55


state 5

    (3) block -> unlabelled_block .

    END             reduce using rule 3 (block -> unlabelled_block .)
    SEMICOLON       reduce using rule 3 (block -> unlabelled_block .)
    $end            reduce using rule 3 (block -> unlabelled_block .)
    ELSE            reduce using rule 3 (block -> unlabelled_block .)


state 6

    (147) unsigned_integer -> DIGIT .

    DIGIT           reduce using rule 147 (unsigned_integer -> DIGIT .)
    DOT             reduce using rule 147 (unsigned_integer -> DIGIT .)
    EREAL           reduce using rule 147 (unsigned_integer -> DIGIT .)
    POWER           reduce using rule 147 (unsigned_integer -> DIGIT .)
    TIMES           reduce using rule 147 (unsigned_integer -> DIGIT .)
    DIV             reduce using rule 147 (unsigned_integer -> DIGIT .)
    MOD             reduce using rule 147 (unsigned_integer -> DIGIT .)
    PLUS            reduce using rule 147 (unsigned_integer -> DIGIT .)
    MINUS           reduce using rule 147 (unsigned_integer -> DIGIT .)
    LESS            reduce using rule 147 (unsigned_integer -> DIGIT .)
    NOTGREATER      reduce using rule 147 (unsigned_integer -> DIGIT .)
    EQUAL           reduce using rule 147 (unsigned_integer -> DIGIT .)
    NOTLESS         reduce using rule 147 (unsigned_integer -> DIGIT .)
    GREATER         reduce using rule 147 (unsigned_integer -> DIGIT .)
    NOTEQUAL        reduce using rule 147 (unsigned_integer -> DIGIT .)
    END             reduce using rule 147 (unsigned_integer -> DIGIT .)
    SEMICOLON       reduce using rule 147 (unsigned_integer -> DIGIT .)
    ELSE            reduce using rule 147 (unsigned_integer -> DIGIT .)
    RBBRACKET       reduce using rule 147 (unsigned_integer -> DIGIT .)
    COMMA           reduce using rule 147 (unsigned_integer -> DIGIT .)
    RCBRACKET       reduce using rule 147 (unsigned_integer -> DIGIT .)
    COLON           reduce using rule 147 (unsigned_integer -> DIGIT .)
    STEP            reduce using rule 147 (unsigned_integer -> DIGIT .)
    WHILE           reduce using rule 147 (unsigned_integer -> DIGIT .)
    DO              reduce using rule 147 (unsigned_integer -> DIGIT .)
    AND             reduce using rule 147 (unsigned_integer -> DIGIT .)
    OR              reduce using rule 147 (unsigned_integer -> DIGIT .)
    IMPL            reduce using rule 147 (unsigned_integer -> DIGIT .)
    EQUIV           reduce using rule 147 (unsigned_integer -> DIGIT .)
    THEN            reduce using rule 147 (unsigned_integer -> DIGIT .)
    UNTIL           reduce using rule 147 (unsigned_integer -> DIGIT .)


state 7

    (9) compound_statement -> label . COLON compound_statement

    COLON           shift and go to state 56


state 8

    (0) S' -> program .



state 9

    (75) label -> unsigned_integer .
    (148) unsigned_integer -> unsigned_integer . DIGIT

    COMMA           reduce using rule 75 (label -> unsigned_integer .)
    SEMICOLON       reduce using rule 75 (label -> unsigned_integer .)
    END             reduce using rule 75 (label -> unsigned_integer .)
    ELSE            reduce using rule 75 (label -> unsigned_integer .)
    RCBRACKET       reduce using rule 75 (label -> unsigned_integer .)
    COLON           reduce using rule 75 (label -> unsigned_integer .)
    DIGIT           shift and go to state 57


state 10

    (5) unlabelled_block -> block_head . SEMICOLON compound_tail
    (7) block_head -> block_head . SEMICOLON declaration

    SEMICOLON       shift and go to state 58


state 11

    (74) label -> IDENTIFIER .

    COLON           reduce using rule 74 (label -> IDENTIFIER .)


state 12

    (1) program -> block .

    $end            reduce using rule 1 (program -> block .)


state 13

    (174) variable -> subscripted_variable .

    ASSIGNMENT      reduce using rule 174 (variable -> subscripted_variable .)
    POWER           reduce using rule 174 (variable -> subscripted_variable .)
    TIMES           reduce using rule 174 (variable -> subscripted_variable .)
    DIV             reduce using rule 174 (variable -> subscripted_variable .)
    MOD             reduce using rule 174 (variable -> subscripted_variable .)
    PLUS            reduce using rule 174 (variable -> subscripted_variable .)
    MINUS           reduce using rule 174 (variable -> subscripted_variable .)
    END             reduce using rule 174 (variable -> subscripted_variable .)
    SEMICOLON       reduce using rule 174 (variable -> subscripted_variable .)
    ELSE            reduce using rule 174 (variable -> subscripted_variable .)
    RBBRACKET       reduce using rule 174 (variable -> subscripted_variable .)
    COMMA           reduce using rule 174 (variable -> subscripted_variable .)
    RCBRACKET       reduce using rule 174 (variable -> subscripted_variable .)
    COLON           reduce using rule 174 (variable -> subscripted_variable .)
    STEP            reduce using rule 174 (variable -> subscripted_variable .)
    WHILE           reduce using rule 174 (variable -> subscripted_variable .)
    DO              reduce using rule 174 (variable -> subscripted_variable .)
    UNTIL           reduce using rule 174 (variable -> subscripted_variable .)
    AND             reduce using rule 174 (variable -> subscripted_variable .)
    OR              reduce using rule 174 (variable -> subscripted_variable .)
    IMPL            reduce using rule 174 (variable -> subscripted_variable .)
    EQUIV           reduce using rule 174 (variable -> subscripted_variable .)
    THEN            reduce using rule 174 (variable -> subscripted_variable .)
    LESS            reduce using rule 174 (variable -> subscripted_variable .)
    NOTGREATER      reduce using rule 174 (variable -> subscripted_variable .)
    EQUAL           reduce using rule 174 (variable -> subscripted_variable .)
    NOTLESS         reduce using rule 174 (variable -> subscripted_variable .)
    GREATER         reduce using rule 174 (variable -> subscripted_variable .)
    NOTEQUAL        reduce using rule 174 (variable -> subscripted_variable .)


state 14

    (177) subscripted_variable -> array_identifier . LBBRACKET subscript_list RBBRACKET

    LBBRACKET       shift and go to state 59


state 15

    (20) type -> TREAL .

    TARRAY          reduce using rule 20 (type -> TREAL .)
    PROCEDURE       reduce using rule 20 (type -> TREAL .)
    IDENTIFIER      reduce using rule 20 (type -> TREAL .)


state 16

    (107) conditional_statement -> if_clause . for_statement
    (109) if_statement -> if_clause . unconditional_statement
    (111) for_statement -> . for_clause statement
    (112) for_statement -> . label COLON for_statement
    (69) unconditional_statement -> . basic_statement
    (70) unconditional_statement -> . compound_statement
    (71) unconditional_statement -> . block
    (113) for_clause -> . FOR variable ASSIGNMENT for_list DO
    (74) label -> . IDENTIFIER
    (75) label -> . unsigned_integer
    (72) basic_statement -> . unlabelled_basic_statement
    (73) basic_statement -> . label COLON basic_statement
    (8) compound_statement -> . unlabelled_compound
    (9) compound_statement -> . label COLON compound_statement
    (3) block -> . unlabelled_block
    (4) block -> . TLABEL COLON block
    (147) unsigned_integer -> . DIGIT
    (148) unsigned_integer -> . unsigned_integer DIGIT
    (76) unlabelled_basic_statement -> .
    (77) unlabelled_basic_statement -> . assignment_statement
    (78) unlabelled_basic_statement -> . go_to_statement
    (79) unlabelled_basic_statement -> . procedure_statement
    (10) unlabelled_compound -> . BEGIN compound_tail
    (5) unlabelled_block -> . block_head SEMICOLON compound_tail
    (80) assignment_statement -> . left_part_list arithmetic_expression
    (81) assignment_statement -> . left_part_list boolean_expression
    (86) go_to_statement -> . GOTO designational_expression
    (93) procedure_statement -> . procedure_identifier actual_parameter_part
    (6) block_head -> . BEGIN declaration
    (7) block_head -> . block_head SEMICOLON declaration
    (82) left_part_list -> . left_part
    (83) left_part_list -> . left_part_list left_part
    (44) procedure_identifier -> . IDENTIFIER
    (84) left_part -> . variable ASSIGNMENT
    (85) left_part -> . procedure_identifier ASSIGNMENT
    (173) variable -> . simple_variable
    (174) variable -> . subscripted_variable
    (175) simple_variable -> . variable_identifier
    (177) subscripted_variable -> . array_identifier LBBRACKET subscript_list RBBRACKET
    (176) variable_identifier -> . IDENTIFIER
    (31) array_identifier -> . IDENTIFIER

    FOR             shift and go to state 37
    IDENTIFIER      shift and go to state 47
    TLABEL          shift and go to state 4
    DIGIT           shift and go to state 6
    ELSE            reduce using rule 76 (unlabelled_basic_statement -> .)
    END             reduce using rule 76 (unlabelled_basic_statement -> .)
    SEMICOLON       reduce using rule 76 (unlabelled_basic_statement -> .)
    BEGIN           shift and go to state 1
    GOTO            shift and go to state 20

    subscripted_variable           shift and go to state 13
    unlabelled_compound            shift and go to state 2
    array_identifier               shift and go to state 14
    block_head                     shift and go to state 10
    left_part                      shift and go to state 34
    left_part_list                 shift and go to state 40
    compound_statement             shift and go to state 22
    assignment_statement           shift and go to state 23
    procedure_statement            shift and go to state 24
    label                          shift and go to state 60
    for_clause                     shift and go to state 52
    for_statement                  shift and go to state 61
    go_to_statement                shift and go to state 38
    variable_identifier            shift and go to state 41
    variable                       shift and go to state 43
    unconditional_statement        shift and go to state 62
    unlabelled_block               shift and go to state 5
    procedure_identifier           shift and go to state 21
    simple_variable                shift and go to state 49
    unlabelled_basic_statement     shift and go to state 50
    unsigned_integer               shift and go to state 9
    basic_statement                shift and go to state 33
    block                          shift and go to state 54

state 17

    (13) declaration -> type_declaration .

    SEMICOLON       reduce using rule 13 (declaration -> type_declaration .)


state 18

    (21) type -> TINTEGER .

    TARRAY          reduce using rule 21 (type -> TINTEGER .)
    PROCEDURE       reduce using rule 21 (type -> TINTEGER .)
    IDENTIFIER      reduce using rule 21 (type -> TINTEGER .)


state 19

    (108) conditional_statement -> label . COLON conditional_statement
    (112) for_statement -> label . COLON for_statement
    (73) basic_statement -> label . COLON basic_statement
    (9) compound_statement -> label . COLON compound_statement

    COLON           shift and go to state 63


state 20

    (86) go_to_statement -> GOTO . designational_expression
    (87) designational_expression -> . simple_designational_expression
    (88) designational_expression -> . if_clause simple_designational_expression ELSE designational_expression
    (89) simple_designational_expression -> . label
    (90) simple_designational_expression -> . switch_designator
    (91) simple_designational_expression -> . LCBRACKET designational_expression RCBRACKET
    (110) if_clause -> . IF boolean_expression THEN
    (74) label -> . IDENTIFIER
    (75) label -> . unsigned_integer
    (92) switch_designator -> . switch_identifier LBBRACKET subscript_expression RBBRACKET
    (147) unsigned_integer -> . DIGIT
    (148) unsigned_integer -> . unsigned_integer DIGIT
    (38) switch_identifier -> . IDENTIFIER

    LCBRACKET       shift and go to state 69
    IF              shift and go to state 45
    IDENTIFIER      shift and go to state 70
    DIGIT           shift and go to state 6

    designational_expression       shift and go to state 64
    simple_designational_expression shift and go to state 71
    switch_designator              shift and go to state 65
    if_clause                      shift and go to state 66
    label                          shift and go to state 67
    switch_identifier              shift and go to state 68
    unsigned_integer               shift and go to state 9

state 21

    (93) procedure_statement -> procedure_identifier . actual_parameter_part
    (85) left_part -> procedure_identifier . ASSIGNMENT
    (94) actual_parameter_part -> .
    (95) actual_parameter_part -> . LCBRACKET actual_parameter_list RCBRACKET

    ASSIGNMENT      shift and go to state 72
    END             reduce using rule 94 (actual_parameter_part -> .)
    SEMICOLON       reduce using rule 94 (actual_parameter_part -> .)
    ELSE            reduce using rule 94 (actual_parameter_part -> .)
    LCBRACKET       shift and go to state 73

    actual_parameter_part          shift and go to state 74

state 22

    (70) unconditional_statement -> compound_statement .

    SEMICOLON       reduce using rule 70 (unconditional_statement -> compound_statement .)
    END             reduce using rule 70 (unconditional_statement -> compound_statement .)
    ELSE            reduce using rule 70 (unconditional_statement -> compound_statement .)


state 23

    (77) unlabelled_basic_statement -> assignment_statement .

    END             reduce using rule 77 (unlabelled_basic_statement -> assignment_statement .)
    SEMICOLON       reduce using rule 77 (unlabelled_basic_statement -> assignment_statement .)
    ELSE            reduce using rule 77 (unlabelled_basic_statement -> assignment_statement .)


state 24

    (79) unlabelled_basic_statement -> procedure_statement .

    END             reduce using rule 79 (unlabelled_basic_statement -> procedure_statement .)
    SEMICOLON       reduce using rule 79 (unlabelled_basic_statement -> procedure_statement .)
    ELSE            reduce using rule 79 (unlabelled_basic_statement -> procedure_statement .)


state 25

    (67) statement -> conditional_statement .

    END             reduce using rule 67 (statement -> conditional_statement .)
    SEMICOLON       reduce using rule 67 (statement -> conditional_statement .)


state 26

    (22) type -> TBOOLEAN .

    TARRAY          reduce using rule 22 (type -> TBOOLEAN .)
    PROCEDURE       reduce using rule 22 (type -> TBOOLEAN .)
    IDENTIFIER      reduce using rule 22 (type -> TBOOLEAN .)


state 27

    (37) switch_declaration -> SWITCH . switch_identifier ASSIGNMENT switch_list
    (38) switch_identifier -> . IDENTIFIER

    IDENTIFIER      shift and go to state 75

    switch_identifier              shift and go to state 76

state 28

    (66) statement -> unconditional_statement .

    END             reduce using rule 66 (statement -> unconditional_statement .)
    SEMICOLON       reduce using rule 66 (statement -> unconditional_statement .)


state 29

    (11) compound_tail -> statement . END
    (12) compound_tail -> statement . SEMICOLON compound_tail

    END             shift and go to state 77
    SEMICOLON       shift and go to state 78


state 30

    (105) conditional_statement -> if_statement .
    (106) conditional_statement -> if_statement . ELSE statement

    END             reduce using rule 105 (conditional_statement -> if_statement .)
    SEMICOLON       reduce using rule 105 (conditional_statement -> if_statement .)
    ELSE            shift and go to state 79


state 31

    (42) procedure_declaration -> type . PROCEDURE procedure_heading procedure_body
    (18) local_or_own_type -> type .

    PROCEDURE       shift and go to state 80
    TARRAY          reduce using rule 18 (local_or_own_type -> type .)
    IDENTIFIER      reduce using rule 18 (local_or_own_type -> type .)


state 32

    (25) array_declaration -> TARRAY . array_list
    (27) array_list -> . array_segment
    (28) array_list -> . array_list COMMA array_segment
    (29) array_segment -> . array_identifier LBBRACKET bound_pair_list RBBRACKET
    (30) array_segment -> . array_identifier COMMA array_segment
    (31) array_identifier -> . IDENTIFIER

    IDENTIFIER      shift and go to state 83

    array_segment                  shift and go to state 81
    array_list                     shift and go to state 84
    array_identifier               shift and go to state 82

state 33

    (69) unconditional_statement -> basic_statement .

    SEMICOLON       reduce using rule 69 (unconditional_statement -> basic_statement .)
    END             reduce using rule 69 (unconditional_statement -> basic_statement .)
    ELSE            reduce using rule 69 (unconditional_statement -> basic_statement .)


state 34

    (82) left_part_list -> left_part .

    IF              reduce using rule 82 (left_part_list -> left_part .)
    IDENTIFIER      reduce using rule 82 (left_part_list -> left_part .)
    PLUS            reduce using rule 82 (left_part_list -> left_part .)
    MINUS           reduce using rule 82 (left_part_list -> left_part .)
    LCBRACKET       reduce using rule 82 (left_part_list -> left_part .)
    NOT             reduce using rule 82 (left_part_list -> left_part .)
    EREAL           reduce using rule 82 (left_part_list -> left_part .)
    DIGIT           reduce using rule 82 (left_part_list -> left_part .)
    DOT             reduce using rule 82 (left_part_list -> left_part .)
    TRUE            reduce using rule 82 (left_part_list -> left_part .)
    FALSE           reduce using rule 82 (left_part_list -> left_part .)


state 35

    (68) statement -> for_statement .

    END             reduce using rule 68 (statement -> for_statement .)
    SEMICOLON       reduce using rule 68 (statement -> for_statement .)


state 36

    (10) unlabelled_compound -> BEGIN compound_tail .

    SEMICOLON       reduce using rule 10 (unlabelled_compound -> BEGIN compound_tail .)
    $end            reduce using rule 10 (unlabelled_compound -> BEGIN compound_tail .)
    END             reduce using rule 10 (unlabelled_compound -> BEGIN compound_tail .)
    ELSE            reduce using rule 10 (unlabelled_compound -> BEGIN compound_tail .)


state 37

    (113) for_clause -> FOR . variable ASSIGNMENT for_list DO
    (173) variable -> . simple_variable
    (174) variable -> . subscripted_variable
    (175) simple_variable -> . variable_identifier
    (177) subscripted_variable -> . array_identifier LBBRACKET subscript_list RBBRACKET
    (176) variable_identifier -> . IDENTIFIER
    (31) array_identifier -> . IDENTIFIER

    IDENTIFIER      shift and go to state 86

    subscripted_variable           shift and go to state 13
    simple_variable                shift and go to state 49
    variable_identifier            shift and go to state 41
    array_identifier               shift and go to state 14
    variable                       shift and go to state 85

state 38

    (78) unlabelled_basic_statement -> go_to_statement .

    END             reduce using rule 78 (unlabelled_basic_statement -> go_to_statement .)
    SEMICOLON       reduce using rule 78 (unlabelled_basic_statement -> go_to_statement .)
    ELSE            reduce using rule 78 (unlabelled_basic_statement -> go_to_statement .)


state 39

    (15) declaration -> switch_declaration .

    SEMICOLON       reduce using rule 15 (declaration -> switch_declaration .)


state 40

    (80) assignment_statement -> left_part_list . arithmetic_expression
    (81) assignment_statement -> left_part_list . boolean_expression
    (83) left_part_list -> left_part_list . left_part
    (122) arithmetic_expression -> . simple_arithmetic_expression
    (123) arithmetic_expression -> . if_clause simple_arithmetic_expression ELSE arithmetic_expression
    (154) boolean_expression -> . simple_boolean
    (155) boolean_expression -> . if_clause simple_boolean ELSE boolean_expression
    (84) left_part -> . variable ASSIGNMENT
    (85) left_part -> . procedure_identifier ASSIGNMENT
    (124) simple_arithmetic_expression -> . term
    (125) simple_arithmetic_expression -> . adding_operator term
    (126) simple_arithmetic_expression -> . simple_arithmetic_expression adding_operator term
    (110) if_clause -> . IF boolean_expression THEN
    (156) simple_boolean -> . implication
    (157) simple_boolean -> . simple_boolean EQUIV implication
    (173) variable -> . simple_variable
    (174) variable -> . subscripted_variable
    (44) procedure_identifier -> . IDENTIFIER
    (129) term -> . factor
    (130) term -> . term multiplying_operator factor
    (127) adding_operator -> . PLUS
    (128) adding_operator -> . MINUS
    (158) implication -> . boolean_term
    (159) implication -> . implication IMPL boolean_term
    (175) simple_variable -> . variable_identifier
    (177) subscripted_variable -> . array_identifier LBBRACKET subscript_list RBBRACKET
    (134) factor -> . primary
    (135) factor -> . factor
    (136) factor -> . factor POWER primary
    (160) boolean_term -> . boolean_factor
    (161) boolean_term -> . boolean_term OR boolean_factor
    (176) variable_identifier -> . IDENTIFIER
    (31) array_identifier -> . IDENTIFIER
    (137) primary -> . unsigned_number
    (138) primary -> . variable
    (139) primary -> . function_designator
    (140) primary -> . LCBRACKET arithmetic_expression RCBRACKET
    (162) boolean_factor -> . boolean_secondary
    (163) boolean_factor -> . boolean_factor AND boolean_secondary
    (141) unsigned_number -> . decimal_number
    (142) unsigned_number -> . exponential_part
    (143) unsigned_number -> . decimal_number exponential_part
    (172) function_designator -> . procedure_identifier actual_parameter_part
    (164) boolean_secondary -> . boolean_primary
    (165) boolean_secondary -> . NOT boolean_primary
    (144) decimal_number -> . unsigned_integer
    (145) decimal_number -> . decimal_fraction
    (146) decimal_number -> . unsigned_integer decimal_fraction
    (150) exponential_part -> . EREAL integer
    (166) boolean_primary -> . logical_value
    (167) boolean_primary -> . variable
    (168) boolean_primary -> . function_designator
    (169) boolean_primary -> . relation
    (170) boolean_primary -> . LCBRACKET boolean_expression RCBRACKET
    (147) unsigned_integer -> . DIGIT
    (148) unsigned_integer -> . unsigned_integer DIGIT
    (149) decimal_fraction -> . DOT unsigned_integer
    (184) logical_value -> . TRUE
    (185) logical_value -> . FALSE
    (171) relation -> . simple_arithmetic_expression relational_operator simple_arithmetic_expression

    IF              shift and go to state 45
    IDENTIFIER      shift and go to state 106
    PLUS            shift and go to state 102
    MINUS           shift and go to state 94
    LCBRACKET       shift and go to state 116
    NOT             shift and go to state 118
    EREAL           shift and go to state 115
    DIGIT           shift and go to state 6
    DOT             shift and go to state 95
    TRUE            shift and go to state 93
    FALSE           shift and go to state 100

    boolean_primary                shift and go to state 99
    procedure_identifier           shift and go to state 87
    primary                        shift and go to state 98
    if_clause                      shift and go to state 89
    variable                       shift and go to state 111
    relation                       shift and go to state 91
    left_part                      shift and go to state 96
    simple_boolean                 shift and go to state 97
    boolean_secondary              shift and go to state 101
    unsigned_number                shift and go to state 105
    decimal_fraction               shift and go to state 103
    factor                         shift and go to state 104
    simple_arithmetic_expression   shift and go to state 107
    arithmetic_expression          shift and go to state 108
    logical_value                  shift and go to state 109
    decimal_number                 shift and go to state 112
    boolean_term                   shift and go to state 88
    variable_identifier            shift and go to state 41
    function_designator            shift and go to state 110
    array_identifier               shift and go to state 14
    boolean_factor                 shift and go to state 90
    exponential_part               shift and go to state 92
    term                           shift and go to state 113
    boolean_expression             shift and go to state 114
    subscripted_variable           shift and go to state 13
    simple_variable                shift and go to state 49
    adding_operator                shift and go to state 117
    implication                    shift and go to state 119
    unsigned_integer               shift and go to state 120

state 41

    (175) simple_variable -> variable_identifier .

    ASSIGNMENT      reduce using rule 175 (simple_variable -> variable_identifier .)
    POWER           reduce using rule 175 (simple_variable -> variable_identifier .)
    TIMES           reduce using rule 175 (simple_variable -> variable_identifier .)
    DIV             reduce using rule 175 (simple_variable -> variable_identifier .)
    MOD             reduce using rule 175 (simple_variable -> variable_identifier .)
    PLUS            reduce using rule 175 (simple_variable -> variable_identifier .)
    MINUS           reduce using rule 175 (simple_variable -> variable_identifier .)
    STEP            reduce using rule 175 (simple_variable -> variable_identifier .)
    WHILE           reduce using rule 175 (simple_variable -> variable_identifier .)
    DO              reduce using rule 175 (simple_variable -> variable_identifier .)
    COMMA           reduce using rule 175 (simple_variable -> variable_identifier .)
    LESS            reduce using rule 175 (simple_variable -> variable_identifier .)
    NOTGREATER      reduce using rule 175 (simple_variable -> variable_identifier .)
    EQUAL           reduce using rule 175 (simple_variable -> variable_identifier .)
    NOTLESS         reduce using rule 175 (simple_variable -> variable_identifier .)
    GREATER         reduce using rule 175 (simple_variable -> variable_identifier .)
    NOTEQUAL        reduce using rule 175 (simple_variable -> variable_identifier .)
    END             reduce using rule 175 (simple_variable -> variable_identifier .)
    SEMICOLON       reduce using rule 175 (simple_variable -> variable_identifier .)
    ELSE            reduce using rule 175 (simple_variable -> variable_identifier .)
    RBBRACKET       reduce using rule 175 (simple_variable -> variable_identifier .)
    RCBRACKET       reduce using rule 175 (simple_variable -> variable_identifier .)
    COLON           reduce using rule 175 (simple_variable -> variable_identifier .)
    AND             reduce using rule 175 (simple_variable -> variable_identifier .)
    OR              reduce using rule 175 (simple_variable -> variable_identifier .)
    IMPL            reduce using rule 175 (simple_variable -> variable_identifier .)
    EQUIV           reduce using rule 175 (simple_variable -> variable_identifier .)
    THEN            reduce using rule 175 (simple_variable -> variable_identifier .)
    UNTIL           reduce using rule 175 (simple_variable -> variable_identifier .)


state 42

    (6) block_head -> BEGIN declaration .

    SEMICOLON       reduce using rule 6 (block_head -> BEGIN declaration .)


state 43

    (84) left_part -> variable . ASSIGNMENT

    ASSIGNMENT      shift and go to state 121


state 44

    (41) procedure_declaration -> PROCEDURE . procedure_heading procedure_body
    (43) procedure_heading -> . procedure_identifier formal_parameter_part SEMICOLON value_part specification_part
    (44) procedure_identifier -> . IDENTIFIER

    IDENTIFIER      shift and go to state 124

    procedure_heading              shift and go to state 122
    procedure_identifier           shift and go to state 123

state 45

    (110) if_clause -> IF . boolean_expression THEN
    (154) boolean_expression -> . simple_boolean
    (155) boolean_expression -> . if_clause simple_boolean ELSE boolean_expression
    (156) simple_boolean -> . implication
    (157) simple_boolean -> . simple_boolean EQUIV implication
    (110) if_clause -> . IF boolean_expression THEN
    (158) implication -> . boolean_term
    (159) implication -> . implication IMPL boolean_term
    (160) boolean_term -> . boolean_factor
    (161) boolean_term -> . boolean_term OR boolean_factor
    (162) boolean_factor -> . boolean_secondary
    (163) boolean_factor -> . boolean_factor AND boolean_secondary
    (164) boolean_secondary -> . boolean_primary
    (165) boolean_secondary -> . NOT boolean_primary
    (166) boolean_primary -> . logical_value
    (167) boolean_primary -> . variable
    (168) boolean_primary -> . function_designator
    (169) boolean_primary -> . relation
    (170) boolean_primary -> . LCBRACKET boolean_expression RCBRACKET
    (184) logical_value -> . TRUE
    (185) logical_value -> . FALSE
    (173) variable -> . simple_variable
    (174) variable -> . subscripted_variable
    (172) function_designator -> . procedure_identifier actual_parameter_part
    (171) relation -> . simple_arithmetic_expression relational_operator simple_arithmetic_expression
    (175) simple_variable -> . variable_identifier
    (177) subscripted_variable -> . array_identifier LBBRACKET subscript_list RBBRACKET
    (44) procedure_identifier -> . IDENTIFIER
    (124) simple_arithmetic_expression -> . term
    (125) simple_arithmetic_expression -> . adding_operator term
    (126) simple_arithmetic_expression -> . simple_arithmetic_expression adding_operator term
    (176) variable_identifier -> . IDENTIFIER
    (31) array_identifier -> . IDENTIFIER
    (129) term -> . factor
    (130) term -> . term multiplying_operator factor
    (127) adding_operator -> . PLUS
    (128) adding_operator -> . MINUS
    (134) factor -> . primary
    (135) factor -> . factor
    (136) factor -> . factor POWER primary
    (137) primary -> . unsigned_number
    (138) primary -> . variable
    (139) primary -> . function_designator
    (140) primary -> . LCBRACKET arithmetic_expression RCBRACKET
    (141) unsigned_number -> . decimal_number
    (142) unsigned_number -> . exponential_part
    (143) unsigned_number -> . decimal_number exponential_part
    (144) decimal_number -> . unsigned_integer
    (145) decimal_number -> . decimal_fraction
    (146) decimal_number -> . unsigned_integer decimal_fraction
    (150) exponential_part -> . EREAL integer
    (147) unsigned_integer -> . DIGIT
    (148) unsigned_integer -> . unsigned_integer DIGIT
    (149) decimal_fraction -> . DOT unsigned_integer

    IF              shift and go to state 45
    NOT             shift and go to state 118
    LCBRACKET       shift and go to state 127
    TRUE            shift and go to state 93
    FALSE           shift and go to state 100
    IDENTIFIER      shift and go to state 106
    PLUS            shift and go to state 102
    MINUS           shift and go to state 94
    EREAL           shift and go to state 115
    DIGIT           shift and go to state 6
    DOT             shift and go to state 95

    subscripted_variable           shift and go to state 13
    boolean_term                   shift and go to state 88
    if_clause                      shift and go to state 126
    boolean_factor                 shift and go to state 90
    relation                       shift and go to state 91
    simple_boolean                 shift and go to state 97
    boolean_secondary              shift and go to state 101
    unsigned_number                shift and go to state 105
    decimal_fraction               shift and go to state 103
    factor                         shift and go to state 104
    simple_arithmetic_expression   shift and go to state 131
    boolean_primary                shift and go to state 99
    logical_value                  shift and go to state 109
    decimal_number                 shift and go to state 112
    primary                        shift and go to state 98
    variable_identifier            shift and go to state 41
    function_designator            shift and go to state 128
    array_identifier               shift and go to state 14
    variable                       shift and go to state 129
    exponential_part               shift and go to state 92
    term                           shift and go to state 113
    boolean_expression             shift and go to state 130
    procedure_identifier           shift and go to state 125
    simple_variable                shift and go to state 49
    adding_operator                shift and go to state 117
    implication                    shift and go to state 119
    unsigned_integer               shift and go to state 120

state 46

    (19) local_or_own_type -> TOWN . type
    (20) type -> . TREAL
    (21) type -> . TINTEGER
    (22) type -> . TBOOLEAN

    TREAL           shift and go to state 15
    TINTEGER        shift and go to state 18
    TBOOLEAN        shift and go to state 26

    type                           shift and go to state 132

state 47

    (74) label -> IDENTIFIER .
    (44) procedure_identifier -> IDENTIFIER .
    (176) variable_identifier -> IDENTIFIER .
    (31) array_identifier -> IDENTIFIER .

  ! reduce/reduce conflict for ASSIGNMENT resolved using rule 44 (procedure_identifier -> IDENTIFIER .)
    COLON           reduce using rule 74 (label -> IDENTIFIER .)
    ASSIGNMENT      reduce using rule 44 (procedure_identifier -> IDENTIFIER .)
    LCBRACKET       reduce using rule 44 (procedure_identifier -> IDENTIFIER .)
    END             reduce using rule 44 (procedure_identifier -> IDENTIFIER .)
    SEMICOLON       reduce using rule 44 (procedure_identifier -> IDENTIFIER .)
    ELSE            reduce using rule 44 (procedure_identifier -> IDENTIFIER .)
    LBBRACKET       reduce using rule 31 (array_identifier -> IDENTIFIER .)

  ! ASSIGNMENT      [ reduce using rule 176 (variable_identifier -> IDENTIFIER .) ]


state 48

    (16) declaration -> procedure_declaration .

    SEMICOLON       reduce using rule 16 (declaration -> procedure_declaration .)


state 49

    (173) variable -> simple_variable .

    ASSIGNMENT      reduce using rule 173 (variable -> simple_variable .)
    POWER           reduce using rule 173 (variable -> simple_variable .)
    TIMES           reduce using rule 173 (variable -> simple_variable .)
    DIV             reduce using rule 173 (variable -> simple_variable .)
    MOD             reduce using rule 173 (variable -> simple_variable .)
    PLUS            reduce using rule 173 (variable -> simple_variable .)
    MINUS           reduce using rule 173 (variable -> simple_variable .)
    END             reduce using rule 173 (variable -> simple_variable .)
    SEMICOLON       reduce using rule 173 (variable -> simple_variable .)
    ELSE            reduce using rule 173 (variable -> simple_variable .)
    RBBRACKET       reduce using rule 173 (variable -> simple_variable .)
    COMMA           reduce using rule 173 (variable -> simple_variable .)
    RCBRACKET       reduce using rule 173 (variable -> simple_variable .)
    COLON           reduce using rule 173 (variable -> simple_variable .)
    STEP            reduce using rule 173 (variable -> simple_variable .)
    WHILE           reduce using rule 173 (variable -> simple_variable .)
    DO              reduce using rule 173 (variable -> simple_variable .)
    UNTIL           reduce using rule 173 (variable -> simple_variable .)
    AND             reduce using rule 173 (variable -> simple_variable .)
    OR              reduce using rule 173 (variable -> simple_variable .)
    IMPL            reduce using rule 173 (variable -> simple_variable .)
    EQUIV           reduce using rule 173 (variable -> simple_variable .)
    THEN            reduce using rule 173 (variable -> simple_variable .)
    LESS            reduce using rule 173 (variable -> simple_variable .)
    NOTGREATER      reduce using rule 173 (variable -> simple_variable .)
    EQUAL           reduce using rule 173 (variable -> simple_variable .)
    NOTLESS         reduce using rule 173 (variable -> simple_variable .)
    GREATER         reduce using rule 173 (variable -> simple_variable .)
    NOTEQUAL        reduce using rule 173 (variable -> simple_variable .)


state 50

    (72) basic_statement -> unlabelled_basic_statement .

    END             reduce using rule 72 (basic_statement -> unlabelled_basic_statement .)
    SEMICOLON       reduce using rule 72 (basic_statement -> unlabelled_basic_statement .)
    ELSE            reduce using rule 72 (basic_statement -> unlabelled_basic_statement .)


state 51

    (17) type_declaration -> local_or_own_type . type_list
    (26) array_declaration -> local_or_own_type . TARRAY array_list
    (23) type_list -> . simple_variable
    (24) type_list -> . simple_variable COMMA type_list
    (175) simple_variable -> . variable_identifier
    (176) variable_identifier -> . IDENTIFIER

    TARRAY          shift and go to state 136
    IDENTIFIER      shift and go to state 135

    type_list                      shift and go to state 134
    simple_variable                shift and go to state 133
    variable_identifier            shift and go to state 41

state 52

    (111) for_statement -> for_clause . statement
    (66) statement -> . unconditional_statement
    (67) statement -> . conditional_statement
    (68) statement -> . for_statement
    (69) unconditional_statement -> . basic_statement
    (70) unconditional_statement -> . compound_statement
    (71) unconditional_statement -> . block
    (105) conditional_statement -> . if_statement
    (106) conditional_statement -> . if_statement ELSE statement
    (107) conditional_statement -> . if_clause for_statement
    (108) conditional_statement -> . label COLON conditional_statement
    (111) for_statement -> . for_clause statement
    (112) for_statement -> . label COLON for_statement
    (72) basic_statement -> . unlabelled_basic_statement
    (73) basic_statement -> . label COLON basic_statement
    (8) compound_statement -> . unlabelled_compound
    (9) compound_statement -> . label COLON compound_statement
    (3) block -> . unlabelled_block
    (4) block -> . TLABEL COLON block
    (109) if_statement -> . if_clause unconditional_statement
    (110) if_clause -> . IF boolean_expression THEN
    (74) label -> . IDENTIFIER
    (75) label -> . unsigned_integer
    (113) for_clause -> . FOR variable ASSIGNMENT for_list DO
    (76) unlabelled_basic_statement -> .
    (77) unlabelled_basic_statement -> . assignment_statement
    (78) unlabelled_basic_statement -> . go_to_statement
    (79) unlabelled_basic_statement -> . procedure_statement
    (10) unlabelled_compound -> . BEGIN compound_tail
    (5) unlabelled_block -> . block_head SEMICOLON compound_tail
    (147) unsigned_integer -> . DIGIT
    (148) unsigned_integer -> . unsigned_integer DIGIT
    (80) assignment_statement -> . left_part_list arithmetic_expression
    (81) assignment_statement -> . left_part_list boolean_expression
    (86) go_to_statement -> . GOTO designational_expression
    (93) procedure_statement -> . procedure_identifier actual_parameter_part
    (6) block_head -> . BEGIN declaration
    (7) block_head -> . block_head SEMICOLON declaration
    (82) left_part_list -> . left_part
    (83) left_part_list -> . left_part_list left_part
    (44) procedure_identifier -> . IDENTIFIER
    (84) left_part -> . variable ASSIGNMENT
    (85) left_part -> . procedure_identifier ASSIGNMENT
    (173) variable -> . simple_variable
    (174) variable -> . subscripted_variable
    (175) simple_variable -> . variable_identifier
    (177) subscripted_variable -> . array_identifier LBBRACKET subscript_list RBBRACKET
    (176) variable_identifier -> . IDENTIFIER
    (31) array_identifier -> . IDENTIFIER

    TLABEL          shift and go to state 4
    IF              shift and go to state 45
    IDENTIFIER      shift and go to state 47
    FOR             shift and go to state 37
    END             reduce using rule 76 (unlabelled_basic_statement -> .)
    SEMICOLON       reduce using rule 76 (unlabelled_basic_statement -> .)
    BEGIN           shift and go to state 1
    DIGIT           shift and go to state 6
    GOTO            shift and go to state 20

    subscripted_variable           shift and go to state 13
    unlabelled_compound            shift and go to state 2
    array_identifier               shift and go to state 14
    if_clause                      shift and go to state 16
    block_head                     shift and go to state 10
    conditional_statement          shift and go to state 25
    left_part                      shift and go to state 34
    left_part_list                 shift and go to state 40
    compound_statement             shift and go to state 22
    assignment_statement           shift and go to state 23
    procedure_statement            shift and go to state 24
    label                          shift and go to state 19
    statement                      shift and go to state 137
    if_statement                   shift and go to state 30
    for_clause                     shift and go to state 52
    for_statement                  shift and go to state 35
    go_to_statement                shift and go to state 38
    variable_identifier            shift and go to state 41
    variable                       shift and go to state 43
    unconditional_statement        shift and go to state 28
    unlabelled_block               shift and go to state 5
    procedure_identifier           shift and go to state 21
    simple_variable                shift and go to state 49
    unlabelled_basic_statement     shift and go to state 50
    unsigned_integer               shift and go to state 9
    basic_statement                shift and go to state 33
    block                          shift and go to state 54

state 53

    (14) declaration -> array_declaration .

    SEMICOLON       reduce using rule 14 (declaration -> array_declaration .)


state 54

    (71) unconditional_statement -> block .

    SEMICOLON       reduce using rule 71 (unconditional_statement -> block .)
    END             reduce using rule 71 (unconditional_statement -> block .)
    ELSE            reduce using rule 71 (unconditional_statement -> block .)


state 55

    (4) block -> TLABEL COLON . block
    (3) block -> . unlabelled_block
    (4) block -> . TLABEL COLON block
    (5) unlabelled_block -> . block_head SEMICOLON compound_tail
    (6) block_head -> . BEGIN declaration
    (7) block_head -> . block_head SEMICOLON declaration

    TLABEL          shift and go to state 4
    BEGIN           shift and go to state 138

    unlabelled_block               shift and go to state 5
    block_head                     shift and go to state 10
    block                          shift and go to state 139

state 56

    (9) compound_statement -> label COLON . compound_statement
    (8) compound_statement -> . unlabelled_compound
    (9) compound_statement -> . label COLON compound_statement
    (10) unlabelled_compound -> . BEGIN compound_tail
    (74) label -> . IDENTIFIER
    (75) label -> . unsigned_integer
    (147) unsigned_integer -> . DIGIT
    (148) unsigned_integer -> . unsigned_integer DIGIT

    BEGIN           shift and go to state 140
    IDENTIFIER      shift and go to state 11
    DIGIT           shift and go to state 6

    compound_statement             shift and go to state 141
    unlabelled_compound            shift and go to state 2
    unsigned_integer               shift and go to state 9
    label                          shift and go to state 7

state 57

    (148) unsigned_integer -> unsigned_integer DIGIT .

    DIGIT           reduce using rule 148 (unsigned_integer -> unsigned_integer DIGIT .)
    DOT             reduce using rule 148 (unsigned_integer -> unsigned_integer DIGIT .)
    EREAL           reduce using rule 148 (unsigned_integer -> unsigned_integer DIGIT .)
    POWER           reduce using rule 148 (unsigned_integer -> unsigned_integer DIGIT .)
    TIMES           reduce using rule 148 (unsigned_integer -> unsigned_integer DIGIT .)
    DIV             reduce using rule 148 (unsigned_integer -> unsigned_integer DIGIT .)
    MOD             reduce using rule 148 (unsigned_integer -> unsigned_integer DIGIT .)
    PLUS            reduce using rule 148 (unsigned_integer -> unsigned_integer DIGIT .)
    MINUS           reduce using rule 148 (unsigned_integer -> unsigned_integer DIGIT .)
    LESS            reduce using rule 148 (unsigned_integer -> unsigned_integer DIGIT .)
    NOTGREATER      reduce using rule 148 (unsigned_integer -> unsigned_integer DIGIT .)
    EQUAL           reduce using rule 148 (unsigned_integer -> unsigned_integer DIGIT .)
    NOTLESS         reduce using rule 148 (unsigned_integer -> unsigned_integer DIGIT .)
    GREATER         reduce using rule 148 (unsigned_integer -> unsigned_integer DIGIT .)
    NOTEQUAL        reduce using rule 148 (unsigned_integer -> unsigned_integer DIGIT .)
    END             reduce using rule 148 (unsigned_integer -> unsigned_integer DIGIT .)
    SEMICOLON       reduce using rule 148 (unsigned_integer -> unsigned_integer DIGIT .)
    ELSE            reduce using rule 148 (unsigned_integer -> unsigned_integer DIGIT .)
    RBBRACKET       reduce using rule 148 (unsigned_integer -> unsigned_integer DIGIT .)
    COMMA           reduce using rule 148 (unsigned_integer -> unsigned_integer DIGIT .)
    RCBRACKET       reduce using rule 148 (unsigned_integer -> unsigned_integer DIGIT .)
    COLON           reduce using rule 148 (unsigned_integer -> unsigned_integer DIGIT .)
    STEP            reduce using rule 148 (unsigned_integer -> unsigned_integer DIGIT .)
    WHILE           reduce using rule 148 (unsigned_integer -> unsigned_integer DIGIT .)
    DO              reduce using rule 148 (unsigned_integer -> unsigned_integer DIGIT .)
    AND             reduce using rule 148 (unsigned_integer -> unsigned_integer DIGIT .)
    OR              reduce using rule 148 (unsigned_integer -> unsigned_integer DIGIT .)
    IMPL            reduce using rule 148 (unsigned_integer -> unsigned_integer DIGIT .)
    EQUIV           reduce using rule 148 (unsigned_integer -> unsigned_integer DIGIT .)
    THEN            reduce using rule 148 (unsigned_integer -> unsigned_integer DIGIT .)
    UNTIL           reduce using rule 148 (unsigned_integer -> unsigned_integer DIGIT .)


state 58

    (5) unlabelled_block -> block_head SEMICOLON . compound_tail
    (7) block_head -> block_head SEMICOLON . declaration
    (11) compound_tail -> . statement END
    (12) compound_tail -> . statement SEMICOLON compound_tail
    (13) declaration -> . type_declaration
    (14) declaration -> . array_declaration
    (15) declaration -> . switch_declaration
    (16) declaration -> . procedure_declaration
    (66) statement -> . unconditional_statement
    (67) statement -> . conditional_statement
    (68) statement -> . for_statement
    (17) type_declaration -> . local_or_own_type type_list
    (25) array_declaration -> . TARRAY array_list
    (26) array_declaration -> . local_or_own_type TARRAY array_list
    (37) switch_declaration -> . SWITCH switch_identifier ASSIGNMENT switch_list
    (41) procedure_declaration -> . PROCEDURE procedure_heading procedure_body
    (42) procedure_declaration -> . type PROCEDURE procedure_heading procedure_body
    (69) unconditional_statement -> . basic_statement
    (70) unconditional_statement -> . compound_statement
    (71) unconditional_statement -> . block
    (105) conditional_statement -> . if_statement
    (106) conditional_statement -> . if_statement ELSE statement
    (107) conditional_statement -> . if_clause for_statement
    (108) conditional_statement -> . label COLON conditional_statement
    (111) for_statement -> . for_clause statement
    (112) for_statement -> . label COLON for_statement
    (18) local_or_own_type -> . type
    (19) local_or_own_type -> . TOWN type
    (20) type -> . TREAL
    (21) type -> . TINTEGER
    (22) type -> . TBOOLEAN
    (72) basic_statement -> . unlabelled_basic_statement
    (73) basic_statement -> . label COLON basic_statement
    (8) compound_statement -> . unlabelled_compound
    (9) compound_statement -> . label COLON compound_statement
    (3) block -> . unlabelled_block
    (4) block -> . TLABEL COLON block
    (109) if_statement -> . if_clause unconditional_statement
    (110) if_clause -> . IF boolean_expression THEN
    (74) label -> . IDENTIFIER
    (75) label -> . unsigned_integer
    (113) for_clause -> . FOR variable ASSIGNMENT for_list DO
    (76) unlabelled_basic_statement -> .
    (77) unlabelled_basic_statement -> . assignment_statement
    (78) unlabelled_basic_statement -> . go_to_statement
    (79) unlabelled_basic_statement -> . procedure_statement
    (10) unlabelled_compound -> . BEGIN compound_tail
    (5) unlabelled_block -> . block_head SEMICOLON compound_tail
    (147) unsigned_integer -> . DIGIT
    (148) unsigned_integer -> . unsigned_integer DIGIT
    (80) assignment_statement -> . left_part_list arithmetic_expression
    (81) assignment_statement -> . left_part_list boolean_expression
    (86) go_to_statement -> . GOTO designational_expression
    (93) procedure_statement -> . procedure_identifier actual_parameter_part
    (6) block_head -> . BEGIN declaration
    (7) block_head -> . block_head SEMICOLON declaration
    (82) left_part_list -> . left_part
    (83) left_part_list -> . left_part_list left_part
    (44) procedure_identifier -> . IDENTIFIER
    (84) left_part -> . variable ASSIGNMENT
    (85) left_part -> . procedure_identifier ASSIGNMENT
    (173) variable -> . simple_variable
    (174) variable -> . subscripted_variable
    (175) simple_variable -> . variable_identifier
    (177) subscripted_variable -> . array_identifier LBBRACKET subscript_list RBBRACKET
    (176) variable_identifier -> . IDENTIFIER
    (31) array_identifier -> . IDENTIFIER

    TARRAY          shift and go to state 32
    SWITCH          shift and go to state 27
    PROCEDURE       shift and go to state 44
    TOWN            shift and go to state 46
    TREAL           shift and go to state 15
    TINTEGER        shift and go to state 18
    TBOOLEAN        shift and go to state 26
    TLABEL          shift and go to state 4
    IF              shift and go to state 45
    IDENTIFIER      shift and go to state 47
    FOR             shift and go to state 37
    END             reduce using rule 76 (unlabelled_basic_statement -> .)
    SEMICOLON       reduce using rule 76 (unlabelled_basic_statement -> .)
    BEGIN           shift and go to state 1
    DIGIT           shift and go to state 6
    GOTO            shift and go to state 20

    subscripted_variable           shift and go to state 13
    procedure_identifier           shift and go to state 21
    unlabelled_compound            shift and go to state 2
    array_identifier               shift and go to state 14
    unsigned_integer               shift and go to state 9
    if_clause                      shift and go to state 16
    type_declaration               shift and go to state 17
    block_head                     shift and go to state 10
    label                          shift and go to state 19
    left_part                      shift and go to state 34
    left_part_list                 shift and go to state 40
    compound_statement             shift and go to state 22
    assignment_statement           shift and go to state 23
    procedure_statement            shift and go to state 24
    conditional_statement          shift and go to state 25
    statement                      shift and go to state 29
    switch_declaration             shift and go to state 39
    if_statement                   shift and go to state 30
    type                           shift and go to state 31
    basic_statement                shift and go to state 33
    for_statement                  shift and go to state 35
    compound_tail                  shift and go to state 142
    go_to_statement                shift and go to state 38
    variable_identifier            shift and go to state 41
    declaration                    shift and go to state 143
    variable                       shift and go to state 43
    unconditional_statement        shift and go to state 28
    procedure_declaration          shift and go to state 48
    unlabelled_block               shift and go to state 5
    simple_variable                shift and go to state 49
    unlabelled_basic_statement     shift and go to state 50
    local_or_own_type              shift and go to state 51
    for_clause                     shift and go to state 52
    array_declaration              shift and go to state 53
    block                          shift and go to state 54

state 59

    (177) subscripted_variable -> array_identifier LBBRACKET . subscript_list RBBRACKET
    (178) subscript_list -> . subscript_expression
    (179) subscript_list -> . subscript_list COMMA subscript_expression
    (180) subscript_expression -> . arithmetic_expression
    (122) arithmetic_expression -> . simple_arithmetic_expression
    (123) arithmetic_expression -> . if_clause simple_arithmetic_expression ELSE arithmetic_expression
    (124) simple_arithmetic_expression -> . term
    (125) simple_arithmetic_expression -> . adding_operator term
    (126) simple_arithmetic_expression -> . simple_arithmetic_expression adding_operator term
    (110) if_clause -> . IF boolean_expression THEN
    (129) term -> . factor
    (130) term -> . term multiplying_operator factor
    (127) adding_operator -> . PLUS
    (128) adding_operator -> . MINUS
    (134) factor -> . primary
    (135) factor -> . factor
    (136) factor -> . factor POWER primary
    (137) primary -> . unsigned_number
    (138) primary -> . variable
    (139) primary -> . function_designator
    (140) primary -> . LCBRACKET arithmetic_expression RCBRACKET
    (141) unsigned_number -> . decimal_number
    (142) unsigned_number -> . exponential_part
    (143) unsigned_number -> . decimal_number exponential_part
    (173) variable -> . simple_variable
    (174) variable -> . subscripted_variable
    (172) function_designator -> . procedure_identifier actual_parameter_part
    (144) decimal_number -> . unsigned_integer
    (145) decimal_number -> . decimal_fraction
    (146) decimal_number -> . unsigned_integer decimal_fraction
    (150) exponential_part -> . EREAL integer
    (175) simple_variable -> . variable_identifier
    (177) subscripted_variable -> . array_identifier LBBRACKET subscript_list RBBRACKET
    (44) procedure_identifier -> . IDENTIFIER
    (147) unsigned_integer -> . DIGIT
    (148) unsigned_integer -> . unsigned_integer DIGIT
    (149) decimal_fraction -> . DOT unsigned_integer
    (176) variable_identifier -> . IDENTIFIER
    (31) array_identifier -> . IDENTIFIER

    IF              shift and go to state 45
    PLUS            shift and go to state 102
    MINUS           shift and go to state 94
    LCBRACKET       shift and go to state 145
    EREAL           shift and go to state 115
    IDENTIFIER      shift and go to state 106
    DIGIT           shift and go to state 6
    DOT             shift and go to state 95

    subscripted_variable           shift and go to state 13
    primary                        shift and go to state 98
    if_clause                      shift and go to state 144
    subscript_expression           shift and go to state 146
    decimal_fraction               shift and go to state 103
    factor                         shift and go to state 104
    unsigned_number                shift and go to state 105
    simple_arithmetic_expression   shift and go to state 147
    arithmetic_expression          shift and go to state 148
    decimal_number                 shift and go to state 112
    variable_identifier            shift and go to state 41
    function_designator            shift and go to state 149
    array_identifier               shift and go to state 14
    variable                       shift and go to state 150
    exponential_part               shift and go to state 92
    term                           shift and go to state 113
    subscript_list                 shift and go to state 151
    procedure_identifier           shift and go to state 125
    simple_variable                shift and go to state 49
    adding_operator                shift and go to state 117
    unsigned_integer               shift and go to state 120

state 60

    (112) for_statement -> label . COLON for_statement
    (73) basic_statement -> label . COLON basic_statement
    (9) compound_statement -> label . COLON compound_statement

    COLON           shift and go to state 152


state 61

    (107) conditional_statement -> if_clause for_statement .

    END             reduce using rule 107 (conditional_statement -> if_clause for_statement .)
    SEMICOLON       reduce using rule 107 (conditional_statement -> if_clause for_statement .)


state 62

    (109) if_statement -> if_clause unconditional_statement .

    ELSE            reduce using rule 109 (if_statement -> if_clause unconditional_statement .)
    END             reduce using rule 109 (if_statement -> if_clause unconditional_statement .)
    SEMICOLON       reduce using rule 109 (if_statement -> if_clause unconditional_statement .)


state 63

    (108) conditional_statement -> label COLON . conditional_statement
    (112) for_statement -> label COLON . for_statement
    (73) basic_statement -> label COLON . basic_statement
    (9) compound_statement -> label COLON . compound_statement
    (105) conditional_statement -> . if_statement
    (106) conditional_statement -> . if_statement ELSE statement
    (107) conditional_statement -> . if_clause for_statement
    (108) conditional_statement -> . label COLON conditional_statement
    (111) for_statement -> . for_clause statement
    (112) for_statement -> . label COLON for_statement
    (72) basic_statement -> . unlabelled_basic_statement
    (73) basic_statement -> . label COLON basic_statement
    (8) compound_statement -> . unlabelled_compound
    (9) compound_statement -> . label COLON compound_statement
    (109) if_statement -> . if_clause unconditional_statement
    (110) if_clause -> . IF boolean_expression THEN
    (74) label -> . IDENTIFIER
    (75) label -> . unsigned_integer
    (113) for_clause -> . FOR variable ASSIGNMENT for_list DO
    (76) unlabelled_basic_statement -> .
    (77) unlabelled_basic_statement -> . assignment_statement
    (78) unlabelled_basic_statement -> . go_to_statement
    (79) unlabelled_basic_statement -> . procedure_statement
    (10) unlabelled_compound -> . BEGIN compound_tail
    (147) unsigned_integer -> . DIGIT
    (148) unsigned_integer -> . unsigned_integer DIGIT
    (80) assignment_statement -> . left_part_list arithmetic_expression
    (81) assignment_statement -> . left_part_list boolean_expression
    (86) go_to_statement -> . GOTO designational_expression
    (93) procedure_statement -> . procedure_identifier actual_parameter_part
    (82) left_part_list -> . left_part
    (83) left_part_list -> . left_part_list left_part
    (44) procedure_identifier -> . IDENTIFIER
    (84) left_part -> . variable ASSIGNMENT
    (85) left_part -> . procedure_identifier ASSIGNMENT
    (173) variable -> . simple_variable
    (174) variable -> . subscripted_variable
    (175) simple_variable -> . variable_identifier
    (177) subscripted_variable -> . array_identifier LBBRACKET subscript_list RBBRACKET
    (176) variable_identifier -> . IDENTIFIER
    (31) array_identifier -> . IDENTIFIER

    IF              shift and go to state 45
    IDENTIFIER      shift and go to state 47
    FOR             shift and go to state 37
    END             reduce using rule 76 (unlabelled_basic_statement -> .)
    SEMICOLON       reduce using rule 76 (unlabelled_basic_statement -> .)
    BEGIN           shift and go to state 140
    DIGIT           shift and go to state 6
    GOTO            shift and go to state 20

    subscripted_variable           shift and go to state 13
    unlabelled_compound            shift and go to state 2
    if_clause                      shift and go to state 16
    conditional_statement          shift and go to state 153
    left_part                      shift and go to state 34
    left_part_list                 shift and go to state 40
    compound_statement             shift and go to state 141
    assignment_statement           shift and go to state 23
    procedure_statement            shift and go to state 24
    label                          shift and go to state 19
    if_statement                   shift and go to state 30
    basic_statement                shift and go to state 154
    for_statement                  shift and go to state 155
    go_to_statement                shift and go to state 38
    variable_identifier            shift and go to state 41
    array_identifier               shift and go to state 14
    variable                       shift and go to state 43
    procedure_identifier           shift and go to state 21
    simple_variable                shift and go to state 49
    unlabelled_basic_statement     shift and go to state 50
    for_clause                     shift and go to state 52
    unsigned_integer               shift and go to state 9

state 64

    (86) go_to_statement -> GOTO designational_expression .

    ELSE            reduce using rule 86 (go_to_statement -> GOTO designational_expression .)
    END             reduce using rule 86 (go_to_statement -> GOTO designational_expression .)
    SEMICOLON       reduce using rule 86 (go_to_statement -> GOTO designational_expression .)


state 65

    (90) simple_designational_expression -> switch_designator .

    ELSE            reduce using rule 90 (simple_designational_expression -> switch_designator .)
    END             reduce using rule 90 (simple_designational_expression -> switch_designator .)
    SEMICOLON       reduce using rule 90 (simple_designational_expression -> switch_designator .)
    RCBRACKET       reduce using rule 90 (simple_designational_expression -> switch_designator .)
    COMMA           reduce using rule 90 (simple_designational_expression -> switch_designator .)


state 66

    (88) designational_expression -> if_clause . simple_designational_expression ELSE designational_expression
    (89) simple_designational_expression -> . label
    (90) simple_designational_expression -> . switch_designator
    (91) simple_designational_expression -> . LCBRACKET designational_expression RCBRACKET
    (74) label -> . IDENTIFIER
    (75) label -> . unsigned_integer
    (92) switch_designator -> . switch_identifier LBBRACKET subscript_expression RBBRACKET
    (147) unsigned_integer -> . DIGIT
    (148) unsigned_integer -> . unsigned_integer DIGIT
    (38) switch_identifier -> . IDENTIFIER

    LCBRACKET       shift and go to state 69
    IDENTIFIER      shift and go to state 70
    DIGIT           shift and go to state 6

    simple_designational_expression shift and go to state 156
    switch_designator              shift and go to state 65
    label                          shift and go to state 67
    switch_identifier              shift and go to state 68
    unsigned_integer               shift and go to state 9

state 67

    (89) simple_designational_expression -> label .

    ELSE            reduce using rule 89 (simple_designational_expression -> label .)
    END             reduce using rule 89 (simple_designational_expression -> label .)
    SEMICOLON       reduce using rule 89 (simple_designational_expression -> label .)
    RCBRACKET       reduce using rule 89 (simple_designational_expression -> label .)
    COMMA           reduce using rule 89 (simple_designational_expression -> label .)


state 68

    (92) switch_designator -> switch_identifier . LBBRACKET subscript_expression RBBRACKET

    LBBRACKET       shift and go to state 157


state 69

    (91) simple_designational_expression -> LCBRACKET . designational_expression RCBRACKET
    (87) designational_expression -> . simple_designational_expression
    (88) designational_expression -> . if_clause simple_designational_expression ELSE designational_expression
    (89) simple_designational_expression -> . label
    (90) simple_designational_expression -> . switch_designator
    (91) simple_designational_expression -> . LCBRACKET designational_expression RCBRACKET
    (110) if_clause -> . IF boolean_expression THEN
    (74) label -> . IDENTIFIER
    (75) label -> . unsigned_integer
    (92) switch_designator -> . switch_identifier LBBRACKET subscript_expression RBBRACKET
    (147) unsigned_integer -> . DIGIT
    (148) unsigned_integer -> . unsigned_integer DIGIT
    (38) switch_identifier -> . IDENTIFIER

    LCBRACKET       shift and go to state 69
    IF              shift and go to state 45
    IDENTIFIER      shift and go to state 70
    DIGIT           shift and go to state 6

    designational_expression       shift and go to state 158
    simple_designational_expression shift and go to state 71
    switch_designator              shift and go to state 65
    if_clause                      shift and go to state 66
    label                          shift and go to state 67
    switch_identifier              shift and go to state 68
    unsigned_integer               shift and go to state 9

state 70

    (74) label -> IDENTIFIER .
    (38) switch_identifier -> IDENTIFIER .

    COMMA           reduce using rule 74 (label -> IDENTIFIER .)
    SEMICOLON       reduce using rule 74 (label -> IDENTIFIER .)
    END             reduce using rule 74 (label -> IDENTIFIER .)
    ELSE            reduce using rule 74 (label -> IDENTIFIER .)
    RCBRACKET       reduce using rule 74 (label -> IDENTIFIER .)
    LBBRACKET       reduce using rule 38 (switch_identifier -> IDENTIFIER .)


state 71

    (87) designational_expression -> simple_designational_expression .

    RCBRACKET       reduce using rule 87 (designational_expression -> simple_designational_expression .)
    END             reduce using rule 87 (designational_expression -> simple_designational_expression .)
    SEMICOLON       reduce using rule 87 (designational_expression -> simple_designational_expression .)
    ELSE            reduce using rule 87 (designational_expression -> simple_designational_expression .)
    COMMA           reduce using rule 87 (designational_expression -> simple_designational_expression .)


state 72

    (85) left_part -> procedure_identifier ASSIGNMENT .

    IF              reduce using rule 85 (left_part -> procedure_identifier ASSIGNMENT .)
    IDENTIFIER      reduce using rule 85 (left_part -> procedure_identifier ASSIGNMENT .)
    PLUS            reduce using rule 85 (left_part -> procedure_identifier ASSIGNMENT .)
    MINUS           reduce using rule 85 (left_part -> procedure_identifier ASSIGNMENT .)
    LCBRACKET       reduce using rule 85 (left_part -> procedure_identifier ASSIGNMENT .)
    NOT             reduce using rule 85 (left_part -> procedure_identifier ASSIGNMENT .)
    EREAL           reduce using rule 85 (left_part -> procedure_identifier ASSIGNMENT .)
    DIGIT           reduce using rule 85 (left_part -> procedure_identifier ASSIGNMENT .)
    DOT             reduce using rule 85 (left_part -> procedure_identifier ASSIGNMENT .)
    TRUE            reduce using rule 85 (left_part -> procedure_identifier ASSIGNMENT .)
    FALSE           reduce using rule 85 (left_part -> procedure_identifier ASSIGNMENT .)


state 73

    (95) actual_parameter_part -> LCBRACKET . actual_parameter_list RCBRACKET
    (96) actual_parameter_list -> . actual_parameter
    (97) actual_parameter_list -> . actual_parameter_list parameter_delimiter actual_parameter
    (100) actual_parameter -> . string
    (101) actual_parameter -> . expression
    (102) actual_parameter -> . array_identifier
    (103) actual_parameter -> . switch_identifier
    (104) actual_parameter -> . procedure_identifier
    (181) string -> . STRING
    (119) expression -> . arithmetic_expression
    (120) expression -> . boolean_expression
    (121) expression -> . designational_expression
    (31) array_identifier -> . IDENTIFIER
    (38) switch_identifier -> . IDENTIFIER
    (44) procedure_identifier -> . IDENTIFIER
    (122) arithmetic_expression -> . simple_arithmetic_expression
    (123) arithmetic_expression -> . if_clause simple_arithmetic_expression ELSE arithmetic_expression
    (154) boolean_expression -> . simple_boolean
    (155) boolean_expression -> . if_clause simple_boolean ELSE boolean_expression
    (87) designational_expression -> . simple_designational_expression
    (88) designational_expression -> . if_clause simple_designational_expression ELSE designational_expression
    (124) simple_arithmetic_expression -> . term
    (125) simple_arithmetic_expression -> . adding_operator term
    (126) simple_arithmetic_expression -> . simple_arithmetic_expression adding_operator term
    (110) if_clause -> . IF boolean_expression THEN
    (156) simple_boolean -> . implication
    (157) simple_boolean -> . simple_boolean EQUIV implication
    (89) simple_designational_expression -> . label
    (90) simple_designational_expression -> . switch_designator
    (91) simple_designational_expression -> . LCBRACKET designational_expression RCBRACKET
    (129) term -> . factor
    (130) term -> . term multiplying_operator factor
    (127) adding_operator -> . PLUS
    (128) adding_operator -> . MINUS
    (158) implication -> . boolean_term
    (159) implication -> . implication IMPL boolean_term
    (74) label -> . IDENTIFIER
    (75) label -> . unsigned_integer
    (92) switch_designator -> . switch_identifier LBBRACKET subscript_expression RBBRACKET
    (134) factor -> . primary
    (135) factor -> . factor
    (136) factor -> . factor POWER primary
    (160) boolean_term -> . boolean_factor
    (161) boolean_term -> . boolean_term OR boolean_factor
    (147) unsigned_integer -> . DIGIT
    (148) unsigned_integer -> . unsigned_integer DIGIT
    (137) primary -> . unsigned_number
    (138) primary -> . variable
    (139) primary -> . function_designator
    (140) primary -> . LCBRACKET arithmetic_expression RCBRACKET
    (162) boolean_factor -> . boolean_secondary
    (163) boolean_factor -> . boolean_factor AND boolean_secondary
    (141) unsigned_number -> . decimal_number
    (142) unsigned_number -> . exponential_part
    (143) unsigned_number -> . decimal_number exponential_part
    (173) variable -> . simple_variable
    (174) variable -> . subscripted_variable
    (172) function_designator -> . procedure_identifier actual_parameter_part
    (164) boolean_secondary -> . boolean_primary
    (165) boolean_secondary -> . NOT boolean_primary
    (144) decimal_number -> . unsigned_integer
    (145) decimal_number -> . decimal_fraction
    (146) decimal_number -> . unsigned_integer decimal_fraction
    (150) exponential_part -> . EREAL integer
    (175) simple_variable -> . variable_identifier
    (177) subscripted_variable -> . array_identifier LBBRACKET subscript_list RBBRACKET
    (166) boolean_primary -> . logical_value
    (167) boolean_primary -> . variable
    (168) boolean_primary -> . function_designator
    (169) boolean_primary -> . relation
    (170) boolean_primary -> . LCBRACKET boolean_expression RCBRACKET
    (149) decimal_fraction -> . DOT unsigned_integer
    (176) variable_identifier -> . IDENTIFIER
    (184) logical_value -> . TRUE
    (185) logical_value -> . FALSE
    (171) relation -> . simple_arithmetic_expression relational_operator simple_arithmetic_expression

    STRING          shift and go to state 164
    IDENTIFIER      shift and go to state 165
    IF              shift and go to state 45
    LCBRACKET       shift and go to state 169
    PLUS            shift and go to state 102
    MINUS           shift and go to state 94
    DIGIT           shift and go to state 6
    NOT             shift and go to state 118
    EREAL           shift and go to state 115
    DOT             shift and go to state 95
    TRUE            shift and go to state 93
    FALSE           shift and go to state 100

    actual_parameter_list          shift and go to state 159
    boolean_primary                shift and go to state 99
    subscripted_variable           shift and go to state 13
    boolean_term                   shift and go to state 88
    if_clause                      shift and go to state 160
    variable                       shift and go to state 161
    relation                       shift and go to state 91
    simple_designational_expression shift and go to state 71
    simple_boolean                 shift and go to state 97
    boolean_secondary              shift and go to state 101
    label                          shift and go to state 67
    actual_parameter               shift and go to state 162
    switch_identifier              shift and go to state 163
    unsigned_number                shift and go to state 105
    decimal_fraction               shift and go to state 103
    simple_arithmetic_expression   shift and go to state 107
    arithmetic_expression          shift and go to state 166
    string                         shift and go to state 167
    logical_value                  shift and go to state 109
    factor                         shift and go to state 104
    decimal_number                 shift and go to state 112
    primary                        shift and go to state 98
    variable_identifier            shift and go to state 41
    function_designator            shift and go to state 110
    array_identifier               shift and go to state 168
    boolean_factor                 shift and go to state 90
    exponential_part               shift and go to state 92
    term                           shift and go to state 113
    designational_expression       shift and go to state 170
    boolean_expression             shift and go to state 171
    procedure_identifier           shift and go to state 172
    simple_variable                shift and go to state 49
    switch_designator              shift and go to state 65
    adding_operator                shift and go to state 117
    implication                    shift and go to state 119
    expression                     shift and go to state 173
    unsigned_integer               shift and go to state 174

state 74

    (93) procedure_statement -> procedure_identifier actual_parameter_part .

    ELSE            reduce using rule 93 (procedure_statement -> procedure_identifier actual_parameter_part .)
    END             reduce using rule 93 (procedure_statement -> procedure_identifier actual_parameter_part .)
    SEMICOLON       reduce using rule 93 (procedure_statement -> procedure_identifier actual_parameter_part .)


state 75

    (38) switch_identifier -> IDENTIFIER .

    ASSIGNMENT      reduce using rule 38 (switch_identifier -> IDENTIFIER .)


state 76

    (37) switch_declaration -> SWITCH switch_identifier . ASSIGNMENT switch_list

    ASSIGNMENT      shift and go to state 175


state 77

    (11) compound_tail -> statement END .

    $end            reduce using rule 11 (compound_tail -> statement END .)
    END             reduce using rule 11 (compound_tail -> statement END .)
    SEMICOLON       reduce using rule 11 (compound_tail -> statement END .)
    ELSE            reduce using rule 11 (compound_tail -> statement END .)


state 78

    (12) compound_tail -> statement SEMICOLON . compound_tail
    (11) compound_tail -> . statement END
    (12) compound_tail -> . statement SEMICOLON compound_tail
    (66) statement -> . unconditional_statement
    (67) statement -> . conditional_statement
    (68) statement -> . for_statement
    (69) unconditional_statement -> . basic_statement
    (70) unconditional_statement -> . compound_statement
    (71) unconditional_statement -> . block
    (105) conditional_statement -> . if_statement
    (106) conditional_statement -> . if_statement ELSE statement
    (107) conditional_statement -> . if_clause for_statement
    (108) conditional_statement -> . label COLON conditional_statement
    (111) for_statement -> . for_clause statement
    (112) for_statement -> . label COLON for_statement
    (72) basic_statement -> . unlabelled_basic_statement
    (73) basic_statement -> . label COLON basic_statement
    (8) compound_statement -> . unlabelled_compound
    (9) compound_statement -> . label COLON compound_statement
    (3) block -> . unlabelled_block
    (4) block -> . TLABEL COLON block
    (109) if_statement -> . if_clause unconditional_statement
    (110) if_clause -> . IF boolean_expression THEN
    (74) label -> . IDENTIFIER
    (75) label -> . unsigned_integer
    (113) for_clause -> . FOR variable ASSIGNMENT for_list DO
    (76) unlabelled_basic_statement -> .
    (77) unlabelled_basic_statement -> . assignment_statement
    (78) unlabelled_basic_statement -> . go_to_statement
    (79) unlabelled_basic_statement -> . procedure_statement
    (10) unlabelled_compound -> . BEGIN compound_tail
    (5) unlabelled_block -> . block_head SEMICOLON compound_tail
    (147) unsigned_integer -> . DIGIT
    (148) unsigned_integer -> . unsigned_integer DIGIT
    (80) assignment_statement -> . left_part_list arithmetic_expression
    (81) assignment_statement -> . left_part_list boolean_expression
    (86) go_to_statement -> . GOTO designational_expression
    (93) procedure_statement -> . procedure_identifier actual_parameter_part
    (6) block_head -> . BEGIN declaration
    (7) block_head -> . block_head SEMICOLON declaration
    (82) left_part_list -> . left_part
    (83) left_part_list -> . left_part_list left_part
    (44) procedure_identifier -> . IDENTIFIER
    (84) left_part -> . variable ASSIGNMENT
    (85) left_part -> . procedure_identifier ASSIGNMENT
    (173) variable -> . simple_variable
    (174) variable -> . subscripted_variable
    (175) simple_variable -> . variable_identifier
    (177) subscripted_variable -> . array_identifier LBBRACKET subscript_list RBBRACKET
    (176) variable_identifier -> . IDENTIFIER
    (31) array_identifier -> . IDENTIFIER

    TLABEL          shift and go to state 4
    IF              shift and go to state 45
    IDENTIFIER      shift and go to state 47
    FOR             shift and go to state 37
    END             reduce using rule 76 (unlabelled_basic_statement -> .)
    SEMICOLON       reduce using rule 76 (unlabelled_basic_statement -> .)
    BEGIN           shift and go to state 1
    DIGIT           shift and go to state 6
    GOTO            shift and go to state 20

    subscripted_variable           shift and go to state 13
    block                          shift and go to state 54
    unlabelled_compound            shift and go to state 2
    array_identifier               shift and go to state 14
    if_clause                      shift and go to state 16
    block_head                     shift and go to state 10
    conditional_statement          shift and go to state 25
    left_part                      shift and go to state 34
    left_part_list                 shift and go to state 40
    compound_statement             shift and go to state 22
    assignment_statement           shift and go to state 23
    procedure_statement            shift and go to state 24
    label                          shift and go to state 19
    statement                      shift and go to state 29
    if_statement                   shift and go to state 30
    basic_statement                shift and go to state 33
    for_statement                  shift and go to state 35
    compound_tail                  shift and go to state 176
    go_to_statement                shift and go to state 38
    variable_identifier            shift and go to state 41
    variable                       shift and go to state 43
    unconditional_statement        shift and go to state 28
    unlabelled_block               shift and go to state 5
    procedure_identifier           shift and go to state 21
    simple_variable                shift and go to state 49
    unlabelled_basic_statement     shift and go to state 50
    for_clause                     shift and go to state 52
    unsigned_integer               shift and go to state 9

state 79

    (106) conditional_statement -> if_statement ELSE . statement
    (66) statement -> . unconditional_statement
    (67) statement -> . conditional_statement
    (68) statement -> . for_statement
    (69) unconditional_statement -> . basic_statement
    (70) unconditional_statement -> . compound_statement
    (71) unconditional_statement -> . block
    (105) conditional_statement -> . if_statement
    (106) conditional_statement -> . if_statement ELSE statement
    (107) conditional_statement -> . if_clause for_statement
    (108) conditional_statement -> . label COLON conditional_statement
    (111) for_statement -> . for_clause statement
    (112) for_statement -> . label COLON for_statement
    (72) basic_statement -> . unlabelled_basic_statement
    (73) basic_statement -> . label COLON basic_statement
    (8) compound_statement -> . unlabelled_compound
    (9) compound_statement -> . label COLON compound_statement
    (3) block -> . unlabelled_block
    (4) block -> . TLABEL COLON block
    (109) if_statement -> . if_clause unconditional_statement
    (110) if_clause -> . IF boolean_expression THEN
    (74) label -> . IDENTIFIER
    (75) label -> . unsigned_integer
    (113) for_clause -> . FOR variable ASSIGNMENT for_list DO
    (76) unlabelled_basic_statement -> .
    (77) unlabelled_basic_statement -> . assignment_statement
    (78) unlabelled_basic_statement -> . go_to_statement
    (79) unlabelled_basic_statement -> . procedure_statement
    (10) unlabelled_compound -> . BEGIN compound_tail
    (5) unlabelled_block -> . block_head SEMICOLON compound_tail
    (147) unsigned_integer -> . DIGIT
    (148) unsigned_integer -> . unsigned_integer DIGIT
    (80) assignment_statement -> . left_part_list arithmetic_expression
    (81) assignment_statement -> . left_part_list boolean_expression
    (86) go_to_statement -> . GOTO designational_expression
    (93) procedure_statement -> . procedure_identifier actual_parameter_part
    (6) block_head -> . BEGIN declaration
    (7) block_head -> . block_head SEMICOLON declaration
    (82) left_part_list -> . left_part
    (83) left_part_list -> . left_part_list left_part
    (44) procedure_identifier -> . IDENTIFIER
    (84) left_part -> . variable ASSIGNMENT
    (85) left_part -> . procedure_identifier ASSIGNMENT
    (173) variable -> . simple_variable
    (174) variable -> . subscripted_variable
    (175) simple_variable -> . variable_identifier
    (177) subscripted_variable -> . array_identifier LBBRACKET subscript_list RBBRACKET
    (176) variable_identifier -> . IDENTIFIER
    (31) array_identifier -> . IDENTIFIER

    TLABEL          shift and go to state 4
    IF              shift and go to state 45
    IDENTIFIER      shift and go to state 47
    FOR             shift and go to state 37
    END             reduce using rule 76 (unlabelled_basic_statement -> .)
    SEMICOLON       reduce using rule 76 (unlabelled_basic_statement -> .)
    BEGIN           shift and go to state 1
    DIGIT           shift and go to state 6
    GOTO            shift and go to state 20

    subscripted_variable           shift and go to state 13
    block                          shift and go to state 54
    unlabelled_compound            shift and go to state 2
    array_identifier               shift and go to state 14
    if_clause                      shift and go to state 16
    block_head                     shift and go to state 10
    conditional_statement          shift and go to state 25
    left_part                      shift and go to state 34
    left_part_list                 shift and go to state 40
    compound_statement             shift and go to state 22
    assignment_statement           shift and go to state 23
    procedure_statement            shift and go to state 24
    label                          shift and go to state 19
    statement                      shift and go to state 177
    if_statement                   shift and go to state 30
    basic_statement                shift and go to state 33
    for_statement                  shift and go to state 35
    go_to_statement                shift and go to state 38
    variable_identifier            shift and go to state 41
    variable                       shift and go to state 43
    unconditional_statement        shift and go to state 28
    unlabelled_block               shift and go to state 5
    procedure_identifier           shift and go to state 21
    simple_variable                shift and go to state 49
    unlabelled_basic_statement     shift and go to state 50
    for_clause                     shift and go to state 52
    unsigned_integer               shift and go to state 9

state 80

    (42) procedure_declaration -> type PROCEDURE . procedure_heading procedure_body
    (43) procedure_heading -> . procedure_identifier formal_parameter_part SEMICOLON value_part specification_part
    (44) procedure_identifier -> . IDENTIFIER

    IDENTIFIER      shift and go to state 124

    procedure_heading              shift and go to state 178
    procedure_identifier           shift and go to state 123

state 81

    (27) array_list -> array_segment .

    COMMA           reduce using rule 27 (array_list -> array_segment .)
    SEMICOLON       reduce using rule 27 (array_list -> array_segment .)


state 82

    (29) array_segment -> array_identifier . LBBRACKET bound_pair_list RBBRACKET
    (30) array_segment -> array_identifier . COMMA array_segment

    LBBRACKET       shift and go to state 179
    COMMA           shift and go to state 180


state 83

    (31) array_identifier -> IDENTIFIER .

    LBBRACKET       reduce using rule 31 (array_identifier -> IDENTIFIER .)
    COMMA           reduce using rule 31 (array_identifier -> IDENTIFIER .)


state 84

    (25) array_declaration -> TARRAY array_list .
    (28) array_list -> array_list . COMMA array_segment

    SEMICOLON       reduce using rule 25 (array_declaration -> TARRAY array_list .)
    COMMA           shift and go to state 181


state 85

    (113) for_clause -> FOR variable . ASSIGNMENT for_list DO

    ASSIGNMENT      shift and go to state 182


state 86

    (176) variable_identifier -> IDENTIFIER .
    (31) array_identifier -> IDENTIFIER .

    ASSIGNMENT      reduce using rule 176 (variable_identifier -> IDENTIFIER .)
    LBBRACKET       reduce using rule 31 (array_identifier -> IDENTIFIER .)


state 87

    (85) left_part -> procedure_identifier . ASSIGNMENT
    (172) function_designator -> procedure_identifier . actual_parameter_part
    (94) actual_parameter_part -> .
    (95) actual_parameter_part -> . LCBRACKET actual_parameter_list RCBRACKET

    ASSIGNMENT      shift and go to state 72
    POWER           reduce using rule 94 (actual_parameter_part -> .)
    TIMES           reduce using rule 94 (actual_parameter_part -> .)
    DIV             reduce using rule 94 (actual_parameter_part -> .)
    MOD             reduce using rule 94 (actual_parameter_part -> .)
    PLUS            reduce using rule 94 (actual_parameter_part -> .)
    MINUS           reduce using rule 94 (actual_parameter_part -> .)
    LESS            reduce using rule 94 (actual_parameter_part -> .)
    NOTGREATER      reduce using rule 94 (actual_parameter_part -> .)
    EQUAL           reduce using rule 94 (actual_parameter_part -> .)
    NOTLESS         reduce using rule 94 (actual_parameter_part -> .)
    GREATER         reduce using rule 94 (actual_parameter_part -> .)
    NOTEQUAL        reduce using rule 94 (actual_parameter_part -> .)
    END             reduce using rule 94 (actual_parameter_part -> .)
    SEMICOLON       reduce using rule 94 (actual_parameter_part -> .)
    ELSE            reduce using rule 94 (actual_parameter_part -> .)
    AND             reduce using rule 94 (actual_parameter_part -> .)
    OR              reduce using rule 94 (actual_parameter_part -> .)
    IMPL            reduce using rule 94 (actual_parameter_part -> .)
    EQUIV           reduce using rule 94 (actual_parameter_part -> .)
    LCBRACKET       shift and go to state 73

    actual_parameter_part          shift and go to state 183

state 88

    (158) implication -> boolean_term .
    (161) boolean_term -> boolean_term . OR boolean_factor

    IMPL            reduce using rule 158 (implication -> boolean_term .)
    EQUIV           reduce using rule 158 (implication -> boolean_term .)
    END             reduce using rule 158 (implication -> boolean_term .)
    SEMICOLON       reduce using rule 158 (implication -> boolean_term .)
    ELSE            reduce using rule 158 (implication -> boolean_term .)
    THEN            reduce using rule 158 (implication -> boolean_term .)
    RCBRACKET       reduce using rule 158 (implication -> boolean_term .)
    COMMA           reduce using rule 158 (implication -> boolean_term .)
    DO              reduce using rule 158 (implication -> boolean_term .)
    OR              shift and go to state 184


state 89

    (123) arithmetic_expression -> if_clause . simple_arithmetic_expression ELSE arithmetic_expression
    (155) boolean_expression -> if_clause . simple_boolean ELSE boolean_expression
    (124) simple_arithmetic_expression -> . term
    (125) simple_arithmetic_expression -> . adding_operator term
    (126) simple_arithmetic_expression -> . simple_arithmetic_expression adding_operator term
    (156) simple_boolean -> . implication
    (157) simple_boolean -> . simple_boolean EQUIV implication
    (129) term -> . factor
    (130) term -> . term multiplying_operator factor
    (127) adding_operator -> . PLUS
    (128) adding_operator -> . MINUS
    (158) implication -> . boolean_term
    (159) implication -> . implication IMPL boolean_term
    (134) factor -> . primary
    (135) factor -> . factor
    (136) factor -> . factor POWER primary
    (160) boolean_term -> . boolean_factor
    (161) boolean_term -> . boolean_term OR boolean_factor
    (137) primary -> . unsigned_number
    (138) primary -> . variable
    (139) primary -> . function_designator
    (140) primary -> . LCBRACKET arithmetic_expression RCBRACKET
    (162) boolean_factor -> . boolean_secondary
    (163) boolean_factor -> . boolean_factor AND boolean_secondary
    (141) unsigned_number -> . decimal_number
    (142) unsigned_number -> . exponential_part
    (143) unsigned_number -> . decimal_number exponential_part
    (173) variable -> . simple_variable
    (174) variable -> . subscripted_variable
    (172) function_designator -> . procedure_identifier actual_parameter_part
    (164) boolean_secondary -> . boolean_primary
    (165) boolean_secondary -> . NOT boolean_primary
    (144) decimal_number -> . unsigned_integer
    (145) decimal_number -> . decimal_fraction
    (146) decimal_number -> . unsigned_integer decimal_fraction
    (150) exponential_part -> . EREAL integer
    (175) simple_variable -> . variable_identifier
    (177) subscripted_variable -> . array_identifier LBBRACKET subscript_list RBBRACKET
    (44) procedure_identifier -> . IDENTIFIER
    (166) boolean_primary -> . logical_value
    (167) boolean_primary -> . variable
    (168) boolean_primary -> . function_designator
    (169) boolean_primary -> . relation
    (170) boolean_primary -> . LCBRACKET boolean_expression RCBRACKET
    (147) unsigned_integer -> . DIGIT
    (148) unsigned_integer -> . unsigned_integer DIGIT
    (149) decimal_fraction -> . DOT unsigned_integer
    (176) variable_identifier -> . IDENTIFIER
    (31) array_identifier -> . IDENTIFIER
    (184) logical_value -> . TRUE
    (185) logical_value -> . FALSE
    (171) relation -> . simple_arithmetic_expression relational_operator simple_arithmetic_expression

    PLUS            shift and go to state 102
    MINUS           shift and go to state 94
    LCBRACKET       shift and go to state 116
    NOT             shift and go to state 118
    EREAL           shift and go to state 115
    IDENTIFIER      shift and go to state 106
    DIGIT           shift and go to state 6
    DOT             shift and go to state 95
    TRUE            shift and go to state 93
    FALSE           shift and go to state 100

    boolean_primary                shift and go to state 99
    procedure_identifier           shift and go to state 125
    boolean_term                   shift and go to state 88
    boolean_factor                 shift and go to state 90
    relation                       shift and go to state 91
    simple_boolean                 shift and go to state 186
    boolean_secondary              shift and go to state 101
    unsigned_number                shift and go to state 105
    decimal_fraction               shift and go to state 103
    factor                         shift and go to state 104
    simple_arithmetic_expression   shift and go to state 185
    logical_value                  shift and go to state 109
    decimal_number                 shift and go to state 112
    primary                        shift and go to state 98
    variable_identifier            shift and go to state 41
    function_designator            shift and go to state 110
    array_identifier               shift and go to state 14
    variable                       shift and go to state 161
    exponential_part               shift and go to state 92
    term                           shift and go to state 113
    subscripted_variable           shift and go to state 13
    simple_variable                shift and go to state 49
    adding_operator                shift and go to state 117
    implication                    shift and go to state 119
    unsigned_integer               shift and go to state 120

state 90

    (160) boolean_term -> boolean_factor .
    (163) boolean_factor -> boolean_factor . AND boolean_secondary

    OR              reduce using rule 160 (boolean_term -> boolean_factor .)
    IMPL            reduce using rule 160 (boolean_term -> boolean_factor .)
    ELSE            reduce using rule 160 (boolean_term -> boolean_factor .)
    EQUIV           reduce using rule 160 (boolean_term -> boolean_factor .)
    RCBRACKET       reduce using rule 160 (boolean_term -> boolean_factor .)
    END             reduce using rule 160 (boolean_term -> boolean_factor .)
    SEMICOLON       reduce using rule 160 (boolean_term -> boolean_factor .)
    THEN            reduce using rule 160 (boolean_term -> boolean_factor .)
    COMMA           reduce using rule 160 (boolean_term -> boolean_factor .)
    DO              reduce using rule 160 (boolean_term -> boolean_factor .)
    AND             shift and go to state 187


state 91

    (169) boolean_primary -> relation .

    AND             reduce using rule 169 (boolean_primary -> relation .)
    OR              reduce using rule 169 (boolean_primary -> relation .)
    IMPL            reduce using rule 169 (boolean_primary -> relation .)
    EQUIV           reduce using rule 169 (boolean_primary -> relation .)
    END             reduce using rule 169 (boolean_primary -> relation .)
    SEMICOLON       reduce using rule 169 (boolean_primary -> relation .)
    ELSE            reduce using rule 169 (boolean_primary -> relation .)
    THEN            reduce using rule 169 (boolean_primary -> relation .)
    RCBRACKET       reduce using rule 169 (boolean_primary -> relation .)
    COMMA           reduce using rule 169 (boolean_primary -> relation .)
    DO              reduce using rule 169 (boolean_primary -> relation .)


state 92

    (142) unsigned_number -> exponential_part .

    POWER           reduce using rule 142 (unsigned_number -> exponential_part .)
    TIMES           reduce using rule 142 (unsigned_number -> exponential_part .)
    DIV             reduce using rule 142 (unsigned_number -> exponential_part .)
    MOD             reduce using rule 142 (unsigned_number -> exponential_part .)
    PLUS            reduce using rule 142 (unsigned_number -> exponential_part .)
    MINUS           reduce using rule 142 (unsigned_number -> exponential_part .)
    LESS            reduce using rule 142 (unsigned_number -> exponential_part .)
    NOTGREATER      reduce using rule 142 (unsigned_number -> exponential_part .)
    EQUAL           reduce using rule 142 (unsigned_number -> exponential_part .)
    NOTLESS         reduce using rule 142 (unsigned_number -> exponential_part .)
    GREATER         reduce using rule 142 (unsigned_number -> exponential_part .)
    NOTEQUAL        reduce using rule 142 (unsigned_number -> exponential_part .)
    RCBRACKET       reduce using rule 142 (unsigned_number -> exponential_part .)
    COMMA           reduce using rule 142 (unsigned_number -> exponential_part .)
    COLON           reduce using rule 142 (unsigned_number -> exponential_part .)
    END             reduce using rule 142 (unsigned_number -> exponential_part .)
    SEMICOLON       reduce using rule 142 (unsigned_number -> exponential_part .)
    ELSE            reduce using rule 142 (unsigned_number -> exponential_part .)
    RBBRACKET       reduce using rule 142 (unsigned_number -> exponential_part .)
    STEP            reduce using rule 142 (unsigned_number -> exponential_part .)
    WHILE           reduce using rule 142 (unsigned_number -> exponential_part .)
    DO              reduce using rule 142 (unsigned_number -> exponential_part .)
    AND             reduce using rule 142 (unsigned_number -> exponential_part .)
    OR              reduce using rule 142 (unsigned_number -> exponential_part .)
    IMPL            reduce using rule 142 (unsigned_number -> exponential_part .)
    EQUIV           reduce using rule 142 (unsigned_number -> exponential_part .)
    THEN            reduce using rule 142 (unsigned_number -> exponential_part .)
    UNTIL           reduce using rule 142 (unsigned_number -> exponential_part .)


state 93

    (184) logical_value -> TRUE .

    AND             reduce using rule 184 (logical_value -> TRUE .)
    OR              reduce using rule 184 (logical_value -> TRUE .)
    IMPL            reduce using rule 184 (logical_value -> TRUE .)
    EQUIV           reduce using rule 184 (logical_value -> TRUE .)
    THEN            reduce using rule 184 (logical_value -> TRUE .)
    RCBRACKET       reduce using rule 184 (logical_value -> TRUE .)
    COMMA           reduce using rule 184 (logical_value -> TRUE .)
    DO              reduce using rule 184 (logical_value -> TRUE .)
    ELSE            reduce using rule 184 (logical_value -> TRUE .)
    END             reduce using rule 184 (logical_value -> TRUE .)
    SEMICOLON       reduce using rule 184 (logical_value -> TRUE .)


state 94

    (128) adding_operator -> MINUS .

    LCBRACKET       reduce using rule 128 (adding_operator -> MINUS .)
    EREAL           reduce using rule 128 (adding_operator -> MINUS .)
    IDENTIFIER      reduce using rule 128 (adding_operator -> MINUS .)
    DIGIT           reduce using rule 128 (adding_operator -> MINUS .)
    DOT             reduce using rule 128 (adding_operator -> MINUS .)


state 95

    (149) decimal_fraction -> DOT . unsigned_integer
    (147) unsigned_integer -> . DIGIT
    (148) unsigned_integer -> . unsigned_integer DIGIT

    DIGIT           shift and go to state 6

    unsigned_integer               shift and go to state 188

state 96

    (83) left_part_list -> left_part_list left_part .

    IF              reduce using rule 83 (left_part_list -> left_part_list left_part .)
    IDENTIFIER      reduce using rule 83 (left_part_list -> left_part_list left_part .)
    PLUS            reduce using rule 83 (left_part_list -> left_part_list left_part .)
    MINUS           reduce using rule 83 (left_part_list -> left_part_list left_part .)
    LCBRACKET       reduce using rule 83 (left_part_list -> left_part_list left_part .)
    NOT             reduce using rule 83 (left_part_list -> left_part_list left_part .)
    EREAL           reduce using rule 83 (left_part_list -> left_part_list left_part .)
    DIGIT           reduce using rule 83 (left_part_list -> left_part_list left_part .)
    DOT             reduce using rule 83 (left_part_list -> left_part_list left_part .)
    TRUE            reduce using rule 83 (left_part_list -> left_part_list left_part .)
    FALSE           reduce using rule 83 (left_part_list -> left_part_list left_part .)


state 97

    (154) boolean_expression -> simple_boolean .
    (157) simple_boolean -> simple_boolean . EQUIV implication

    END             reduce using rule 154 (boolean_expression -> simple_boolean .)
    SEMICOLON       reduce using rule 154 (boolean_expression -> simple_boolean .)
    ELSE            reduce using rule 154 (boolean_expression -> simple_boolean .)
    THEN            reduce using rule 154 (boolean_expression -> simple_boolean .)
    DO              reduce using rule 154 (boolean_expression -> simple_boolean .)
    COMMA           reduce using rule 154 (boolean_expression -> simple_boolean .)
    RCBRACKET       reduce using rule 154 (boolean_expression -> simple_boolean .)
    EQUIV           shift and go to state 189


state 98

    (134) factor -> primary .

    POWER           reduce using rule 134 (factor -> primary .)
    TIMES           reduce using rule 134 (factor -> primary .)
    DIV             reduce using rule 134 (factor -> primary .)
    MOD             reduce using rule 134 (factor -> primary .)
    PLUS            reduce using rule 134 (factor -> primary .)
    MINUS           reduce using rule 134 (factor -> primary .)
    STEP            reduce using rule 134 (factor -> primary .)
    WHILE           reduce using rule 134 (factor -> primary .)
    DO              reduce using rule 134 (factor -> primary .)
    COMMA           reduce using rule 134 (factor -> primary .)
    UNTIL           reduce using rule 134 (factor -> primary .)
    LESS            reduce using rule 134 (factor -> primary .)
    NOTGREATER      reduce using rule 134 (factor -> primary .)
    EQUAL           reduce using rule 134 (factor -> primary .)
    NOTLESS         reduce using rule 134 (factor -> primary .)
    GREATER         reduce using rule 134 (factor -> primary .)
    NOTEQUAL        reduce using rule 134 (factor -> primary .)
    RCBRACKET       reduce using rule 134 (factor -> primary .)
    COLON           reduce using rule 134 (factor -> primary .)
    AND             reduce using rule 134 (factor -> primary .)
    OR              reduce using rule 134 (factor -> primary .)
    IMPL            reduce using rule 134 (factor -> primary .)
    EQUIV           reduce using rule 134 (factor -> primary .)
    END             reduce using rule 134 (factor -> primary .)
    SEMICOLON       reduce using rule 134 (factor -> primary .)
    ELSE            reduce using rule 134 (factor -> primary .)
    THEN            reduce using rule 134 (factor -> primary .)
    RBBRACKET       reduce using rule 134 (factor -> primary .)


state 99

    (164) boolean_secondary -> boolean_primary .

    AND             reduce using rule 164 (boolean_secondary -> boolean_primary .)
    OR              reduce using rule 164 (boolean_secondary -> boolean_primary .)
    IMPL            reduce using rule 164 (boolean_secondary -> boolean_primary .)
    ELSE            reduce using rule 164 (boolean_secondary -> boolean_primary .)
    EQUIV           reduce using rule 164 (boolean_secondary -> boolean_primary .)
    DO              reduce using rule 164 (boolean_secondary -> boolean_primary .)
    COMMA           reduce using rule 164 (boolean_secondary -> boolean_primary .)
    RCBRACKET       reduce using rule 164 (boolean_secondary -> boolean_primary .)
    END             reduce using rule 164 (boolean_secondary -> boolean_primary .)
    SEMICOLON       reduce using rule 164 (boolean_secondary -> boolean_primary .)
    THEN            reduce using rule 164 (boolean_secondary -> boolean_primary .)


state 100

    (185) logical_value -> FALSE .

    AND             reduce using rule 185 (logical_value -> FALSE .)
    OR              reduce using rule 185 (logical_value -> FALSE .)
    IMPL            reduce using rule 185 (logical_value -> FALSE .)
    EQUIV           reduce using rule 185 (logical_value -> FALSE .)
    THEN            reduce using rule 185 (logical_value -> FALSE .)
    RCBRACKET       reduce using rule 185 (logical_value -> FALSE .)
    COMMA           reduce using rule 185 (logical_value -> FALSE .)
    DO              reduce using rule 185 (logical_value -> FALSE .)
    ELSE            reduce using rule 185 (logical_value -> FALSE .)
    END             reduce using rule 185 (logical_value -> FALSE .)
    SEMICOLON       reduce using rule 185 (logical_value -> FALSE .)


state 101

    (162) boolean_factor -> boolean_secondary .

    AND             reduce using rule 162 (boolean_factor -> boolean_secondary .)
    OR              reduce using rule 162 (boolean_factor -> boolean_secondary .)
    IMPL            reduce using rule 162 (boolean_factor -> boolean_secondary .)
    ELSE            reduce using rule 162 (boolean_factor -> boolean_secondary .)
    EQUIV           reduce using rule 162 (boolean_factor -> boolean_secondary .)
    END             reduce using rule 162 (boolean_factor -> boolean_secondary .)
    SEMICOLON       reduce using rule 162 (boolean_factor -> boolean_secondary .)
    RCBRACKET       reduce using rule 162 (boolean_factor -> boolean_secondary .)
    THEN            reduce using rule 162 (boolean_factor -> boolean_secondary .)
    COMMA           reduce using rule 162 (boolean_factor -> boolean_secondary .)
    DO              reduce using rule 162 (boolean_factor -> boolean_secondary .)


state 102

    (127) adding_operator -> PLUS .

    LCBRACKET       reduce using rule 127 (adding_operator -> PLUS .)
    EREAL           reduce using rule 127 (adding_operator -> PLUS .)
    IDENTIFIER      reduce using rule 127 (adding_operator -> PLUS .)
    DIGIT           reduce using rule 127 (adding_operator -> PLUS .)
    DOT             reduce using rule 127 (adding_operator -> PLUS .)


state 103

    (145) decimal_number -> decimal_fraction .

    EREAL           reduce using rule 145 (decimal_number -> decimal_fraction .)
    POWER           reduce using rule 145 (decimal_number -> decimal_fraction .)
    TIMES           reduce using rule 145 (decimal_number -> decimal_fraction .)
    DIV             reduce using rule 145 (decimal_number -> decimal_fraction .)
    MOD             reduce using rule 145 (decimal_number -> decimal_fraction .)
    LESS            reduce using rule 145 (decimal_number -> decimal_fraction .)
    NOTGREATER      reduce using rule 145 (decimal_number -> decimal_fraction .)
    EQUAL           reduce using rule 145 (decimal_number -> decimal_fraction .)
    NOTLESS         reduce using rule 145 (decimal_number -> decimal_fraction .)
    GREATER         reduce using rule 145 (decimal_number -> decimal_fraction .)
    NOTEQUAL        reduce using rule 145 (decimal_number -> decimal_fraction .)
    PLUS            reduce using rule 145 (decimal_number -> decimal_fraction .)
    MINUS           reduce using rule 145 (decimal_number -> decimal_fraction .)
    END             reduce using rule 145 (decimal_number -> decimal_fraction .)
    SEMICOLON       reduce using rule 145 (decimal_number -> decimal_fraction .)
    ELSE            reduce using rule 145 (decimal_number -> decimal_fraction .)
    RBBRACKET       reduce using rule 145 (decimal_number -> decimal_fraction .)
    COMMA           reduce using rule 145 (decimal_number -> decimal_fraction .)
    RCBRACKET       reduce using rule 145 (decimal_number -> decimal_fraction .)
    COLON           reduce using rule 145 (decimal_number -> decimal_fraction .)
    STEP            reduce using rule 145 (decimal_number -> decimal_fraction .)
    WHILE           reduce using rule 145 (decimal_number -> decimal_fraction .)
    DO              reduce using rule 145 (decimal_number -> decimal_fraction .)
    AND             reduce using rule 145 (decimal_number -> decimal_fraction .)
    OR              reduce using rule 145 (decimal_number -> decimal_fraction .)
    IMPL            reduce using rule 145 (decimal_number -> decimal_fraction .)
    EQUIV           reduce using rule 145 (decimal_number -> decimal_fraction .)
    THEN            reduce using rule 145 (decimal_number -> decimal_fraction .)
    UNTIL           reduce using rule 145 (decimal_number -> decimal_fraction .)


state 104

    (129) term -> factor .
    (135) factor -> factor .
    (136) factor -> factor . POWER primary

  ! reduce/reduce conflict for TIMES resolved using rule 129 (term -> factor .)
  ! reduce/reduce conflict for DIV resolved using rule 129 (term -> factor .)
  ! reduce/reduce conflict for MOD resolved using rule 129 (term -> factor .)
  ! reduce/reduce conflict for PLUS resolved using rule 129 (term -> factor .)
  ! reduce/reduce conflict for MINUS resolved using rule 129 (term -> factor .)
  ! reduce/reduce conflict for STEP resolved using rule 129 (term -> factor .)
  ! reduce/reduce conflict for WHILE resolved using rule 129 (term -> factor .)
  ! reduce/reduce conflict for DO resolved using rule 129 (term -> factor .)
  ! reduce/reduce conflict for COMMA resolved using rule 129 (term -> factor .)
  ! reduce/reduce conflict for UNTIL resolved using rule 129 (term -> factor .)
  ! reduce/reduce conflict for LESS resolved using rule 129 (term -> factor .)
  ! reduce/reduce conflict for NOTGREATER resolved using rule 129 (term -> factor .)
  ! reduce/reduce conflict for EQUAL resolved using rule 129 (term -> factor .)
  ! reduce/reduce conflict for NOTLESS resolved using rule 129 (term -> factor .)
  ! reduce/reduce conflict for GREATER resolved using rule 129 (term -> factor .)
  ! reduce/reduce conflict for NOTEQUAL resolved using rule 129 (term -> factor .)
  ! reduce/reduce conflict for RCBRACKET resolved using rule 129 (term -> factor .)
  ! reduce/reduce conflict for COLON resolved using rule 129 (term -> factor .)
  ! reduce/reduce conflict for AND resolved using rule 129 (term -> factor .)
  ! reduce/reduce conflict for OR resolved using rule 129 (term -> factor .)
  ! reduce/reduce conflict for IMPL resolved using rule 129 (term -> factor .)
  ! reduce/reduce conflict for EQUIV resolved using rule 129 (term -> factor .)
  ! reduce/reduce conflict for END resolved using rule 129 (term -> factor .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 129 (term -> factor .)
  ! reduce/reduce conflict for ELSE resolved using rule 129 (term -> factor .)
  ! reduce/reduce conflict for THEN resolved using rule 129 (term -> factor .)
  ! reduce/reduce conflict for RBBRACKET resolved using rule 129 (term -> factor .)
  ! shift/reduce conflict for POWER resolved as shift
    TIMES           reduce using rule 129 (term -> factor .)
    DIV             reduce using rule 129 (term -> factor .)
    MOD             reduce using rule 129 (term -> factor .)
    ELSE            reduce using rule 129 (term -> factor .)
    PLUS            reduce using rule 129 (term -> factor .)
    MINUS           reduce using rule 129 (term -> factor .)
    LESS            reduce using rule 129 (term -> factor .)
    NOTGREATER      reduce using rule 129 (term -> factor .)
    EQUAL           reduce using rule 129 (term -> factor .)
    NOTLESS         reduce using rule 129 (term -> factor .)
    GREATER         reduce using rule 129 (term -> factor .)
    NOTEQUAL        reduce using rule 129 (term -> factor .)
    RCBRACKET       reduce using rule 129 (term -> factor .)
    END             reduce using rule 129 (term -> factor .)
    SEMICOLON       reduce using rule 129 (term -> factor .)
    RBBRACKET       reduce using rule 129 (term -> factor .)
    COMMA           reduce using rule 129 (term -> factor .)
    COLON           reduce using rule 129 (term -> factor .)
    STEP            reduce using rule 129 (term -> factor .)
    WHILE           reduce using rule 129 (term -> factor .)
    DO              reduce using rule 129 (term -> factor .)
    AND             reduce using rule 129 (term -> factor .)
    OR              reduce using rule 129 (term -> factor .)
    IMPL            reduce using rule 129 (term -> factor .)
    EQUIV           reduce using rule 129 (term -> factor .)
    THEN            reduce using rule 129 (term -> factor .)
    UNTIL           reduce using rule 129 (term -> factor .)
    POWER           shift and go to state 190

  ! POWER           [ reduce using rule 135 (factor -> factor .) ]
  ! TIMES           [ reduce using rule 135 (factor -> factor .) ]
  ! DIV             [ reduce using rule 135 (factor -> factor .) ]
  ! MOD             [ reduce using rule 135 (factor -> factor .) ]
  ! PLUS            [ reduce using rule 135 (factor -> factor .) ]
  ! MINUS           [ reduce using rule 135 (factor -> factor .) ]
  ! STEP            [ reduce using rule 135 (factor -> factor .) ]
  ! WHILE           [ reduce using rule 135 (factor -> factor .) ]
  ! DO              [ reduce using rule 135 (factor -> factor .) ]
  ! COMMA           [ reduce using rule 135 (factor -> factor .) ]
  ! UNTIL           [ reduce using rule 135 (factor -> factor .) ]
  ! LESS            [ reduce using rule 135 (factor -> factor .) ]
  ! NOTGREATER      [ reduce using rule 135 (factor -> factor .) ]
  ! EQUAL           [ reduce using rule 135 (factor -> factor .) ]
  ! NOTLESS         [ reduce using rule 135 (factor -> factor .) ]
  ! GREATER         [ reduce using rule 135 (factor -> factor .) ]
  ! NOTEQUAL        [ reduce using rule 135 (factor -> factor .) ]
  ! RCBRACKET       [ reduce using rule 135 (factor -> factor .) ]
  ! COLON           [ reduce using rule 135 (factor -> factor .) ]
  ! AND             [ reduce using rule 135 (factor -> factor .) ]
  ! OR              [ reduce using rule 135 (factor -> factor .) ]
  ! IMPL            [ reduce using rule 135 (factor -> factor .) ]
  ! EQUIV           [ reduce using rule 135 (factor -> factor .) ]
  ! END             [ reduce using rule 135 (factor -> factor .) ]
  ! SEMICOLON       [ reduce using rule 135 (factor -> factor .) ]
  ! ELSE            [ reduce using rule 135 (factor -> factor .) ]
  ! THEN            [ reduce using rule 135 (factor -> factor .) ]
  ! RBBRACKET       [ reduce using rule 135 (factor -> factor .) ]


state 105

    (137) primary -> unsigned_number .

    POWER           reduce using rule 137 (primary -> unsigned_number .)
    TIMES           reduce using rule 137 (primary -> unsigned_number .)
    DIV             reduce using rule 137 (primary -> unsigned_number .)
    MOD             reduce using rule 137 (primary -> unsigned_number .)
    PLUS            reduce using rule 137 (primary -> unsigned_number .)
    MINUS           reduce using rule 137 (primary -> unsigned_number .)
    LESS            reduce using rule 137 (primary -> unsigned_number .)
    NOTGREATER      reduce using rule 137 (primary -> unsigned_number .)
    EQUAL           reduce using rule 137 (primary -> unsigned_number .)
    NOTLESS         reduce using rule 137 (primary -> unsigned_number .)
    GREATER         reduce using rule 137 (primary -> unsigned_number .)
    NOTEQUAL        reduce using rule 137 (primary -> unsigned_number .)
    RCBRACKET       reduce using rule 137 (primary -> unsigned_number .)
    ELSE            reduce using rule 137 (primary -> unsigned_number .)
    STEP            reduce using rule 137 (primary -> unsigned_number .)
    WHILE           reduce using rule 137 (primary -> unsigned_number .)
    DO              reduce using rule 137 (primary -> unsigned_number .)
    COMMA           reduce using rule 137 (primary -> unsigned_number .)
    COLON           reduce using rule 137 (primary -> unsigned_number .)
    END             reduce using rule 137 (primary -> unsigned_number .)
    SEMICOLON       reduce using rule 137 (primary -> unsigned_number .)
    RBBRACKET       reduce using rule 137 (primary -> unsigned_number .)
    UNTIL           reduce using rule 137 (primary -> unsigned_number .)
    AND             reduce using rule 137 (primary -> unsigned_number .)
    OR              reduce using rule 137 (primary -> unsigned_number .)
    IMPL            reduce using rule 137 (primary -> unsigned_number .)
    EQUIV           reduce using rule 137 (primary -> unsigned_number .)
    THEN            reduce using rule 137 (primary -> unsigned_number .)


state 106

    (44) procedure_identifier -> IDENTIFIER .
    (176) variable_identifier -> IDENTIFIER .
    (31) array_identifier -> IDENTIFIER .

  ! reduce/reduce conflict for POWER resolved using rule 44 (procedure_identifier -> IDENTIFIER .)
  ! reduce/reduce conflict for TIMES resolved using rule 44 (procedure_identifier -> IDENTIFIER .)
  ! reduce/reduce conflict for DIV resolved using rule 44 (procedure_identifier -> IDENTIFIER .)
  ! reduce/reduce conflict for MOD resolved using rule 44 (procedure_identifier -> IDENTIFIER .)
  ! reduce/reduce conflict for PLUS resolved using rule 44 (procedure_identifier -> IDENTIFIER .)
  ! reduce/reduce conflict for MINUS resolved using rule 44 (procedure_identifier -> IDENTIFIER .)
  ! reduce/reduce conflict for LESS resolved using rule 44 (procedure_identifier -> IDENTIFIER .)
  ! reduce/reduce conflict for NOTGREATER resolved using rule 44 (procedure_identifier -> IDENTIFIER .)
  ! reduce/reduce conflict for EQUAL resolved using rule 44 (procedure_identifier -> IDENTIFIER .)
  ! reduce/reduce conflict for NOTLESS resolved using rule 44 (procedure_identifier -> IDENTIFIER .)
  ! reduce/reduce conflict for GREATER resolved using rule 44 (procedure_identifier -> IDENTIFIER .)
  ! reduce/reduce conflict for NOTEQUAL resolved using rule 44 (procedure_identifier -> IDENTIFIER .)
  ! reduce/reduce conflict for END resolved using rule 44 (procedure_identifier -> IDENTIFIER .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 44 (procedure_identifier -> IDENTIFIER .)
  ! reduce/reduce conflict for ELSE resolved using rule 44 (procedure_identifier -> IDENTIFIER .)
  ! reduce/reduce conflict for RBBRACKET resolved using rule 44 (procedure_identifier -> IDENTIFIER .)
  ! reduce/reduce conflict for COMMA resolved using rule 44 (procedure_identifier -> IDENTIFIER .)
  ! reduce/reduce conflict for RCBRACKET resolved using rule 44 (procedure_identifier -> IDENTIFIER .)
  ! reduce/reduce conflict for COLON resolved using rule 44 (procedure_identifier -> IDENTIFIER .)
  ! reduce/reduce conflict for STEP resolved using rule 44 (procedure_identifier -> IDENTIFIER .)
  ! reduce/reduce conflict for WHILE resolved using rule 44 (procedure_identifier -> IDENTIFIER .)
  ! reduce/reduce conflict for DO resolved using rule 44 (procedure_identifier -> IDENTIFIER .)
  ! reduce/reduce conflict for AND resolved using rule 44 (procedure_identifier -> IDENTIFIER .)
  ! reduce/reduce conflict for OR resolved using rule 44 (procedure_identifier -> IDENTIFIER .)
  ! reduce/reduce conflict for IMPL resolved using rule 44 (procedure_identifier -> IDENTIFIER .)
  ! reduce/reduce conflict for EQUIV resolved using rule 44 (procedure_identifier -> IDENTIFIER .)
  ! reduce/reduce conflict for THEN resolved using rule 44 (procedure_identifier -> IDENTIFIER .)
  ! reduce/reduce conflict for UNTIL resolved using rule 44 (procedure_identifier -> IDENTIFIER .)
  ! reduce/reduce conflict for ASSIGNMENT resolved using rule 44 (procedure_identifier -> IDENTIFIER .)
    LCBRACKET       reduce using rule 44 (procedure_identifier -> IDENTIFIER .)
    AND             reduce using rule 44 (procedure_identifier -> IDENTIFIER .)
    OR              reduce using rule 44 (procedure_identifier -> IDENTIFIER .)
    IMPL            reduce using rule 44 (procedure_identifier -> IDENTIFIER .)
    EQUIV           reduce using rule 44 (procedure_identifier -> IDENTIFIER .)
    END             reduce using rule 44 (procedure_identifier -> IDENTIFIER .)
    SEMICOLON       reduce using rule 44 (procedure_identifier -> IDENTIFIER .)
    ELSE            reduce using rule 44 (procedure_identifier -> IDENTIFIER .)
    THEN            reduce using rule 44 (procedure_identifier -> IDENTIFIER .)
    RCBRACKET       reduce using rule 44 (procedure_identifier -> IDENTIFIER .)
    COMMA           reduce using rule 44 (procedure_identifier -> IDENTIFIER .)
    DO              reduce using rule 44 (procedure_identifier -> IDENTIFIER .)
    POWER           reduce using rule 44 (procedure_identifier -> IDENTIFIER .)
    TIMES           reduce using rule 44 (procedure_identifier -> IDENTIFIER .)
    DIV             reduce using rule 44 (procedure_identifier -> IDENTIFIER .)
    MOD             reduce using rule 44 (procedure_identifier -> IDENTIFIER .)
    LESS            reduce using rule 44 (procedure_identifier -> IDENTIFIER .)
    NOTGREATER      reduce using rule 44 (procedure_identifier -> IDENTIFIER .)
    EQUAL           reduce using rule 44 (procedure_identifier -> IDENTIFIER .)
    NOTLESS         reduce using rule 44 (procedure_identifier -> IDENTIFIER .)
    GREATER         reduce using rule 44 (procedure_identifier -> IDENTIFIER .)
    NOTEQUAL        reduce using rule 44 (procedure_identifier -> IDENTIFIER .)
    PLUS            reduce using rule 44 (procedure_identifier -> IDENTIFIER .)
    MINUS           reduce using rule 44 (procedure_identifier -> IDENTIFIER .)
    RBBRACKET       reduce using rule 44 (procedure_identifier -> IDENTIFIER .)
    COLON           reduce using rule 44 (procedure_identifier -> IDENTIFIER .)
    STEP            reduce using rule 44 (procedure_identifier -> IDENTIFIER .)
    WHILE           reduce using rule 44 (procedure_identifier -> IDENTIFIER .)
    UNTIL           reduce using rule 44 (procedure_identifier -> IDENTIFIER .)
    ASSIGNMENT      reduce using rule 44 (procedure_identifier -> IDENTIFIER .)
    LBBRACKET       reduce using rule 31 (array_identifier -> IDENTIFIER .)

  ! POWER           [ reduce using rule 176 (variable_identifier -> IDENTIFIER .) ]
  ! TIMES           [ reduce using rule 176 (variable_identifier -> IDENTIFIER .) ]
  ! DIV             [ reduce using rule 176 (variable_identifier -> IDENTIFIER .) ]
  ! MOD             [ reduce using rule 176 (variable_identifier -> IDENTIFIER .) ]
  ! PLUS            [ reduce using rule 176 (variable_identifier -> IDENTIFIER .) ]
  ! MINUS           [ reduce using rule 176 (variable_identifier -> IDENTIFIER .) ]
  ! LESS            [ reduce using rule 176 (variable_identifier -> IDENTIFIER .) ]
  ! NOTGREATER      [ reduce using rule 176 (variable_identifier -> IDENTIFIER .) ]
  ! EQUAL           [ reduce using rule 176 (variable_identifier -> IDENTIFIER .) ]
  ! NOTLESS         [ reduce using rule 176 (variable_identifier -> IDENTIFIER .) ]
  ! GREATER         [ reduce using rule 176 (variable_identifier -> IDENTIFIER .) ]
  ! NOTEQUAL        [ reduce using rule 176 (variable_identifier -> IDENTIFIER .) ]
  ! END             [ reduce using rule 176 (variable_identifier -> IDENTIFIER .) ]
  ! SEMICOLON       [ reduce using rule 176 (variable_identifier -> IDENTIFIER .) ]
  ! ELSE            [ reduce using rule 176 (variable_identifier -> IDENTIFIER .) ]
  ! RBBRACKET       [ reduce using rule 176 (variable_identifier -> IDENTIFIER .) ]
  ! COMMA           [ reduce using rule 176 (variable_identifier -> IDENTIFIER .) ]
  ! RCBRACKET       [ reduce using rule 176 (variable_identifier -> IDENTIFIER .) ]
  ! COLON           [ reduce using rule 176 (variable_identifier -> IDENTIFIER .) ]
  ! STEP            [ reduce using rule 176 (variable_identifier -> IDENTIFIER .) ]
  ! WHILE           [ reduce using rule 176 (variable_identifier -> IDENTIFIER .) ]
  ! DO              [ reduce using rule 176 (variable_identifier -> IDENTIFIER .) ]
  ! AND             [ reduce using rule 176 (variable_identifier -> IDENTIFIER .) ]
  ! OR              [ reduce using rule 176 (variable_identifier -> IDENTIFIER .) ]
  ! IMPL            [ reduce using rule 176 (variable_identifier -> IDENTIFIER .) ]
  ! EQUIV           [ reduce using rule 176 (variable_identifier -> IDENTIFIER .) ]
  ! THEN            [ reduce using rule 176 (variable_identifier -> IDENTIFIER .) ]
  ! UNTIL           [ reduce using rule 176 (variable_identifier -> IDENTIFIER .) ]
  ! ASSIGNMENT      [ reduce using rule 176 (variable_identifier -> IDENTIFIER .) ]


state 107

    (122) arithmetic_expression -> simple_arithmetic_expression .
    (126) simple_arithmetic_expression -> simple_arithmetic_expression . adding_operator term
    (171) relation -> simple_arithmetic_expression . relational_operator simple_arithmetic_expression
    (127) adding_operator -> . PLUS
    (128) adding_operator -> . MINUS
    (186) relational_operator -> . LESS
    (187) relational_operator -> . NOTGREATER
    (188) relational_operator -> . EQUAL
    (189) relational_operator -> . NOTLESS
    (190) relational_operator -> . GREATER
    (191) relational_operator -> . NOTEQUAL

    RCBRACKET       reduce using rule 122 (arithmetic_expression -> simple_arithmetic_expression .)
    COMMA           reduce using rule 122 (arithmetic_expression -> simple_arithmetic_expression .)
    END             reduce using rule 122 (arithmetic_expression -> simple_arithmetic_expression .)
    SEMICOLON       reduce using rule 122 (arithmetic_expression -> simple_arithmetic_expression .)
    ELSE            reduce using rule 122 (arithmetic_expression -> simple_arithmetic_expression .)
    PLUS            shift and go to state 102
    MINUS           shift and go to state 94
    LESS            shift and go to state 193
    NOTGREATER      shift and go to state 198
    EQUAL           shift and go to state 194
    NOTLESS         shift and go to state 197
    GREATER         shift and go to state 196
    NOTEQUAL        shift and go to state 191

    adding_operator                shift and go to state 195
    relational_operator            shift and go to state 192

state 108

    (80) assignment_statement -> left_part_list arithmetic_expression .

    END             reduce using rule 80 (assignment_statement -> left_part_list arithmetic_expression .)
    SEMICOLON       reduce using rule 80 (assignment_statement -> left_part_list arithmetic_expression .)
    ELSE            reduce using rule 80 (assignment_statement -> left_part_list arithmetic_expression .)


state 109

    (166) boolean_primary -> logical_value .

    AND             reduce using rule 166 (boolean_primary -> logical_value .)
    OR              reduce using rule 166 (boolean_primary -> logical_value .)
    IMPL            reduce using rule 166 (boolean_primary -> logical_value .)
    EQUIV           reduce using rule 166 (boolean_primary -> logical_value .)
    END             reduce using rule 166 (boolean_primary -> logical_value .)
    SEMICOLON       reduce using rule 166 (boolean_primary -> logical_value .)
    ELSE            reduce using rule 166 (boolean_primary -> logical_value .)
    THEN            reduce using rule 166 (boolean_primary -> logical_value .)
    RCBRACKET       reduce using rule 166 (boolean_primary -> logical_value .)
    COMMA           reduce using rule 166 (boolean_primary -> logical_value .)
    DO              reduce using rule 166 (boolean_primary -> logical_value .)


state 110

    (139) primary -> function_designator .
    (168) boolean_primary -> function_designator .

  ! reduce/reduce conflict for ELSE resolved using rule 139 (primary -> function_designator .)
  ! reduce/reduce conflict for RCBRACKET resolved using rule 139 (primary -> function_designator .)
  ! reduce/reduce conflict for COMMA resolved using rule 139 (primary -> function_designator .)
  ! reduce/reduce conflict for END resolved using rule 139 (primary -> function_designator .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 139 (primary -> function_designator .)
    POWER           reduce using rule 139 (primary -> function_designator .)
    TIMES           reduce using rule 139 (primary -> function_designator .)
    DIV             reduce using rule 139 (primary -> function_designator .)
    MOD             reduce using rule 139 (primary -> function_designator .)
    PLUS            reduce using rule 139 (primary -> function_designator .)
    MINUS           reduce using rule 139 (primary -> function_designator .)
    LESS            reduce using rule 139 (primary -> function_designator .)
    NOTGREATER      reduce using rule 139 (primary -> function_designator .)
    EQUAL           reduce using rule 139 (primary -> function_designator .)
    NOTLESS         reduce using rule 139 (primary -> function_designator .)
    GREATER         reduce using rule 139 (primary -> function_designator .)
    NOTEQUAL        reduce using rule 139 (primary -> function_designator .)
    RCBRACKET       reduce using rule 139 (primary -> function_designator .)
    ELSE            reduce using rule 139 (primary -> function_designator .)
    COMMA           reduce using rule 139 (primary -> function_designator .)
    END             reduce using rule 139 (primary -> function_designator .)
    SEMICOLON       reduce using rule 139 (primary -> function_designator .)
    AND             reduce using rule 168 (boolean_primary -> function_designator .)
    OR              reduce using rule 168 (boolean_primary -> function_designator .)
    IMPL            reduce using rule 168 (boolean_primary -> function_designator .)
    EQUIV           reduce using rule 168 (boolean_primary -> function_designator .)

  ! ELSE            [ reduce using rule 168 (boolean_primary -> function_designator .) ]
  ! RCBRACKET       [ reduce using rule 168 (boolean_primary -> function_designator .) ]
  ! COMMA           [ reduce using rule 168 (boolean_primary -> function_designator .) ]
  ! END             [ reduce using rule 168 (boolean_primary -> function_designator .) ]
  ! SEMICOLON       [ reduce using rule 168 (boolean_primary -> function_designator .) ]


state 111

    (84) left_part -> variable . ASSIGNMENT
    (138) primary -> variable .
    (167) boolean_primary -> variable .

  ! reduce/reduce conflict for END resolved using rule 138 (primary -> variable .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 138 (primary -> variable .)
  ! reduce/reduce conflict for ELSE resolved using rule 138 (primary -> variable .)
    ASSIGNMENT      shift and go to state 121
    POWER           reduce using rule 138 (primary -> variable .)
    TIMES           reduce using rule 138 (primary -> variable .)
    DIV             reduce using rule 138 (primary -> variable .)
    MOD             reduce using rule 138 (primary -> variable .)
    PLUS            reduce using rule 138 (primary -> variable .)
    MINUS           reduce using rule 138 (primary -> variable .)
    LESS            reduce using rule 138 (primary -> variable .)
    NOTGREATER      reduce using rule 138 (primary -> variable .)
    EQUAL           reduce using rule 138 (primary -> variable .)
    NOTLESS         reduce using rule 138 (primary -> variable .)
    GREATER         reduce using rule 138 (primary -> variable .)
    NOTEQUAL        reduce using rule 138 (primary -> variable .)
    END             reduce using rule 138 (primary -> variable .)
    SEMICOLON       reduce using rule 138 (primary -> variable .)
    ELSE            reduce using rule 138 (primary -> variable .)
    AND             reduce using rule 167 (boolean_primary -> variable .)
    OR              reduce using rule 167 (boolean_primary -> variable .)
    IMPL            reduce using rule 167 (boolean_primary -> variable .)
    EQUIV           reduce using rule 167 (boolean_primary -> variable .)

  ! END             [ reduce using rule 167 (boolean_primary -> variable .) ]
  ! SEMICOLON       [ reduce using rule 167 (boolean_primary -> variable .) ]
  ! ELSE            [ reduce using rule 167 (boolean_primary -> variable .) ]


state 112

    (141) unsigned_number -> decimal_number .
    (143) unsigned_number -> decimal_number . exponential_part
    (150) exponential_part -> . EREAL integer

    POWER           reduce using rule 141 (unsigned_number -> decimal_number .)
    TIMES           reduce using rule 141 (unsigned_number -> decimal_number .)
    DIV             reduce using rule 141 (unsigned_number -> decimal_number .)
    MOD             reduce using rule 141 (unsigned_number -> decimal_number .)
    PLUS            reduce using rule 141 (unsigned_number -> decimal_number .)
    MINUS           reduce using rule 141 (unsigned_number -> decimal_number .)
    LESS            reduce using rule 141 (unsigned_number -> decimal_number .)
    NOTGREATER      reduce using rule 141 (unsigned_number -> decimal_number .)
    EQUAL           reduce using rule 141 (unsigned_number -> decimal_number .)
    NOTLESS         reduce using rule 141 (unsigned_number -> decimal_number .)
    GREATER         reduce using rule 141 (unsigned_number -> decimal_number .)
    NOTEQUAL        reduce using rule 141 (unsigned_number -> decimal_number .)
    RCBRACKET       reduce using rule 141 (unsigned_number -> decimal_number .)
    COMMA           reduce using rule 141 (unsigned_number -> decimal_number .)
    COLON           reduce using rule 141 (unsigned_number -> decimal_number .)
    END             reduce using rule 141 (unsigned_number -> decimal_number .)
    SEMICOLON       reduce using rule 141 (unsigned_number -> decimal_number .)
    ELSE            reduce using rule 141 (unsigned_number -> decimal_number .)
    RBBRACKET       reduce using rule 141 (unsigned_number -> decimal_number .)
    STEP            reduce using rule 141 (unsigned_number -> decimal_number .)
    WHILE           reduce using rule 141 (unsigned_number -> decimal_number .)
    DO              reduce using rule 141 (unsigned_number -> decimal_number .)
    AND             reduce using rule 141 (unsigned_number -> decimal_number .)
    OR              reduce using rule 141 (unsigned_number -> decimal_number .)
    IMPL            reduce using rule 141 (unsigned_number -> decimal_number .)
    EQUIV           reduce using rule 141 (unsigned_number -> decimal_number .)
    THEN            reduce using rule 141 (unsigned_number -> decimal_number .)
    UNTIL           reduce using rule 141 (unsigned_number -> decimal_number .)
    EREAL           shift and go to state 115

    exponential_part               shift and go to state 199

state 113

    (124) simple_arithmetic_expression -> term .
    (130) term -> term . multiplying_operator factor
    (131) multiplying_operator -> . TIMES
    (132) multiplying_operator -> . DIV
    (133) multiplying_operator -> . MOD

    PLUS            reduce using rule 124 (simple_arithmetic_expression -> term .)
    MINUS           reduce using rule 124 (simple_arithmetic_expression -> term .)
    LESS            reduce using rule 124 (simple_arithmetic_expression -> term .)
    NOTGREATER      reduce using rule 124 (simple_arithmetic_expression -> term .)
    EQUAL           reduce using rule 124 (simple_arithmetic_expression -> term .)
    NOTLESS         reduce using rule 124 (simple_arithmetic_expression -> term .)
    GREATER         reduce using rule 124 (simple_arithmetic_expression -> term .)
    NOTEQUAL        reduce using rule 124 (simple_arithmetic_expression -> term .)
    RCBRACKET       reduce using rule 124 (simple_arithmetic_expression -> term .)
    RBBRACKET       reduce using rule 124 (simple_arithmetic_expression -> term .)
    COMMA           reduce using rule 124 (simple_arithmetic_expression -> term .)
    ELSE            reduce using rule 124 (simple_arithmetic_expression -> term .)
    END             reduce using rule 124 (simple_arithmetic_expression -> term .)
    SEMICOLON       reduce using rule 124 (simple_arithmetic_expression -> term .)
    AND             reduce using rule 124 (simple_arithmetic_expression -> term .)
    OR              reduce using rule 124 (simple_arithmetic_expression -> term .)
    IMPL            reduce using rule 124 (simple_arithmetic_expression -> term .)
    EQUIV           reduce using rule 124 (simple_arithmetic_expression -> term .)
    THEN            reduce using rule 124 (simple_arithmetic_expression -> term .)
    DO              reduce using rule 124 (simple_arithmetic_expression -> term .)
    STEP            reduce using rule 124 (simple_arithmetic_expression -> term .)
    WHILE           reduce using rule 124 (simple_arithmetic_expression -> term .)
    COLON           reduce using rule 124 (simple_arithmetic_expression -> term .)
    UNTIL           reduce using rule 124 (simple_arithmetic_expression -> term .)
    TIMES           shift and go to state 200
    DIV             shift and go to state 201
    MOD             shift and go to state 203

    multiplying_operator           shift and go to state 202

state 114

    (81) assignment_statement -> left_part_list boolean_expression .

    END             reduce using rule 81 (assignment_statement -> left_part_list boolean_expression .)
    SEMICOLON       reduce using rule 81 (assignment_statement -> left_part_list boolean_expression .)
    ELSE            reduce using rule 81 (assignment_statement -> left_part_list boolean_expression .)


state 115

    (150) exponential_part -> EREAL . integer
    (151) integer -> . unsigned_integer
    (152) integer -> . PLUS unsigned_integer
    (153) integer -> . MINUS unsigned_integer
    (147) unsigned_integer -> . DIGIT
    (148) unsigned_integer -> . unsigned_integer DIGIT

    PLUS            shift and go to state 204
    MINUS           shift and go to state 206
    DIGIT           shift and go to state 6

    integer                        shift and go to state 205
    unsigned_integer               shift and go to state 207

state 116

    (140) primary -> LCBRACKET . arithmetic_expression RCBRACKET
    (170) boolean_primary -> LCBRACKET . boolean_expression RCBRACKET
    (122) arithmetic_expression -> . simple_arithmetic_expression
    (123) arithmetic_expression -> . if_clause simple_arithmetic_expression ELSE arithmetic_expression
    (154) boolean_expression -> . simple_boolean
    (155) boolean_expression -> . if_clause simple_boolean ELSE boolean_expression
    (124) simple_arithmetic_expression -> . term
    (125) simple_arithmetic_expression -> . adding_operator term
    (126) simple_arithmetic_expression -> . simple_arithmetic_expression adding_operator term
    (110) if_clause -> . IF boolean_expression THEN
    (156) simple_boolean -> . implication
    (157) simple_boolean -> . simple_boolean EQUIV implication
    (129) term -> . factor
    (130) term -> . term multiplying_operator factor
    (127) adding_operator -> . PLUS
    (128) adding_operator -> . MINUS
    (158) implication -> . boolean_term
    (159) implication -> . implication IMPL boolean_term
    (134) factor -> . primary
    (135) factor -> . factor
    (136) factor -> . factor POWER primary
    (160) boolean_term -> . boolean_factor
    (161) boolean_term -> . boolean_term OR boolean_factor
    (137) primary -> . unsigned_number
    (138) primary -> . variable
    (139) primary -> . function_designator
    (140) primary -> . LCBRACKET arithmetic_expression RCBRACKET
    (162) boolean_factor -> . boolean_secondary
    (163) boolean_factor -> . boolean_factor AND boolean_secondary
    (141) unsigned_number -> . decimal_number
    (142) unsigned_number -> . exponential_part
    (143) unsigned_number -> . decimal_number exponential_part
    (173) variable -> . simple_variable
    (174) variable -> . subscripted_variable
    (172) function_designator -> . procedure_identifier actual_parameter_part
    (164) boolean_secondary -> . boolean_primary
    (165) boolean_secondary -> . NOT boolean_primary
    (144) decimal_number -> . unsigned_integer
    (145) decimal_number -> . decimal_fraction
    (146) decimal_number -> . unsigned_integer decimal_fraction
    (150) exponential_part -> . EREAL integer
    (175) simple_variable -> . variable_identifier
    (177) subscripted_variable -> . array_identifier LBBRACKET subscript_list RBBRACKET
    (44) procedure_identifier -> . IDENTIFIER
    (166) boolean_primary -> . logical_value
    (167) boolean_primary -> . variable
    (168) boolean_primary -> . function_designator
    (169) boolean_primary -> . relation
    (170) boolean_primary -> . LCBRACKET boolean_expression RCBRACKET
    (147) unsigned_integer -> . DIGIT
    (148) unsigned_integer -> . unsigned_integer DIGIT
    (149) decimal_fraction -> . DOT unsigned_integer
    (176) variable_identifier -> . IDENTIFIER
    (31) array_identifier -> . IDENTIFIER
    (184) logical_value -> . TRUE
    (185) logical_value -> . FALSE
    (171) relation -> . simple_arithmetic_expression relational_operator simple_arithmetic_expression

    IF              shift and go to state 45
    PLUS            shift and go to state 102
    MINUS           shift and go to state 94
    LCBRACKET       shift and go to state 116
    NOT             shift and go to state 118
    EREAL           shift and go to state 115
    IDENTIFIER      shift and go to state 106
    DIGIT           shift and go to state 6
    DOT             shift and go to state 95
    TRUE            shift and go to state 93
    FALSE           shift and go to state 100

    boolean_primary                shift and go to state 99
    procedure_identifier           shift and go to state 125
    boolean_term                   shift and go to state 88
    if_clause                      shift and go to state 89
    boolean_factor                 shift and go to state 90
    relation                       shift and go to state 91
    simple_boolean                 shift and go to state 97
    boolean_secondary              shift and go to state 101
    unsigned_number                shift and go to state 105
    decimal_fraction               shift and go to state 103
    factor                         shift and go to state 104
    simple_arithmetic_expression   shift and go to state 107
    arithmetic_expression          shift and go to state 208
    logical_value                  shift and go to state 109
    decimal_number                 shift and go to state 112
    primary                        shift and go to state 98
    variable_identifier            shift and go to state 41
    function_designator            shift and go to state 110
    array_identifier               shift and go to state 14
    variable                       shift and go to state 161
    exponential_part               shift and go to state 92
    term                           shift and go to state 113
    boolean_expression             shift and go to state 209
    subscripted_variable           shift and go to state 13
    simple_variable                shift and go to state 49
    adding_operator                shift and go to state 117
    implication                    shift and go to state 119
    unsigned_integer               shift and go to state 120

state 117

    (125) simple_arithmetic_expression -> adding_operator . term
    (129) term -> . factor
    (130) term -> . term multiplying_operator factor
    (134) factor -> . primary
    (135) factor -> . factor
    (136) factor -> . factor POWER primary
    (137) primary -> . unsigned_number
    (138) primary -> . variable
    (139) primary -> . function_designator
    (140) primary -> . LCBRACKET arithmetic_expression RCBRACKET
    (141) unsigned_number -> . decimal_number
    (142) unsigned_number -> . exponential_part
    (143) unsigned_number -> . decimal_number exponential_part
    (173) variable -> . simple_variable
    (174) variable -> . subscripted_variable
    (172) function_designator -> . procedure_identifier actual_parameter_part
    (144) decimal_number -> . unsigned_integer
    (145) decimal_number -> . decimal_fraction
    (146) decimal_number -> . unsigned_integer decimal_fraction
    (150) exponential_part -> . EREAL integer
    (175) simple_variable -> . variable_identifier
    (177) subscripted_variable -> . array_identifier LBBRACKET subscript_list RBBRACKET
    (44) procedure_identifier -> . IDENTIFIER
    (147) unsigned_integer -> . DIGIT
    (148) unsigned_integer -> . unsigned_integer DIGIT
    (149) decimal_fraction -> . DOT unsigned_integer
    (176) variable_identifier -> . IDENTIFIER
    (31) array_identifier -> . IDENTIFIER

    LCBRACKET       shift and go to state 145
    EREAL           shift and go to state 115
    IDENTIFIER      shift and go to state 106
    DIGIT           shift and go to state 6
    DOT             shift and go to state 95

    term                           shift and go to state 210
    procedure_identifier           shift and go to state 125
    array_identifier               shift and go to state 14
    subscripted_variable           shift and go to state 13
    primary                        shift and go to state 98
    function_designator            shift and go to state 149
    decimal_number                 shift and go to state 112
    variable_identifier            shift and go to state 41
    unsigned_number                shift and go to state 105
    decimal_fraction               shift and go to state 103
    factor                         shift and go to state 104
    variable                       shift and go to state 150
    simple_variable                shift and go to state 49
    unsigned_integer               shift and go to state 120
    exponential_part               shift and go to state 92

state 118

    (165) boolean_secondary -> NOT . boolean_primary
    (166) boolean_primary -> . logical_value
    (167) boolean_primary -> . variable
    (168) boolean_primary -> . function_designator
    (169) boolean_primary -> . relation
    (170) boolean_primary -> . LCBRACKET boolean_expression RCBRACKET
    (184) logical_value -> . TRUE
    (185) logical_value -> . FALSE
    (173) variable -> . simple_variable
    (174) variable -> . subscripted_variable
    (172) function_designator -> . procedure_identifier actual_parameter_part
    (171) relation -> . simple_arithmetic_expression relational_operator simple_arithmetic_expression
    (175) simple_variable -> . variable_identifier
    (177) subscripted_variable -> . array_identifier LBBRACKET subscript_list RBBRACKET
    (44) procedure_identifier -> . IDENTIFIER
    (124) simple_arithmetic_expression -> . term
    (125) simple_arithmetic_expression -> . adding_operator term
    (126) simple_arithmetic_expression -> . simple_arithmetic_expression adding_operator term
    (176) variable_identifier -> . IDENTIFIER
    (31) array_identifier -> . IDENTIFIER
    (129) term -> . factor
    (130) term -> . term multiplying_operator factor
    (127) adding_operator -> . PLUS
    (128) adding_operator -> . MINUS
    (134) factor -> . primary
    (135) factor -> . factor
    (136) factor -> . factor POWER primary
    (137) primary -> . unsigned_number
    (138) primary -> . variable
    (139) primary -> . function_designator
    (140) primary -> . LCBRACKET arithmetic_expression RCBRACKET
    (141) unsigned_number -> . decimal_number
    (142) unsigned_number -> . exponential_part
    (143) unsigned_number -> . decimal_number exponential_part
    (144) decimal_number -> . unsigned_integer
    (145) decimal_number -> . decimal_fraction
    (146) decimal_number -> . unsigned_integer decimal_fraction
    (150) exponential_part -> . EREAL integer
    (147) unsigned_integer -> . DIGIT
    (148) unsigned_integer -> . unsigned_integer DIGIT
    (149) decimal_fraction -> . DOT unsigned_integer

    LCBRACKET       shift and go to state 127
    TRUE            shift and go to state 93
    FALSE           shift and go to state 100
    IDENTIFIER      shift and go to state 106
    PLUS            shift and go to state 102
    MINUS           shift and go to state 94
    EREAL           shift and go to state 115
    DIGIT           shift and go to state 6
    DOT             shift and go to state 95

    subscripted_variable           shift and go to state 13
    primary                        shift and go to state 98
    function_designator            shift and go to state 128
    relation                       shift and go to state 91
    unsigned_number                shift and go to state 105
    decimal_fraction               shift and go to state 103
    factor                         shift and go to state 104
    simple_arithmetic_expression   shift and go to state 131
    boolean_primary                shift and go to state 211
    logical_value                  shift and go to state 109
    decimal_number                 shift and go to state 112
    variable_identifier            shift and go to state 41
    array_identifier               shift and go to state 14
    variable                       shift and go to state 129
    exponential_part               shift and go to state 92
    term                           shift and go to state 113
    procedure_identifier           shift and go to state 125
    simple_variable                shift and go to state 49
    adding_operator                shift and go to state 117
    unsigned_integer               shift and go to state 120

state 119

    (156) simple_boolean -> implication .
    (159) implication -> implication . IMPL boolean_term

    EQUIV           reduce using rule 156 (simple_boolean -> implication .)
    RCBRACKET       reduce using rule 156 (simple_boolean -> implication .)
    COMMA           reduce using rule 156 (simple_boolean -> implication .)
    THEN            reduce using rule 156 (simple_boolean -> implication .)
    ELSE            reduce using rule 156 (simple_boolean -> implication .)
    DO              reduce using rule 156 (simple_boolean -> implication .)
    END             reduce using rule 156 (simple_boolean -> implication .)
    SEMICOLON       reduce using rule 156 (simple_boolean -> implication .)
    IMPL            shift and go to state 212


state 120

    (144) decimal_number -> unsigned_integer .
    (146) decimal_number -> unsigned_integer . decimal_fraction
    (148) unsigned_integer -> unsigned_integer . DIGIT
    (149) decimal_fraction -> . DOT unsigned_integer

    EREAL           reduce using rule 144 (decimal_number -> unsigned_integer .)
    POWER           reduce using rule 144 (decimal_number -> unsigned_integer .)
    TIMES           reduce using rule 144 (decimal_number -> unsigned_integer .)
    DIV             reduce using rule 144 (decimal_number -> unsigned_integer .)
    MOD             reduce using rule 144 (decimal_number -> unsigned_integer .)
    LESS            reduce using rule 144 (decimal_number -> unsigned_integer .)
    NOTGREATER      reduce using rule 144 (decimal_number -> unsigned_integer .)
    EQUAL           reduce using rule 144 (decimal_number -> unsigned_integer .)
    NOTLESS         reduce using rule 144 (decimal_number -> unsigned_integer .)
    GREATER         reduce using rule 144 (decimal_number -> unsigned_integer .)
    NOTEQUAL        reduce using rule 144 (decimal_number -> unsigned_integer .)
    PLUS            reduce using rule 144 (decimal_number -> unsigned_integer .)
    MINUS           reduce using rule 144 (decimal_number -> unsigned_integer .)
    END             reduce using rule 144 (decimal_number -> unsigned_integer .)
    SEMICOLON       reduce using rule 144 (decimal_number -> unsigned_integer .)
    ELSE            reduce using rule 144 (decimal_number -> unsigned_integer .)
    RBBRACKET       reduce using rule 144 (decimal_number -> unsigned_integer .)
    COMMA           reduce using rule 144 (decimal_number -> unsigned_integer .)
    RCBRACKET       reduce using rule 144 (decimal_number -> unsigned_integer .)
    COLON           reduce using rule 144 (decimal_number -> unsigned_integer .)
    STEP            reduce using rule 144 (decimal_number -> unsigned_integer .)
    WHILE           reduce using rule 144 (decimal_number -> unsigned_integer .)
    DO              reduce using rule 144 (decimal_number -> unsigned_integer .)
    AND             reduce using rule 144 (decimal_number -> unsigned_integer .)
    OR              reduce using rule 144 (decimal_number -> unsigned_integer .)
    IMPL            reduce using rule 144 (decimal_number -> unsigned_integer .)
    EQUIV           reduce using rule 144 (decimal_number -> unsigned_integer .)
    THEN            reduce using rule 144 (decimal_number -> unsigned_integer .)
    UNTIL           reduce using rule 144 (decimal_number -> unsigned_integer .)
    DIGIT           shift and go to state 57
    DOT             shift and go to state 95

    decimal_fraction               shift and go to state 213

state 121

    (84) left_part -> variable ASSIGNMENT .

    IF              reduce using rule 84 (left_part -> variable ASSIGNMENT .)
    IDENTIFIER      reduce using rule 84 (left_part -> variable ASSIGNMENT .)
    PLUS            reduce using rule 84 (left_part -> variable ASSIGNMENT .)
    MINUS           reduce using rule 84 (left_part -> variable ASSIGNMENT .)
    LCBRACKET       reduce using rule 84 (left_part -> variable ASSIGNMENT .)
    NOT             reduce using rule 84 (left_part -> variable ASSIGNMENT .)
    EREAL           reduce using rule 84 (left_part -> variable ASSIGNMENT .)
    DIGIT           reduce using rule 84 (left_part -> variable ASSIGNMENT .)
    DOT             reduce using rule 84 (left_part -> variable ASSIGNMENT .)
    TRUE            reduce using rule 84 (left_part -> variable ASSIGNMENT .)
    FALSE           reduce using rule 84 (left_part -> variable ASSIGNMENT .)


state 122

    (41) procedure_declaration -> PROCEDURE procedure_heading . procedure_body
    (65) procedure_body -> . statement
    (66) statement -> . unconditional_statement
    (67) statement -> . conditional_statement
    (68) statement -> . for_statement
    (69) unconditional_statement -> . basic_statement
    (70) unconditional_statement -> . compound_statement
    (71) unconditional_statement -> . block
    (105) conditional_statement -> . if_statement
    (106) conditional_statement -> . if_statement ELSE statement
    (107) conditional_statement -> . if_clause for_statement
    (108) conditional_statement -> . label COLON conditional_statement
    (111) for_statement -> . for_clause statement
    (112) for_statement -> . label COLON for_statement
    (72) basic_statement -> . unlabelled_basic_statement
    (73) basic_statement -> . label COLON basic_statement
    (8) compound_statement -> . unlabelled_compound
    (9) compound_statement -> . label COLON compound_statement
    (3) block -> . unlabelled_block
    (4) block -> . TLABEL COLON block
    (109) if_statement -> . if_clause unconditional_statement
    (110) if_clause -> . IF boolean_expression THEN
    (74) label -> . IDENTIFIER
    (75) label -> . unsigned_integer
    (113) for_clause -> . FOR variable ASSIGNMENT for_list DO
    (76) unlabelled_basic_statement -> .
    (77) unlabelled_basic_statement -> . assignment_statement
    (78) unlabelled_basic_statement -> . go_to_statement
    (79) unlabelled_basic_statement -> . procedure_statement
    (10) unlabelled_compound -> . BEGIN compound_tail
    (5) unlabelled_block -> . block_head SEMICOLON compound_tail
    (147) unsigned_integer -> . DIGIT
    (148) unsigned_integer -> . unsigned_integer DIGIT
    (80) assignment_statement -> . left_part_list arithmetic_expression
    (81) assignment_statement -> . left_part_list boolean_expression
    (86) go_to_statement -> . GOTO designational_expression
    (93) procedure_statement -> . procedure_identifier actual_parameter_part
    (6) block_head -> . BEGIN declaration
    (7) block_head -> . block_head SEMICOLON declaration
    (82) left_part_list -> . left_part
    (83) left_part_list -> . left_part_list left_part
    (44) procedure_identifier -> . IDENTIFIER
    (84) left_part -> . variable ASSIGNMENT
    (85) left_part -> . procedure_identifier ASSIGNMENT
    (173) variable -> . simple_variable
    (174) variable -> . subscripted_variable
    (175) simple_variable -> . variable_identifier
    (177) subscripted_variable -> . array_identifier LBBRACKET subscript_list RBBRACKET
    (176) variable_identifier -> . IDENTIFIER
    (31) array_identifier -> . IDENTIFIER

    TLABEL          shift and go to state 4
    IF              shift and go to state 45
    IDENTIFIER      shift and go to state 47
    FOR             shift and go to state 37
    SEMICOLON       reduce using rule 76 (unlabelled_basic_statement -> .)
    BEGIN           shift and go to state 1
    DIGIT           shift and go to state 6
    GOTO            shift and go to state 20

    subscripted_variable           shift and go to state 13
    block                          shift and go to state 54
    unlabelled_compound            shift and go to state 2
    array_identifier               shift and go to state 14
    if_clause                      shift and go to state 16
    block_head                     shift and go to state 10
    conditional_statement          shift and go to state 25
    left_part                      shift and go to state 34
    left_part_list                 shift and go to state 40
    compound_statement             shift and go to state 22
    assignment_statement           shift and go to state 23
    procedure_statement            shift and go to state 24
    label                          shift and go to state 19
    statement                      shift and go to state 214
    if_statement                   shift and go to state 30
    basic_statement                shift and go to state 33
    for_statement                  shift and go to state 35
    go_to_statement                shift and go to state 38
    variable_identifier            shift and go to state 41
    variable                       shift and go to state 43
    unconditional_statement        shift and go to state 28
    unlabelled_block               shift and go to state 5
    procedure_identifier           shift and go to state 21
    simple_variable                shift and go to state 49
    unlabelled_basic_statement     shift and go to state 50
    for_clause                     shift and go to state 52
    procedure_body                 shift and go to state 215
    unsigned_integer               shift and go to state 9

state 123

    (43) procedure_heading -> procedure_identifier . formal_parameter_part SEMICOLON value_part specification_part
    (45) formal_parameter_part -> .
    (46) formal_parameter_part -> . LCBRACKET formal_parameter_list RCBRACKET

    SEMICOLON       reduce using rule 45 (formal_parameter_part -> .)
    LCBRACKET       shift and go to state 217

    formal_parameter_part          shift and go to state 216

state 124

    (44) procedure_identifier -> IDENTIFIER .

    LCBRACKET       reduce using rule 44 (procedure_identifier -> IDENTIFIER .)
    SEMICOLON       reduce using rule 44 (procedure_identifier -> IDENTIFIER .)


state 125

    (172) function_designator -> procedure_identifier . actual_parameter_part
    (94) actual_parameter_part -> .
    (95) actual_parameter_part -> . LCBRACKET actual_parameter_list RCBRACKET

    AND             reduce using rule 94 (actual_parameter_part -> .)
    OR              reduce using rule 94 (actual_parameter_part -> .)
    IMPL            reduce using rule 94 (actual_parameter_part -> .)
    EQUIV           reduce using rule 94 (actual_parameter_part -> .)
    THEN            reduce using rule 94 (actual_parameter_part -> .)
    POWER           reduce using rule 94 (actual_parameter_part -> .)
    TIMES           reduce using rule 94 (actual_parameter_part -> .)
    DIV             reduce using rule 94 (actual_parameter_part -> .)
    MOD             reduce using rule 94 (actual_parameter_part -> .)
    LESS            reduce using rule 94 (actual_parameter_part -> .)
    NOTGREATER      reduce using rule 94 (actual_parameter_part -> .)
    EQUAL           reduce using rule 94 (actual_parameter_part -> .)
    NOTLESS         reduce using rule 94 (actual_parameter_part -> .)
    GREATER         reduce using rule 94 (actual_parameter_part -> .)
    NOTEQUAL        reduce using rule 94 (actual_parameter_part -> .)
    PLUS            reduce using rule 94 (actual_parameter_part -> .)
    MINUS           reduce using rule 94 (actual_parameter_part -> .)
    RBBRACKET       reduce using rule 94 (actual_parameter_part -> .)
    COMMA           reduce using rule 94 (actual_parameter_part -> .)
    ELSE            reduce using rule 94 (actual_parameter_part -> .)
    RCBRACKET       reduce using rule 94 (actual_parameter_part -> .)
    END             reduce using rule 94 (actual_parameter_part -> .)
    SEMICOLON       reduce using rule 94 (actual_parameter_part -> .)
    COLON           reduce using rule 94 (actual_parameter_part -> .)
    STEP            reduce using rule 94 (actual_parameter_part -> .)
    WHILE           reduce using rule 94 (actual_parameter_part -> .)
    DO              reduce using rule 94 (actual_parameter_part -> .)
    UNTIL           reduce using rule 94 (actual_parameter_part -> .)
    LCBRACKET       shift and go to state 73

    actual_parameter_part          shift and go to state 183

state 126

    (155) boolean_expression -> if_clause . simple_boolean ELSE boolean_expression
    (156) simple_boolean -> . implication
    (157) simple_boolean -> . simple_boolean EQUIV implication
    (158) implication -> . boolean_term
    (159) implication -> . implication IMPL boolean_term
    (160) boolean_term -> . boolean_factor
    (161) boolean_term -> . boolean_term OR boolean_factor
    (162) boolean_factor -> . boolean_secondary
    (163) boolean_factor -> . boolean_factor AND boolean_secondary
    (164) boolean_secondary -> . boolean_primary
    (165) boolean_secondary -> . NOT boolean_primary
    (166) boolean_primary -> . logical_value
    (167) boolean_primary -> . variable
    (168) boolean_primary -> . function_designator
    (169) boolean_primary -> . relation
    (170) boolean_primary -> . LCBRACKET boolean_expression RCBRACKET
    (184) logical_value -> . TRUE
    (185) logical_value -> . FALSE
    (173) variable -> . simple_variable
    (174) variable -> . subscripted_variable
    (172) function_designator -> . procedure_identifier actual_parameter_part
    (171) relation -> . simple_arithmetic_expression relational_operator simple_arithmetic_expression
    (175) simple_variable -> . variable_identifier
    (177) subscripted_variable -> . array_identifier LBBRACKET subscript_list RBBRACKET
    (44) procedure_identifier -> . IDENTIFIER
    (124) simple_arithmetic_expression -> . term
    (125) simple_arithmetic_expression -> . adding_operator term
    (126) simple_arithmetic_expression -> . simple_arithmetic_expression adding_operator term
    (176) variable_identifier -> . IDENTIFIER
    (31) array_identifier -> . IDENTIFIER
    (129) term -> . factor
    (130) term -> . term multiplying_operator factor
    (127) adding_operator -> . PLUS
    (128) adding_operator -> . MINUS
    (134) factor -> . primary
    (135) factor -> . factor
    (136) factor -> . factor POWER primary
    (137) primary -> . unsigned_number
    (138) primary -> . variable
    (139) primary -> . function_designator
    (140) primary -> . LCBRACKET arithmetic_expression RCBRACKET
    (141) unsigned_number -> . decimal_number
    (142) unsigned_number -> . exponential_part
    (143) unsigned_number -> . decimal_number exponential_part
    (144) decimal_number -> . unsigned_integer
    (145) decimal_number -> . decimal_fraction
    (146) decimal_number -> . unsigned_integer decimal_fraction
    (150) exponential_part -> . EREAL integer
    (147) unsigned_integer -> . DIGIT
    (148) unsigned_integer -> . unsigned_integer DIGIT
    (149) decimal_fraction -> . DOT unsigned_integer

    NOT             shift and go to state 118
    LCBRACKET       shift and go to state 127
    TRUE            shift and go to state 93
    FALSE           shift and go to state 100
    IDENTIFIER      shift and go to state 106
    PLUS            shift and go to state 102
    MINUS           shift and go to state 94
    EREAL           shift and go to state 115
    DIGIT           shift and go to state 6
    DOT             shift and go to state 95

    subscripted_variable           shift and go to state 13
    boolean_term                   shift and go to state 88
    boolean_factor                 shift and go to state 90
    relation                       shift and go to state 91
    simple_boolean                 shift and go to state 186
    boolean_secondary              shift and go to state 101
    unsigned_number                shift and go to state 105
    decimal_fraction               shift and go to state 103
    factor                         shift and go to state 104
    simple_arithmetic_expression   shift and go to state 131
    boolean_primary                shift and go to state 99
    logical_value                  shift and go to state 109
    decimal_number                 shift and go to state 112
    primary                        shift and go to state 98
    variable_identifier            shift and go to state 41
    function_designator            shift and go to state 128
    array_identifier               shift and go to state 14
    variable                       shift and go to state 129
    exponential_part               shift and go to state 92
    term                           shift and go to state 113
    procedure_identifier           shift and go to state 125
    simple_variable                shift and go to state 49
    adding_operator                shift and go to state 117
    implication                    shift and go to state 119
    unsigned_integer               shift and go to state 120

state 127

    (170) boolean_primary -> LCBRACKET . boolean_expression RCBRACKET
    (140) primary -> LCBRACKET . arithmetic_expression RCBRACKET
    (154) boolean_expression -> . simple_boolean
    (155) boolean_expression -> . if_clause simple_boolean ELSE boolean_expression
    (122) arithmetic_expression -> . simple_arithmetic_expression
    (123) arithmetic_expression -> . if_clause simple_arithmetic_expression ELSE arithmetic_expression
    (156) simple_boolean -> . implication
    (157) simple_boolean -> . simple_boolean EQUIV implication
    (110) if_clause -> . IF boolean_expression THEN
    (124) simple_arithmetic_expression -> . term
    (125) simple_arithmetic_expression -> . adding_operator term
    (126) simple_arithmetic_expression -> . simple_arithmetic_expression adding_operator term
    (158) implication -> . boolean_term
    (159) implication -> . implication IMPL boolean_term
    (129) term -> . factor
    (130) term -> . term multiplying_operator factor
    (127) adding_operator -> . PLUS
    (128) adding_operator -> . MINUS
    (160) boolean_term -> . boolean_factor
    (161) boolean_term -> . boolean_term OR boolean_factor
    (134) factor -> . primary
    (135) factor -> . factor
    (136) factor -> . factor POWER primary
    (162) boolean_factor -> . boolean_secondary
    (163) boolean_factor -> . boolean_factor AND boolean_secondary
    (137) primary -> . unsigned_number
    (138) primary -> . variable
    (139) primary -> . function_designator
    (140) primary -> . LCBRACKET arithmetic_expression RCBRACKET
    (164) boolean_secondary -> . boolean_primary
    (165) boolean_secondary -> . NOT boolean_primary
    (141) unsigned_number -> . decimal_number
    (142) unsigned_number -> . exponential_part
    (143) unsigned_number -> . decimal_number exponential_part
    (173) variable -> . simple_variable
    (174) variable -> . subscripted_variable
    (172) function_designator -> . procedure_identifier actual_parameter_part
    (166) boolean_primary -> . logical_value
    (167) boolean_primary -> . variable
    (168) boolean_primary -> . function_designator
    (169) boolean_primary -> . relation
    (170) boolean_primary -> . LCBRACKET boolean_expression RCBRACKET
    (144) decimal_number -> . unsigned_integer
    (145) decimal_number -> . decimal_fraction
    (146) decimal_number -> . unsigned_integer decimal_fraction
    (150) exponential_part -> . EREAL integer
    (175) simple_variable -> . variable_identifier
    (177) subscripted_variable -> . array_identifier LBBRACKET subscript_list RBBRACKET
    (44) procedure_identifier -> . IDENTIFIER
    (184) logical_value -> . TRUE
    (185) logical_value -> . FALSE
    (171) relation -> . simple_arithmetic_expression relational_operator simple_arithmetic_expression
    (147) unsigned_integer -> . DIGIT
    (148) unsigned_integer -> . unsigned_integer DIGIT
    (149) decimal_fraction -> . DOT unsigned_integer
    (176) variable_identifier -> . IDENTIFIER
    (31) array_identifier -> . IDENTIFIER

    IF              shift and go to state 45
    PLUS            shift and go to state 102
    MINUS           shift and go to state 94
    LCBRACKET       shift and go to state 116
    NOT             shift and go to state 118
    EREAL           shift and go to state 115
    IDENTIFIER      shift and go to state 106
    TRUE            shift and go to state 93
    FALSE           shift and go to state 100
    DIGIT           shift and go to state 6
    DOT             shift and go to state 95

    boolean_primary                shift and go to state 99
    procedure_identifier           shift and go to state 125
    boolean_term                   shift and go to state 88
    if_clause                      shift and go to state 218
    boolean_factor                 shift and go to state 90
    relation                       shift and go to state 91
    simple_boolean                 shift and go to state 97
    boolean_secondary              shift and go to state 101
    unsigned_number                shift and go to state 105
    decimal_fraction               shift and go to state 103
    factor                         shift and go to state 104
    simple_arithmetic_expression   shift and go to state 107
    arithmetic_expression          shift and go to state 208
    logical_value                  shift and go to state 109
    decimal_number                 shift and go to state 112
    primary                        shift and go to state 98
    variable_identifier            shift and go to state 41
    function_designator            shift and go to state 110
    array_identifier               shift and go to state 14
    variable                       shift and go to state 161
    exponential_part               shift and go to state 92
    term                           shift and go to state 113
    boolean_expression             shift and go to state 209
    subscripted_variable           shift and go to state 13
    simple_variable                shift and go to state 49
    adding_operator                shift and go to state 117
    implication                    shift and go to state 119
    unsigned_integer               shift and go to state 120

state 128

    (168) boolean_primary -> function_designator .
    (139) primary -> function_designator .

    AND             reduce using rule 168 (boolean_primary -> function_designator .)
    OR              reduce using rule 168 (boolean_primary -> function_designator .)
    IMPL            reduce using rule 168 (boolean_primary -> function_designator .)
    EQUIV           reduce using rule 168 (boolean_primary -> function_designator .)
    END             reduce using rule 168 (boolean_primary -> function_designator .)
    SEMICOLON       reduce using rule 168 (boolean_primary -> function_designator .)
    ELSE            reduce using rule 168 (boolean_primary -> function_designator .)
    THEN            reduce using rule 168 (boolean_primary -> function_designator .)
    RCBRACKET       reduce using rule 168 (boolean_primary -> function_designator .)
    COMMA           reduce using rule 168 (boolean_primary -> function_designator .)
    DO              reduce using rule 168 (boolean_primary -> function_designator .)
    POWER           reduce using rule 139 (primary -> function_designator .)
    TIMES           reduce using rule 139 (primary -> function_designator .)
    DIV             reduce using rule 139 (primary -> function_designator .)
    MOD             reduce using rule 139 (primary -> function_designator .)
    LESS            reduce using rule 139 (primary -> function_designator .)
    NOTGREATER      reduce using rule 139 (primary -> function_designator .)
    EQUAL           reduce using rule 139 (primary -> function_designator .)
    NOTLESS         reduce using rule 139 (primary -> function_designator .)
    GREATER         reduce using rule 139 (primary -> function_designator .)
    NOTEQUAL        reduce using rule 139 (primary -> function_designator .)
    PLUS            reduce using rule 139 (primary -> function_designator .)
    MINUS           reduce using rule 139 (primary -> function_designator .)


state 129

    (167) boolean_primary -> variable .
    (138) primary -> variable .

    AND             reduce using rule 167 (boolean_primary -> variable .)
    OR              reduce using rule 167 (boolean_primary -> variable .)
    IMPL            reduce using rule 167 (boolean_primary -> variable .)
    EQUIV           reduce using rule 167 (boolean_primary -> variable .)
    END             reduce using rule 167 (boolean_primary -> variable .)
    SEMICOLON       reduce using rule 167 (boolean_primary -> variable .)
    ELSE            reduce using rule 167 (boolean_primary -> variable .)
    THEN            reduce using rule 167 (boolean_primary -> variable .)
    RCBRACKET       reduce using rule 167 (boolean_primary -> variable .)
    COMMA           reduce using rule 167 (boolean_primary -> variable .)
    DO              reduce using rule 167 (boolean_primary -> variable .)
    POWER           reduce using rule 138 (primary -> variable .)
    TIMES           reduce using rule 138 (primary -> variable .)
    DIV             reduce using rule 138 (primary -> variable .)
    MOD             reduce using rule 138 (primary -> variable .)
    LESS            reduce using rule 138 (primary -> variable .)
    NOTGREATER      reduce using rule 138 (primary -> variable .)
    EQUAL           reduce using rule 138 (primary -> variable .)
    NOTLESS         reduce using rule 138 (primary -> variable .)
    GREATER         reduce using rule 138 (primary -> variable .)
    NOTEQUAL        reduce using rule 138 (primary -> variable .)
    PLUS            reduce using rule 138 (primary -> variable .)
    MINUS           reduce using rule 138 (primary -> variable .)


state 130

    (110) if_clause -> IF boolean_expression . THEN

    THEN            shift and go to state 219


state 131

    (171) relation -> simple_arithmetic_expression . relational_operator simple_arithmetic_expression
    (126) simple_arithmetic_expression -> simple_arithmetic_expression . adding_operator term
    (186) relational_operator -> . LESS
    (187) relational_operator -> . NOTGREATER
    (188) relational_operator -> . EQUAL
    (189) relational_operator -> . NOTLESS
    (190) relational_operator -> . GREATER
    (191) relational_operator -> . NOTEQUAL
    (127) adding_operator -> . PLUS
    (128) adding_operator -> . MINUS

    LESS            shift and go to state 193
    NOTGREATER      shift and go to state 198
    EQUAL           shift and go to state 194
    NOTLESS         shift and go to state 197
    GREATER         shift and go to state 196
    NOTEQUAL        shift and go to state 191
    PLUS            shift and go to state 102
    MINUS           shift and go to state 94

    relational_operator            shift and go to state 192
    adding_operator                shift and go to state 195

state 132

    (19) local_or_own_type -> TOWN type .

    TARRAY          reduce using rule 19 (local_or_own_type -> TOWN type .)
    IDENTIFIER      reduce using rule 19 (local_or_own_type -> TOWN type .)


state 133

    (23) type_list -> simple_variable .
    (24) type_list -> simple_variable . COMMA type_list

    SEMICOLON       reduce using rule 23 (type_list -> simple_variable .)
    COMMA           shift and go to state 220


state 134

    (17) type_declaration -> local_or_own_type type_list .

    SEMICOLON       reduce using rule 17 (type_declaration -> local_or_own_type type_list .)


state 135

    (176) variable_identifier -> IDENTIFIER .

    COMMA           reduce using rule 176 (variable_identifier -> IDENTIFIER .)
    SEMICOLON       reduce using rule 176 (variable_identifier -> IDENTIFIER .)


state 136

    (26) array_declaration -> local_or_own_type TARRAY . array_list
    (27) array_list -> . array_segment
    (28) array_list -> . array_list COMMA array_segment
    (29) array_segment -> . array_identifier LBBRACKET bound_pair_list RBBRACKET
    (30) array_segment -> . array_identifier COMMA array_segment
    (31) array_identifier -> . IDENTIFIER

    IDENTIFIER      shift and go to state 83

    array_segment                  shift and go to state 81
    array_list                     shift and go to state 221
    array_identifier               shift and go to state 82

state 137

    (111) for_statement -> for_clause statement .

    END             reduce using rule 111 (for_statement -> for_clause statement .)
    SEMICOLON       reduce using rule 111 (for_statement -> for_clause statement .)


state 138

    (6) block_head -> BEGIN . declaration
    (13) declaration -> . type_declaration
    (14) declaration -> . array_declaration
    (15) declaration -> . switch_declaration
    (16) declaration -> . procedure_declaration
    (17) type_declaration -> . local_or_own_type type_list
    (25) array_declaration -> . TARRAY array_list
    (26) array_declaration -> . local_or_own_type TARRAY array_list
    (37) switch_declaration -> . SWITCH switch_identifier ASSIGNMENT switch_list
    (41) procedure_declaration -> . PROCEDURE procedure_heading procedure_body
    (42) procedure_declaration -> . type PROCEDURE procedure_heading procedure_body
    (18) local_or_own_type -> . type
    (19) local_or_own_type -> . TOWN type
    (20) type -> . TREAL
    (21) type -> . TINTEGER
    (22) type -> . TBOOLEAN

    TARRAY          shift and go to state 32
    SWITCH          shift and go to state 27
    PROCEDURE       shift and go to state 44
    TOWN            shift and go to state 46
    TREAL           shift and go to state 15
    TINTEGER        shift and go to state 18
    TBOOLEAN        shift and go to state 26

    type                           shift and go to state 31
    procedure_declaration          shift and go to state 48
    declaration                    shift and go to state 42
    type_declaration               shift and go to state 17
    local_or_own_type              shift and go to state 51
    switch_declaration             shift and go to state 39
    array_declaration              shift and go to state 53

state 139

    (4) block -> TLABEL COLON block .

    END             reduce using rule 4 (block -> TLABEL COLON block .)
    SEMICOLON       reduce using rule 4 (block -> TLABEL COLON block .)
    $end            reduce using rule 4 (block -> TLABEL COLON block .)
    ELSE            reduce using rule 4 (block -> TLABEL COLON block .)


state 140

    (10) unlabelled_compound -> BEGIN . compound_tail
    (11) compound_tail -> . statement END
    (12) compound_tail -> . statement SEMICOLON compound_tail
    (66) statement -> . unconditional_statement
    (67) statement -> . conditional_statement
    (68) statement -> . for_statement
    (69) unconditional_statement -> . basic_statement
    (70) unconditional_statement -> . compound_statement
    (71) unconditional_statement -> . block
    (105) conditional_statement -> . if_statement
    (106) conditional_statement -> . if_statement ELSE statement
    (107) conditional_statement -> . if_clause for_statement
    (108) conditional_statement -> . label COLON conditional_statement
    (111) for_statement -> . for_clause statement
    (112) for_statement -> . label COLON for_statement
    (72) basic_statement -> . unlabelled_basic_statement
    (73) basic_statement -> . label COLON basic_statement
    (8) compound_statement -> . unlabelled_compound
    (9) compound_statement -> . label COLON compound_statement
    (3) block -> . unlabelled_block
    (4) block -> . TLABEL COLON block
    (109) if_statement -> . if_clause unconditional_statement
    (110) if_clause -> . IF boolean_expression THEN
    (74) label -> . IDENTIFIER
    (75) label -> . unsigned_integer
    (113) for_clause -> . FOR variable ASSIGNMENT for_list DO
    (76) unlabelled_basic_statement -> .
    (77) unlabelled_basic_statement -> . assignment_statement
    (78) unlabelled_basic_statement -> . go_to_statement
    (79) unlabelled_basic_statement -> . procedure_statement
    (10) unlabelled_compound -> . BEGIN compound_tail
    (5) unlabelled_block -> . block_head SEMICOLON compound_tail
    (147) unsigned_integer -> . DIGIT
    (148) unsigned_integer -> . unsigned_integer DIGIT
    (80) assignment_statement -> . left_part_list arithmetic_expression
    (81) assignment_statement -> . left_part_list boolean_expression
    (86) go_to_statement -> . GOTO designational_expression
    (93) procedure_statement -> . procedure_identifier actual_parameter_part
    (6) block_head -> . BEGIN declaration
    (7) block_head -> . block_head SEMICOLON declaration
    (82) left_part_list -> . left_part
    (83) left_part_list -> . left_part_list left_part
    (44) procedure_identifier -> . IDENTIFIER
    (84) left_part -> . variable ASSIGNMENT
    (85) left_part -> . procedure_identifier ASSIGNMENT
    (173) variable -> . simple_variable
    (174) variable -> . subscripted_variable
    (175) simple_variable -> . variable_identifier
    (177) subscripted_variable -> . array_identifier LBBRACKET subscript_list RBBRACKET
    (176) variable_identifier -> . IDENTIFIER
    (31) array_identifier -> . IDENTIFIER

    TLABEL          shift and go to state 4
    IF              shift and go to state 45
    IDENTIFIER      shift and go to state 47
    FOR             shift and go to state 37
    END             reduce using rule 76 (unlabelled_basic_statement -> .)
    SEMICOLON       reduce using rule 76 (unlabelled_basic_statement -> .)
    BEGIN           shift and go to state 1
    DIGIT           shift and go to state 6
    GOTO            shift and go to state 20

    subscripted_variable           shift and go to state 13
    block                          shift and go to state 54
    unlabelled_compound            shift and go to state 2
    array_identifier               shift and go to state 14
    if_clause                      shift and go to state 16
    block_head                     shift and go to state 10
    conditional_statement          shift and go to state 25
    left_part                      shift and go to state 34
    left_part_list                 shift and go to state 40
    compound_statement             shift and go to state 22
    assignment_statement           shift and go to state 23
    procedure_statement            shift and go to state 24
    label                          shift and go to state 19
    statement                      shift and go to state 29
    if_statement                   shift and go to state 30
    basic_statement                shift and go to state 33
    for_statement                  shift and go to state 35
    compound_tail                  shift and go to state 36
    go_to_statement                shift and go to state 38
    variable_identifier            shift and go to state 41
    variable                       shift and go to state 43
    unconditional_statement        shift and go to state 28
    unlabelled_block               shift and go to state 5
    procedure_identifier           shift and go to state 21
    simple_variable                shift and go to state 49
    unlabelled_basic_statement     shift and go to state 50
    for_clause                     shift and go to state 52
    unsigned_integer               shift and go to state 9

state 141

    (9) compound_statement -> label COLON compound_statement .

    END             reduce using rule 9 (compound_statement -> label COLON compound_statement .)
    SEMICOLON       reduce using rule 9 (compound_statement -> label COLON compound_statement .)
    $end            reduce using rule 9 (compound_statement -> label COLON compound_statement .)
    ELSE            reduce using rule 9 (compound_statement -> label COLON compound_statement .)


state 142

    (5) unlabelled_block -> block_head SEMICOLON compound_tail .

    $end            reduce using rule 5 (unlabelled_block -> block_head SEMICOLON compound_tail .)
    END             reduce using rule 5 (unlabelled_block -> block_head SEMICOLON compound_tail .)
    SEMICOLON       reduce using rule 5 (unlabelled_block -> block_head SEMICOLON compound_tail .)
    ELSE            reduce using rule 5 (unlabelled_block -> block_head SEMICOLON compound_tail .)


state 143

    (7) block_head -> block_head SEMICOLON declaration .

    SEMICOLON       reduce using rule 7 (block_head -> block_head SEMICOLON declaration .)


state 144

    (123) arithmetic_expression -> if_clause . simple_arithmetic_expression ELSE arithmetic_expression
    (124) simple_arithmetic_expression -> . term
    (125) simple_arithmetic_expression -> . adding_operator term
    (126) simple_arithmetic_expression -> . simple_arithmetic_expression adding_operator term
    (129) term -> . factor
    (130) term -> . term multiplying_operator factor
    (127) adding_operator -> . PLUS
    (128) adding_operator -> . MINUS
    (134) factor -> . primary
    (135) factor -> . factor
    (136) factor -> . factor POWER primary
    (137) primary -> . unsigned_number
    (138) primary -> . variable
    (139) primary -> . function_designator
    (140) primary -> . LCBRACKET arithmetic_expression RCBRACKET
    (141) unsigned_number -> . decimal_number
    (142) unsigned_number -> . exponential_part
    (143) unsigned_number -> . decimal_number exponential_part
    (173) variable -> . simple_variable
    (174) variable -> . subscripted_variable
    (172) function_designator -> . procedure_identifier actual_parameter_part
    (144) decimal_number -> . unsigned_integer
    (145) decimal_number -> . decimal_fraction
    (146) decimal_number -> . unsigned_integer decimal_fraction
    (150) exponential_part -> . EREAL integer
    (175) simple_variable -> . variable_identifier
    (177) subscripted_variable -> . array_identifier LBBRACKET subscript_list RBBRACKET
    (44) procedure_identifier -> . IDENTIFIER
    (147) unsigned_integer -> . DIGIT
    (148) unsigned_integer -> . unsigned_integer DIGIT
    (149) decimal_fraction -> . DOT unsigned_integer
    (176) variable_identifier -> . IDENTIFIER
    (31) array_identifier -> . IDENTIFIER

    PLUS            shift and go to state 102
    MINUS           shift and go to state 94
    LCBRACKET       shift and go to state 145
    EREAL           shift and go to state 115
    IDENTIFIER      shift and go to state 106
    DIGIT           shift and go to state 6
    DOT             shift and go to state 95

    subscripted_variable           shift and go to state 13
    primary                        shift and go to state 98
    unsigned_number                shift and go to state 105
    decimal_fraction               shift and go to state 103
    factor                         shift and go to state 104
    simple_arithmetic_expression   shift and go to state 222
    decimal_number                 shift and go to state 112
    variable_identifier            shift and go to state 41
    function_designator            shift and go to state 149
    array_identifier               shift and go to state 14
    variable                       shift and go to state 150
    exponential_part               shift and go to state 92
    term                           shift and go to state 113
    procedure_identifier           shift and go to state 125
    simple_variable                shift and go to state 49
    adding_operator                shift and go to state 117
    unsigned_integer               shift and go to state 120

state 145

    (140) primary -> LCBRACKET . arithmetic_expression RCBRACKET
    (122) arithmetic_expression -> . simple_arithmetic_expression
    (123) arithmetic_expression -> . if_clause simple_arithmetic_expression ELSE arithmetic_expression
    (124) simple_arithmetic_expression -> . term
    (125) simple_arithmetic_expression -> . adding_operator term
    (126) simple_arithmetic_expression -> . simple_arithmetic_expression adding_operator term
    (110) if_clause -> . IF boolean_expression THEN
    (129) term -> . factor
    (130) term -> . term multiplying_operator factor
    (127) adding_operator -> . PLUS
    (128) adding_operator -> . MINUS
    (134) factor -> . primary
    (135) factor -> . factor
    (136) factor -> . factor POWER primary
    (137) primary -> . unsigned_number
    (138) primary -> . variable
    (139) primary -> . function_designator
    (140) primary -> . LCBRACKET arithmetic_expression RCBRACKET
    (141) unsigned_number -> . decimal_number
    (142) unsigned_number -> . exponential_part
    (143) unsigned_number -> . decimal_number exponential_part
    (173) variable -> . simple_variable
    (174) variable -> . subscripted_variable
    (172) function_designator -> . procedure_identifier actual_parameter_part
    (144) decimal_number -> . unsigned_integer
    (145) decimal_number -> . decimal_fraction
    (146) decimal_number -> . unsigned_integer decimal_fraction
    (150) exponential_part -> . EREAL integer
    (175) simple_variable -> . variable_identifier
    (177) subscripted_variable -> . array_identifier LBBRACKET subscript_list RBBRACKET
    (44) procedure_identifier -> . IDENTIFIER
    (147) unsigned_integer -> . DIGIT
    (148) unsigned_integer -> . unsigned_integer DIGIT
    (149) decimal_fraction -> . DOT unsigned_integer
    (176) variable_identifier -> . IDENTIFIER
    (31) array_identifier -> . IDENTIFIER

    IF              shift and go to state 45
    PLUS            shift and go to state 102
    MINUS           shift and go to state 94
    LCBRACKET       shift and go to state 145
    EREAL           shift and go to state 115
    IDENTIFIER      shift and go to state 106
    DIGIT           shift and go to state 6
    DOT             shift and go to state 95

    subscripted_variable           shift and go to state 13
    primary                        shift and go to state 98
    if_clause                      shift and go to state 144
    unsigned_number                shift and go to state 105
    decimal_fraction               shift and go to state 103
    factor                         shift and go to state 104
    simple_arithmetic_expression   shift and go to state 147
    arithmetic_expression          shift and go to state 208
    decimal_number                 shift and go to state 112
    variable_identifier            shift and go to state 41
    function_designator            shift and go to state 149
    array_identifier               shift and go to state 14
    variable                       shift and go to state 150
    exponential_part               shift and go to state 92
    term                           shift and go to state 113
    procedure_identifier           shift and go to state 125
    simple_variable                shift and go to state 49
    adding_operator                shift and go to state 117
    unsigned_integer               shift and go to state 120

state 146

    (178) subscript_list -> subscript_expression .

    RBBRACKET       reduce using rule 178 (subscript_list -> subscript_expression .)
    COMMA           reduce using rule 178 (subscript_list -> subscript_expression .)


state 147

    (122) arithmetic_expression -> simple_arithmetic_expression .
    (126) simple_arithmetic_expression -> simple_arithmetic_expression . adding_operator term
    (127) adding_operator -> . PLUS
    (128) adding_operator -> . MINUS

    STEP            reduce using rule 122 (arithmetic_expression -> simple_arithmetic_expression .)
    WHILE           reduce using rule 122 (arithmetic_expression -> simple_arithmetic_expression .)
    DO              reduce using rule 122 (arithmetic_expression -> simple_arithmetic_expression .)
    COMMA           reduce using rule 122 (arithmetic_expression -> simple_arithmetic_expression .)
    END             reduce using rule 122 (arithmetic_expression -> simple_arithmetic_expression .)
    SEMICOLON       reduce using rule 122 (arithmetic_expression -> simple_arithmetic_expression .)
    ELSE            reduce using rule 122 (arithmetic_expression -> simple_arithmetic_expression .)
    RBBRACKET       reduce using rule 122 (arithmetic_expression -> simple_arithmetic_expression .)
    RCBRACKET       reduce using rule 122 (arithmetic_expression -> simple_arithmetic_expression .)
    COLON           reduce using rule 122 (arithmetic_expression -> simple_arithmetic_expression .)
    UNTIL           reduce using rule 122 (arithmetic_expression -> simple_arithmetic_expression .)
    PLUS            shift and go to state 102
    MINUS           shift and go to state 94

    adding_operator                shift and go to state 195

state 148

    (180) subscript_expression -> arithmetic_expression .

    RBBRACKET       reduce using rule 180 (subscript_expression -> arithmetic_expression .)
    COMMA           reduce using rule 180 (subscript_expression -> arithmetic_expression .)


state 149

    (139) primary -> function_designator .

    POWER           reduce using rule 139 (primary -> function_designator .)
    TIMES           reduce using rule 139 (primary -> function_designator .)
    DIV             reduce using rule 139 (primary -> function_designator .)
    MOD             reduce using rule 139 (primary -> function_designator .)
    PLUS            reduce using rule 139 (primary -> function_designator .)
    MINUS           reduce using rule 139 (primary -> function_designator .)
    STEP            reduce using rule 139 (primary -> function_designator .)
    WHILE           reduce using rule 139 (primary -> function_designator .)
    DO              reduce using rule 139 (primary -> function_designator .)
    COMMA           reduce using rule 139 (primary -> function_designator .)
    COLON           reduce using rule 139 (primary -> function_designator .)
    END             reduce using rule 139 (primary -> function_designator .)
    SEMICOLON       reduce using rule 139 (primary -> function_designator .)
    ELSE            reduce using rule 139 (primary -> function_designator .)
    RBBRACKET       reduce using rule 139 (primary -> function_designator .)
    RCBRACKET       reduce using rule 139 (primary -> function_designator .)
    UNTIL           reduce using rule 139 (primary -> function_designator .)
    LESS            reduce using rule 139 (primary -> function_designator .)
    NOTGREATER      reduce using rule 139 (primary -> function_designator .)
    EQUAL           reduce using rule 139 (primary -> function_designator .)
    NOTLESS         reduce using rule 139 (primary -> function_designator .)
    GREATER         reduce using rule 139 (primary -> function_designator .)
    NOTEQUAL        reduce using rule 139 (primary -> function_designator .)
    AND             reduce using rule 139 (primary -> function_designator .)
    OR              reduce using rule 139 (primary -> function_designator .)
    IMPL            reduce using rule 139 (primary -> function_designator .)
    EQUIV           reduce using rule 139 (primary -> function_designator .)
    THEN            reduce using rule 139 (primary -> function_designator .)


state 150

    (138) primary -> variable .

    POWER           reduce using rule 138 (primary -> variable .)
    TIMES           reduce using rule 138 (primary -> variable .)
    DIV             reduce using rule 138 (primary -> variable .)
    MOD             reduce using rule 138 (primary -> variable .)
    PLUS            reduce using rule 138 (primary -> variable .)
    MINUS           reduce using rule 138 (primary -> variable .)
    STEP            reduce using rule 138 (primary -> variable .)
    WHILE           reduce using rule 138 (primary -> variable .)
    DO              reduce using rule 138 (primary -> variable .)
    COMMA           reduce using rule 138 (primary -> variable .)
    COLON           reduce using rule 138 (primary -> variable .)
    END             reduce using rule 138 (primary -> variable .)
    SEMICOLON       reduce using rule 138 (primary -> variable .)
    ELSE            reduce using rule 138 (primary -> variable .)
    RBBRACKET       reduce using rule 138 (primary -> variable .)
    RCBRACKET       reduce using rule 138 (primary -> variable .)
    UNTIL           reduce using rule 138 (primary -> variable .)
    LESS            reduce using rule 138 (primary -> variable .)
    NOTGREATER      reduce using rule 138 (primary -> variable .)
    EQUAL           reduce using rule 138 (primary -> variable .)
    NOTLESS         reduce using rule 138 (primary -> variable .)
    GREATER         reduce using rule 138 (primary -> variable .)
    NOTEQUAL        reduce using rule 138 (primary -> variable .)
    AND             reduce using rule 138 (primary -> variable .)
    OR              reduce using rule 138 (primary -> variable .)
    IMPL            reduce using rule 138 (primary -> variable .)
    EQUIV           reduce using rule 138 (primary -> variable .)
    THEN            reduce using rule 138 (primary -> variable .)


state 151

    (177) subscripted_variable -> array_identifier LBBRACKET subscript_list . RBBRACKET
    (179) subscript_list -> subscript_list . COMMA subscript_expression

    RBBRACKET       shift and go to state 223
    COMMA           shift and go to state 224


state 152

    (112) for_statement -> label COLON . for_statement
    (73) basic_statement -> label COLON . basic_statement
    (9) compound_statement -> label COLON . compound_statement
    (111) for_statement -> . for_clause statement
    (112) for_statement -> . label COLON for_statement
    (72) basic_statement -> . unlabelled_basic_statement
    (73) basic_statement -> . label COLON basic_statement
    (8) compound_statement -> . unlabelled_compound
    (9) compound_statement -> . label COLON compound_statement
    (113) for_clause -> . FOR variable ASSIGNMENT for_list DO
    (74) label -> . IDENTIFIER
    (75) label -> . unsigned_integer
    (76) unlabelled_basic_statement -> .
    (77) unlabelled_basic_statement -> . assignment_statement
    (78) unlabelled_basic_statement -> . go_to_statement
    (79) unlabelled_basic_statement -> . procedure_statement
    (10) unlabelled_compound -> . BEGIN compound_tail
    (147) unsigned_integer -> . DIGIT
    (148) unsigned_integer -> . unsigned_integer DIGIT
    (80) assignment_statement -> . left_part_list arithmetic_expression
    (81) assignment_statement -> . left_part_list boolean_expression
    (86) go_to_statement -> . GOTO designational_expression
    (93) procedure_statement -> . procedure_identifier actual_parameter_part
    (82) left_part_list -> . left_part
    (83) left_part_list -> . left_part_list left_part
    (44) procedure_identifier -> . IDENTIFIER
    (84) left_part -> . variable ASSIGNMENT
    (85) left_part -> . procedure_identifier ASSIGNMENT
    (173) variable -> . simple_variable
    (174) variable -> . subscripted_variable
    (175) simple_variable -> . variable_identifier
    (177) subscripted_variable -> . array_identifier LBBRACKET subscript_list RBBRACKET
    (176) variable_identifier -> . IDENTIFIER
    (31) array_identifier -> . IDENTIFIER

    FOR             shift and go to state 37
    IDENTIFIER      shift and go to state 47
    ELSE            reduce using rule 76 (unlabelled_basic_statement -> .)
    END             reduce using rule 76 (unlabelled_basic_statement -> .)
    SEMICOLON       reduce using rule 76 (unlabelled_basic_statement -> .)
    BEGIN           shift and go to state 140
    DIGIT           shift and go to state 6
    GOTO            shift and go to state 20

    subscripted_variable           shift and go to state 13
    unlabelled_compound            shift and go to state 2
    left_part                      shift and go to state 34
    left_part_list                 shift and go to state 40
    compound_statement             shift and go to state 141
    assignment_statement           shift and go to state 23
    procedure_statement            shift and go to state 24
    label                          shift and go to state 60
    basic_statement                shift and go to state 154
    for_statement                  shift and go to state 155
    go_to_statement                shift and go to state 38
    variable_identifier            shift and go to state 41
    array_identifier               shift and go to state 14
    variable                       shift and go to state 43
    procedure_identifier           shift and go to state 21
    simple_variable                shift and go to state 49
    unlabelled_basic_statement     shift and go to state 50
    for_clause                     shift and go to state 52
    unsigned_integer               shift and go to state 9

state 153

    (108) conditional_statement -> label COLON conditional_statement .

    END             reduce using rule 108 (conditional_statement -> label COLON conditional_statement .)
    SEMICOLON       reduce using rule 108 (conditional_statement -> label COLON conditional_statement .)


state 154

    (73) basic_statement -> label COLON basic_statement .

    END             reduce using rule 73 (basic_statement -> label COLON basic_statement .)
    SEMICOLON       reduce using rule 73 (basic_statement -> label COLON basic_statement .)
    ELSE            reduce using rule 73 (basic_statement -> label COLON basic_statement .)


state 155

    (112) for_statement -> label COLON for_statement .

    END             reduce using rule 112 (for_statement -> label COLON for_statement .)
    SEMICOLON       reduce using rule 112 (for_statement -> label COLON for_statement .)


state 156

    (88) designational_expression -> if_clause simple_designational_expression . ELSE designational_expression

    ELSE            shift and go to state 225


state 157

    (92) switch_designator -> switch_identifier LBBRACKET . subscript_expression RBBRACKET
    (180) subscript_expression -> . arithmetic_expression
    (122) arithmetic_expression -> . simple_arithmetic_expression
    (123) arithmetic_expression -> . if_clause simple_arithmetic_expression ELSE arithmetic_expression
    (124) simple_arithmetic_expression -> . term
    (125) simple_arithmetic_expression -> . adding_operator term
    (126) simple_arithmetic_expression -> . simple_arithmetic_expression adding_operator term
    (110) if_clause -> . IF boolean_expression THEN
    (129) term -> . factor
    (130) term -> . term multiplying_operator factor
    (127) adding_operator -> . PLUS
    (128) adding_operator -> . MINUS
    (134) factor -> . primary
    (135) factor -> . factor
    (136) factor -> . factor POWER primary
    (137) primary -> . unsigned_number
    (138) primary -> . variable
    (139) primary -> . function_designator
    (140) primary -> . LCBRACKET arithmetic_expression RCBRACKET
    (141) unsigned_number -> . decimal_number
    (142) unsigned_number -> . exponential_part
    (143) unsigned_number -> . decimal_number exponential_part
    (173) variable -> . simple_variable
    (174) variable -> . subscripted_variable
    (172) function_designator -> . procedure_identifier actual_parameter_part
    (144) decimal_number -> . unsigned_integer
    (145) decimal_number -> . decimal_fraction
    (146) decimal_number -> . unsigned_integer decimal_fraction
    (150) exponential_part -> . EREAL integer
    (175) simple_variable -> . variable_identifier
    (177) subscripted_variable -> . array_identifier LBBRACKET subscript_list RBBRACKET
    (44) procedure_identifier -> . IDENTIFIER
    (147) unsigned_integer -> . DIGIT
    (148) unsigned_integer -> . unsigned_integer DIGIT
    (149) decimal_fraction -> . DOT unsigned_integer
    (176) variable_identifier -> . IDENTIFIER
    (31) array_identifier -> . IDENTIFIER

    IF              shift and go to state 45
    PLUS            shift and go to state 102
    MINUS           shift and go to state 94
    LCBRACKET       shift and go to state 145
    EREAL           shift and go to state 115
    IDENTIFIER      shift and go to state 106
    DIGIT           shift and go to state 6
    DOT             shift and go to state 95

    subscripted_variable           shift and go to state 13
    primary                        shift and go to state 98
    if_clause                      shift and go to state 144
    subscript_expression           shift and go to state 226
    decimal_fraction               shift and go to state 103
    factor                         shift and go to state 104
    unsigned_number                shift and go to state 105
    simple_arithmetic_expression   shift and go to state 147
    arithmetic_expression          shift and go to state 148
    decimal_number                 shift and go to state 112
    variable_identifier            shift and go to state 41
    function_designator            shift and go to state 149
    array_identifier               shift and go to state 14
    variable                       shift and go to state 150
    exponential_part               shift and go to state 92
    term                           shift and go to state 113
    procedure_identifier           shift and go to state 125
    simple_variable                shift and go to state 49
    adding_operator                shift and go to state 117
    unsigned_integer               shift and go to state 120

state 158

    (91) simple_designational_expression -> LCBRACKET designational_expression . RCBRACKET

    RCBRACKET       shift and go to state 227


state 159

    (95) actual_parameter_part -> LCBRACKET actual_parameter_list . RCBRACKET
    (97) actual_parameter_list -> actual_parameter_list . parameter_delimiter actual_parameter
    (98) parameter_delimiter -> . COMMA
    (99) parameter_delimiter -> . RCBRACKET letter_string COLON LCBRACKET

    RCBRACKET       shift and go to state 228
    COMMA           shift and go to state 230

    parameter_delimiter            shift and go to state 229

state 160

    (123) arithmetic_expression -> if_clause . simple_arithmetic_expression ELSE arithmetic_expression
    (155) boolean_expression -> if_clause . simple_boolean ELSE boolean_expression
    (88) designational_expression -> if_clause . simple_designational_expression ELSE designational_expression
    (124) simple_arithmetic_expression -> . term
    (125) simple_arithmetic_expression -> . adding_operator term
    (126) simple_arithmetic_expression -> . simple_arithmetic_expression adding_operator term
    (156) simple_boolean -> . implication
    (157) simple_boolean -> . simple_boolean EQUIV implication
    (89) simple_designational_expression -> . label
    (90) simple_designational_expression -> . switch_designator
    (91) simple_designational_expression -> . LCBRACKET designational_expression RCBRACKET
    (129) term -> . factor
    (130) term -> . term multiplying_operator factor
    (127) adding_operator -> . PLUS
    (128) adding_operator -> . MINUS
    (158) implication -> . boolean_term
    (159) implication -> . implication IMPL boolean_term
    (74) label -> . IDENTIFIER
    (75) label -> . unsigned_integer
    (92) switch_designator -> . switch_identifier LBBRACKET subscript_expression RBBRACKET
    (134) factor -> . primary
    (135) factor -> . factor
    (136) factor -> . factor POWER primary
    (160) boolean_term -> . boolean_factor
    (161) boolean_term -> . boolean_term OR boolean_factor
    (147) unsigned_integer -> . DIGIT
    (148) unsigned_integer -> . unsigned_integer DIGIT
    (38) switch_identifier -> . IDENTIFIER
    (137) primary -> . unsigned_number
    (138) primary -> . variable
    (139) primary -> . function_designator
    (140) primary -> . LCBRACKET arithmetic_expression RCBRACKET
    (162) boolean_factor -> . boolean_secondary
    (163) boolean_factor -> . boolean_factor AND boolean_secondary
    (141) unsigned_number -> . decimal_number
    (142) unsigned_number -> . exponential_part
    (143) unsigned_number -> . decimal_number exponential_part
    (173) variable -> . simple_variable
    (174) variable -> . subscripted_variable
    (172) function_designator -> . procedure_identifier actual_parameter_part
    (164) boolean_secondary -> . boolean_primary
    (165) boolean_secondary -> . NOT boolean_primary
    (144) decimal_number -> . unsigned_integer
    (145) decimal_number -> . decimal_fraction
    (146) decimal_number -> . unsigned_integer decimal_fraction
    (150) exponential_part -> . EREAL integer
    (175) simple_variable -> . variable_identifier
    (177) subscripted_variable -> . array_identifier LBBRACKET subscript_list RBBRACKET
    (44) procedure_identifier -> . IDENTIFIER
    (166) boolean_primary -> . logical_value
    (167) boolean_primary -> . variable
    (168) boolean_primary -> . function_designator
    (169) boolean_primary -> . relation
    (170) boolean_primary -> . LCBRACKET boolean_expression RCBRACKET
    (149) decimal_fraction -> . DOT unsigned_integer
    (176) variable_identifier -> . IDENTIFIER
    (31) array_identifier -> . IDENTIFIER
    (184) logical_value -> . TRUE
    (185) logical_value -> . FALSE
    (171) relation -> . simple_arithmetic_expression relational_operator simple_arithmetic_expression

    LCBRACKET       shift and go to state 169
    PLUS            shift and go to state 102
    MINUS           shift and go to state 94
    IDENTIFIER      shift and go to state 231
    DIGIT           shift and go to state 6
    NOT             shift and go to state 118
    EREAL           shift and go to state 115
    DOT             shift and go to state 95
    TRUE            shift and go to state 93
    FALSE           shift and go to state 100

    boolean_primary                shift and go to state 99
    procedure_identifier           shift and go to state 125
    primary                        shift and go to state 98
    boolean_factor                 shift and go to state 90
    relation                       shift and go to state 91
    simple_boolean                 shift and go to state 186
    boolean_secondary              shift and go to state 101
    label                          shift and go to state 67
    decimal_fraction               shift and go to state 103
    switch_identifier              shift and go to state 68
    unsigned_number                shift and go to state 105
    simple_arithmetic_expression   shift and go to state 185
    simple_designational_expression shift and go to state 156
    logical_value                  shift and go to state 109
    factor                         shift and go to state 104
    decimal_number                 shift and go to state 112
    boolean_term                   shift and go to state 88
    variable_identifier            shift and go to state 41
    function_designator            shift and go to state 110
    array_identifier               shift and go to state 14
    variable                       shift and go to state 161
    exponential_part               shift and go to state 92
    term                           shift and go to state 113
    switch_designator              shift and go to state 65
    subscripted_variable           shift and go to state 13
    simple_variable                shift and go to state 49
    adding_operator                shift and go to state 117
    implication                    shift and go to state 119
    unsigned_integer               shift and go to state 174

state 161

    (138) primary -> variable .
    (167) boolean_primary -> variable .

  ! reduce/reduce conflict for ELSE resolved using rule 138 (primary -> variable .)
  ! reduce/reduce conflict for RCBRACKET resolved using rule 138 (primary -> variable .)
  ! reduce/reduce conflict for COMMA resolved using rule 138 (primary -> variable .)
    POWER           reduce using rule 138 (primary -> variable .)
    TIMES           reduce using rule 138 (primary -> variable .)
    DIV             reduce using rule 138 (primary -> variable .)
    MOD             reduce using rule 138 (primary -> variable .)
    PLUS            reduce using rule 138 (primary -> variable .)
    MINUS           reduce using rule 138 (primary -> variable .)
    LESS            reduce using rule 138 (primary -> variable .)
    NOTGREATER      reduce using rule 138 (primary -> variable .)
    EQUAL           reduce using rule 138 (primary -> variable .)
    NOTLESS         reduce using rule 138 (primary -> variable .)
    GREATER         reduce using rule 138 (primary -> variable .)
    NOTEQUAL        reduce using rule 138 (primary -> variable .)
    RCBRACKET       reduce using rule 138 (primary -> variable .)
    ELSE            reduce using rule 138 (primary -> variable .)
    COMMA           reduce using rule 138 (primary -> variable .)
    AND             reduce using rule 167 (boolean_primary -> variable .)
    OR              reduce using rule 167 (boolean_primary -> variable .)
    IMPL            reduce using rule 167 (boolean_primary -> variable .)
    EQUIV           reduce using rule 167 (boolean_primary -> variable .)

  ! ELSE            [ reduce using rule 167 (boolean_primary -> variable .) ]
  ! RCBRACKET       [ reduce using rule 167 (boolean_primary -> variable .) ]
  ! COMMA           [ reduce using rule 167 (boolean_primary -> variable .) ]


state 162

    (96) actual_parameter_list -> actual_parameter .

    RCBRACKET       reduce using rule 96 (actual_parameter_list -> actual_parameter .)
    COMMA           reduce using rule 96 (actual_parameter_list -> actual_parameter .)


state 163

    (103) actual_parameter -> switch_identifier .
    (92) switch_designator -> switch_identifier . LBBRACKET subscript_expression RBBRACKET

    RCBRACKET       reduce using rule 103 (actual_parameter -> switch_identifier .)
    COMMA           reduce using rule 103 (actual_parameter -> switch_identifier .)
    LBBRACKET       shift and go to state 157


state 164

    (181) string -> STRING .

    RCBRACKET       reduce using rule 181 (string -> STRING .)
    COMMA           reduce using rule 181 (string -> STRING .)


state 165

    (31) array_identifier -> IDENTIFIER .
    (38) switch_identifier -> IDENTIFIER .
    (44) procedure_identifier -> IDENTIFIER .
    (74) label -> IDENTIFIER .
    (176) variable_identifier -> IDENTIFIER .

  ! reduce/reduce conflict for LBBRACKET resolved using rule 31 (array_identifier -> IDENTIFIER .)
  ! reduce/reduce conflict for RCBRACKET resolved using rule 31 (array_identifier -> IDENTIFIER .)
  ! reduce/reduce conflict for COMMA resolved using rule 31 (array_identifier -> IDENTIFIER .)
  ! reduce/reduce conflict for RCBRACKET resolved using rule 31 (array_identifier -> IDENTIFIER .)
  ! reduce/reduce conflict for COMMA resolved using rule 31 (array_identifier -> IDENTIFIER .)
  ! reduce/reduce conflict for RCBRACKET resolved using rule 31 (array_identifier -> IDENTIFIER .)
  ! reduce/reduce conflict for COMMA resolved using rule 31 (array_identifier -> IDENTIFIER .)
  ! reduce/reduce conflict for POWER resolved using rule 44 (procedure_identifier -> IDENTIFIER .)
  ! reduce/reduce conflict for TIMES resolved using rule 44 (procedure_identifier -> IDENTIFIER .)
  ! reduce/reduce conflict for DIV resolved using rule 44 (procedure_identifier -> IDENTIFIER .)
  ! reduce/reduce conflict for MOD resolved using rule 44 (procedure_identifier -> IDENTIFIER .)
  ! reduce/reduce conflict for PLUS resolved using rule 44 (procedure_identifier -> IDENTIFIER .)
  ! reduce/reduce conflict for MINUS resolved using rule 44 (procedure_identifier -> IDENTIFIER .)
  ! reduce/reduce conflict for LESS resolved using rule 44 (procedure_identifier -> IDENTIFIER .)
  ! reduce/reduce conflict for NOTGREATER resolved using rule 44 (procedure_identifier -> IDENTIFIER .)
  ! reduce/reduce conflict for EQUAL resolved using rule 44 (procedure_identifier -> IDENTIFIER .)
  ! reduce/reduce conflict for NOTLESS resolved using rule 44 (procedure_identifier -> IDENTIFIER .)
  ! reduce/reduce conflict for GREATER resolved using rule 44 (procedure_identifier -> IDENTIFIER .)
  ! reduce/reduce conflict for NOTEQUAL resolved using rule 44 (procedure_identifier -> IDENTIFIER .)
  ! reduce/reduce conflict for RCBRACKET resolved using rule 31 (array_identifier -> IDENTIFIER .)
  ! reduce/reduce conflict for COMMA resolved using rule 31 (array_identifier -> IDENTIFIER .)
  ! reduce/reduce conflict for AND resolved using rule 44 (procedure_identifier -> IDENTIFIER .)
  ! reduce/reduce conflict for OR resolved using rule 44 (procedure_identifier -> IDENTIFIER .)
  ! reduce/reduce conflict for IMPL resolved using rule 44 (procedure_identifier -> IDENTIFIER .)
  ! reduce/reduce conflict for EQUIV resolved using rule 44 (procedure_identifier -> IDENTIFIER .)
    LBBRACKET       reduce using rule 31 (array_identifier -> IDENTIFIER .)
    RCBRACKET       reduce using rule 31 (array_identifier -> IDENTIFIER .)
    COMMA           reduce using rule 31 (array_identifier -> IDENTIFIER .)
    LCBRACKET       reduce using rule 44 (procedure_identifier -> IDENTIFIER .)
    POWER           reduce using rule 44 (procedure_identifier -> IDENTIFIER .)
    TIMES           reduce using rule 44 (procedure_identifier -> IDENTIFIER .)
    DIV             reduce using rule 44 (procedure_identifier -> IDENTIFIER .)
    MOD             reduce using rule 44 (procedure_identifier -> IDENTIFIER .)
    PLUS            reduce using rule 44 (procedure_identifier -> IDENTIFIER .)
    MINUS           reduce using rule 44 (procedure_identifier -> IDENTIFIER .)
    LESS            reduce using rule 44 (procedure_identifier -> IDENTIFIER .)
    NOTGREATER      reduce using rule 44 (procedure_identifier -> IDENTIFIER .)
    EQUAL           reduce using rule 44 (procedure_identifier -> IDENTIFIER .)
    NOTLESS         reduce using rule 44 (procedure_identifier -> IDENTIFIER .)
    GREATER         reduce using rule 44 (procedure_identifier -> IDENTIFIER .)
    NOTEQUAL        reduce using rule 44 (procedure_identifier -> IDENTIFIER .)
    AND             reduce using rule 44 (procedure_identifier -> IDENTIFIER .)
    OR              reduce using rule 44 (procedure_identifier -> IDENTIFIER .)
    IMPL            reduce using rule 44 (procedure_identifier -> IDENTIFIER .)
    EQUIV           reduce using rule 44 (procedure_identifier -> IDENTIFIER .)

  ! LBBRACKET       [ reduce using rule 38 (switch_identifier -> IDENTIFIER .) ]
  ! RCBRACKET       [ reduce using rule 38 (switch_identifier -> IDENTIFIER .) ]
  ! COMMA           [ reduce using rule 38 (switch_identifier -> IDENTIFIER .) ]
  ! RCBRACKET       [ reduce using rule 44 (procedure_identifier -> IDENTIFIER .) ]
  ! COMMA           [ reduce using rule 44 (procedure_identifier -> IDENTIFIER .) ]
  ! RCBRACKET       [ reduce using rule 74 (label -> IDENTIFIER .) ]
  ! COMMA           [ reduce using rule 74 (label -> IDENTIFIER .) ]
  ! POWER           [ reduce using rule 176 (variable_identifier -> IDENTIFIER .) ]
  ! TIMES           [ reduce using rule 176 (variable_identifier -> IDENTIFIER .) ]
  ! DIV             [ reduce using rule 176 (variable_identifier -> IDENTIFIER .) ]
  ! MOD             [ reduce using rule 176 (variable_identifier -> IDENTIFIER .) ]
  ! PLUS            [ reduce using rule 176 (variable_identifier -> IDENTIFIER .) ]
  ! MINUS           [ reduce using rule 176 (variable_identifier -> IDENTIFIER .) ]
  ! LESS            [ reduce using rule 176 (variable_identifier -> IDENTIFIER .) ]
  ! NOTGREATER      [ reduce using rule 176 (variable_identifier -> IDENTIFIER .) ]
  ! EQUAL           [ reduce using rule 176 (variable_identifier -> IDENTIFIER .) ]
  ! NOTLESS         [ reduce using rule 176 (variable_identifier -> IDENTIFIER .) ]
  ! GREATER         [ reduce using rule 176 (variable_identifier -> IDENTIFIER .) ]
  ! NOTEQUAL        [ reduce using rule 176 (variable_identifier -> IDENTIFIER .) ]
  ! RCBRACKET       [ reduce using rule 176 (variable_identifier -> IDENTIFIER .) ]
  ! COMMA           [ reduce using rule 176 (variable_identifier -> IDENTIFIER .) ]
  ! AND             [ reduce using rule 176 (variable_identifier -> IDENTIFIER .) ]
  ! OR              [ reduce using rule 176 (variable_identifier -> IDENTIFIER .) ]
  ! IMPL            [ reduce using rule 176 (variable_identifier -> IDENTIFIER .) ]
  ! EQUIV           [ reduce using rule 176 (variable_identifier -> IDENTIFIER .) ]


state 166

    (119) expression -> arithmetic_expression .

    RCBRACKET       reduce using rule 119 (expression -> arithmetic_expression .)
    COMMA           reduce using rule 119 (expression -> arithmetic_expression .)


state 167

    (100) actual_parameter -> string .

    RCBRACKET       reduce using rule 100 (actual_parameter -> string .)
    COMMA           reduce using rule 100 (actual_parameter -> string .)


state 168

    (102) actual_parameter -> array_identifier .
    (177) subscripted_variable -> array_identifier . LBBRACKET subscript_list RBBRACKET

    RCBRACKET       reduce using rule 102 (actual_parameter -> array_identifier .)
    COMMA           reduce using rule 102 (actual_parameter -> array_identifier .)
    LBBRACKET       shift and go to state 59


state 169

    (91) simple_designational_expression -> LCBRACKET . designational_expression RCBRACKET
    (140) primary -> LCBRACKET . arithmetic_expression RCBRACKET
    (170) boolean_primary -> LCBRACKET . boolean_expression RCBRACKET
    (87) designational_expression -> . simple_designational_expression
    (88) designational_expression -> . if_clause simple_designational_expression ELSE designational_expression
    (122) arithmetic_expression -> . simple_arithmetic_expression
    (123) arithmetic_expression -> . if_clause simple_arithmetic_expression ELSE arithmetic_expression
    (154) boolean_expression -> . simple_boolean
    (155) boolean_expression -> . if_clause simple_boolean ELSE boolean_expression
    (89) simple_designational_expression -> . label
    (90) simple_designational_expression -> . switch_designator
    (91) simple_designational_expression -> . LCBRACKET designational_expression RCBRACKET
    (110) if_clause -> . IF boolean_expression THEN
    (124) simple_arithmetic_expression -> . term
    (125) simple_arithmetic_expression -> . adding_operator term
    (126) simple_arithmetic_expression -> . simple_arithmetic_expression adding_operator term
    (156) simple_boolean -> . implication
    (157) simple_boolean -> . simple_boolean EQUIV implication
    (74) label -> . IDENTIFIER
    (75) label -> . unsigned_integer
    (92) switch_designator -> . switch_identifier LBBRACKET subscript_expression RBBRACKET
    (129) term -> . factor
    (130) term -> . term multiplying_operator factor
    (127) adding_operator -> . PLUS
    (128) adding_operator -> . MINUS
    (158) implication -> . boolean_term
    (159) implication -> . implication IMPL boolean_term
    (147) unsigned_integer -> . DIGIT
    (148) unsigned_integer -> . unsigned_integer DIGIT
    (38) switch_identifier -> . IDENTIFIER
    (134) factor -> . primary
    (135) factor -> . factor
    (136) factor -> . factor POWER primary
    (160) boolean_term -> . boolean_factor
    (161) boolean_term -> . boolean_term OR boolean_factor
    (137) primary -> . unsigned_number
    (138) primary -> . variable
    (139) primary -> . function_designator
    (140) primary -> . LCBRACKET arithmetic_expression RCBRACKET
    (162) boolean_factor -> . boolean_secondary
    (163) boolean_factor -> . boolean_factor AND boolean_secondary
    (141) unsigned_number -> . decimal_number
    (142) unsigned_number -> . exponential_part
    (143) unsigned_number -> . decimal_number exponential_part
    (173) variable -> . simple_variable
    (174) variable -> . subscripted_variable
    (172) function_designator -> . procedure_identifier actual_parameter_part
    (164) boolean_secondary -> . boolean_primary
    (165) boolean_secondary -> . NOT boolean_primary
    (144) decimal_number -> . unsigned_integer
    (145) decimal_number -> . decimal_fraction
    (146) decimal_number -> . unsigned_integer decimal_fraction
    (150) exponential_part -> . EREAL integer
    (175) simple_variable -> . variable_identifier
    (177) subscripted_variable -> . array_identifier LBBRACKET subscript_list RBBRACKET
    (44) procedure_identifier -> . IDENTIFIER
    (166) boolean_primary -> . logical_value
    (167) boolean_primary -> . variable
    (168) boolean_primary -> . function_designator
    (169) boolean_primary -> . relation
    (170) boolean_primary -> . LCBRACKET boolean_expression RCBRACKET
    (149) decimal_fraction -> . DOT unsigned_integer
    (176) variable_identifier -> . IDENTIFIER
    (31) array_identifier -> . IDENTIFIER
    (184) logical_value -> . TRUE
    (185) logical_value -> . FALSE
    (171) relation -> . simple_arithmetic_expression relational_operator simple_arithmetic_expression

    LCBRACKET       shift and go to state 169
    IF              shift and go to state 45
    IDENTIFIER      shift and go to state 231
    PLUS            shift and go to state 102
    MINUS           shift and go to state 94
    DIGIT           shift and go to state 6
    NOT             shift and go to state 118
    EREAL           shift and go to state 115
    DOT             shift and go to state 95
    TRUE            shift and go to state 93
    FALSE           shift and go to state 100

    boolean_primary                shift and go to state 99
    procedure_identifier           shift and go to state 125
    primary                        shift and go to state 98
    if_clause                      shift and go to state 232
    boolean_factor                 shift and go to state 90
    relation                       shift and go to state 91
    simple_boolean                 shift and go to state 97
    boolean_secondary              shift and go to state 101
    label                          shift and go to state 67
    decimal_fraction               shift and go to state 103
    factor                         shift and go to state 104
    unsigned_number                shift and go to state 105
    simple_arithmetic_expression   shift and go to state 107
    arithmetic_expression          shift and go to state 208
    simple_designational_expression shift and go to state 71
    logical_value                  shift and go to state 109
    switch_identifier              shift and go to state 68
    decimal_number                 shift and go to state 112
    boolean_term                   shift and go to state 88
    variable_identifier            shift and go to state 41
    function_designator            shift and go to state 110
    array_identifier               shift and go to state 14
    variable                       shift and go to state 161
    exponential_part               shift and go to state 92
    term                           shift and go to state 113
    designational_expression       shift and go to state 158
    boolean_expression             shift and go to state 209
    switch_designator              shift and go to state 65
    subscripted_variable           shift and go to state 13
    simple_variable                shift and go to state 49
    adding_operator                shift and go to state 117
    implication                    shift and go to state 119
    unsigned_integer               shift and go to state 174

state 170

    (121) expression -> designational_expression .

    RCBRACKET       reduce using rule 121 (expression -> designational_expression .)
    COMMA           reduce using rule 121 (expression -> designational_expression .)


state 171

    (120) expression -> boolean_expression .

    RCBRACKET       reduce using rule 120 (expression -> boolean_expression .)
    COMMA           reduce using rule 120 (expression -> boolean_expression .)


state 172

    (104) actual_parameter -> procedure_identifier .
    (172) function_designator -> procedure_identifier . actual_parameter_part
    (94) actual_parameter_part -> .
    (95) actual_parameter_part -> . LCBRACKET actual_parameter_list RCBRACKET

  ! reduce/reduce conflict for RCBRACKET resolved using rule 94 (actual_parameter_part -> .)
  ! reduce/reduce conflict for COMMA resolved using rule 94 (actual_parameter_part -> .)
    POWER           reduce using rule 94 (actual_parameter_part -> .)
    TIMES           reduce using rule 94 (actual_parameter_part -> .)
    DIV             reduce using rule 94 (actual_parameter_part -> .)
    MOD             reduce using rule 94 (actual_parameter_part -> .)
    PLUS            reduce using rule 94 (actual_parameter_part -> .)
    MINUS           reduce using rule 94 (actual_parameter_part -> .)
    LESS            reduce using rule 94 (actual_parameter_part -> .)
    NOTGREATER      reduce using rule 94 (actual_parameter_part -> .)
    EQUAL           reduce using rule 94 (actual_parameter_part -> .)
    NOTLESS         reduce using rule 94 (actual_parameter_part -> .)
    GREATER         reduce using rule 94 (actual_parameter_part -> .)
    NOTEQUAL        reduce using rule 94 (actual_parameter_part -> .)
    RCBRACKET       reduce using rule 94 (actual_parameter_part -> .)
    COMMA           reduce using rule 94 (actual_parameter_part -> .)
    AND             reduce using rule 94 (actual_parameter_part -> .)
    OR              reduce using rule 94 (actual_parameter_part -> .)
    IMPL            reduce using rule 94 (actual_parameter_part -> .)
    EQUIV           reduce using rule 94 (actual_parameter_part -> .)
    LCBRACKET       shift and go to state 73

  ! RCBRACKET       [ reduce using rule 104 (actual_parameter -> procedure_identifier .) ]
  ! COMMA           [ reduce using rule 104 (actual_parameter -> procedure_identifier .) ]

    actual_parameter_part          shift and go to state 183

state 173

    (101) actual_parameter -> expression .

    RCBRACKET       reduce using rule 101 (actual_parameter -> expression .)
    COMMA           reduce using rule 101 (actual_parameter -> expression .)


state 174

    (75) label -> unsigned_integer .
    (148) unsigned_integer -> unsigned_integer . DIGIT
    (144) decimal_number -> unsigned_integer .
    (146) decimal_number -> unsigned_integer . decimal_fraction
    (149) decimal_fraction -> . DOT unsigned_integer

  ! reduce/reduce conflict for ELSE resolved using rule 75 (label -> unsigned_integer .)
  ! reduce/reduce conflict for RCBRACKET resolved using rule 75 (label -> unsigned_integer .)
  ! reduce/reduce conflict for COMMA resolved using rule 75 (label -> unsigned_integer .)
    ELSE            reduce using rule 75 (label -> unsigned_integer .)
    RCBRACKET       reduce using rule 75 (label -> unsigned_integer .)
    COMMA           reduce using rule 75 (label -> unsigned_integer .)
    DIGIT           shift and go to state 57
    EREAL           reduce using rule 144 (decimal_number -> unsigned_integer .)
    POWER           reduce using rule 144 (decimal_number -> unsigned_integer .)
    TIMES           reduce using rule 144 (decimal_number -> unsigned_integer .)
    DIV             reduce using rule 144 (decimal_number -> unsigned_integer .)
    MOD             reduce using rule 144 (decimal_number -> unsigned_integer .)
    PLUS            reduce using rule 144 (decimal_number -> unsigned_integer .)
    MINUS           reduce using rule 144 (decimal_number -> unsigned_integer .)
    LESS            reduce using rule 144 (decimal_number -> unsigned_integer .)
    NOTGREATER      reduce using rule 144 (decimal_number -> unsigned_integer .)
    EQUAL           reduce using rule 144 (decimal_number -> unsigned_integer .)
    NOTLESS         reduce using rule 144 (decimal_number -> unsigned_integer .)
    GREATER         reduce using rule 144 (decimal_number -> unsigned_integer .)
    NOTEQUAL        reduce using rule 144 (decimal_number -> unsigned_integer .)
    DOT             shift and go to state 95

  ! ELSE            [ reduce using rule 144 (decimal_number -> unsigned_integer .) ]
  ! RCBRACKET       [ reduce using rule 144 (decimal_number -> unsigned_integer .) ]
  ! COMMA           [ reduce using rule 144 (decimal_number -> unsigned_integer .) ]

    decimal_fraction               shift and go to state 213

state 175

    (37) switch_declaration -> SWITCH switch_identifier ASSIGNMENT . switch_list
    (39) switch_list -> . designational_expression
    (40) switch_list -> . switch_list COMMA designational_expression
    (87) designational_expression -> . simple_designational_expression
    (88) designational_expression -> . if_clause simple_designational_expression ELSE designational_expression
    (89) simple_designational_expression -> . label
    (90) simple_designational_expression -> . switch_designator
    (91) simple_designational_expression -> . LCBRACKET designational_expression RCBRACKET
    (110) if_clause -> . IF boolean_expression THEN
    (74) label -> . IDENTIFIER
    (75) label -> . unsigned_integer
    (92) switch_designator -> . switch_identifier LBBRACKET subscript_expression RBBRACKET
    (147) unsigned_integer -> . DIGIT
    (148) unsigned_integer -> . unsigned_integer DIGIT
    (38) switch_identifier -> . IDENTIFIER

    LCBRACKET       shift and go to state 69
    IF              shift and go to state 45
    IDENTIFIER      shift and go to state 70
    DIGIT           shift and go to state 6

    designational_expression       shift and go to state 234
    simple_designational_expression shift and go to state 71
    switch_designator              shift and go to state 65
    if_clause                      shift and go to state 66
    label                          shift and go to state 67
    switch_identifier              shift and go to state 68
    switch_list                    shift and go to state 233
    unsigned_integer               shift and go to state 9

state 176

    (12) compound_tail -> statement SEMICOLON compound_tail .

    $end            reduce using rule 12 (compound_tail -> statement SEMICOLON compound_tail .)
    END             reduce using rule 12 (compound_tail -> statement SEMICOLON compound_tail .)
    SEMICOLON       reduce using rule 12 (compound_tail -> statement SEMICOLON compound_tail .)
    ELSE            reduce using rule 12 (compound_tail -> statement SEMICOLON compound_tail .)


state 177

    (106) conditional_statement -> if_statement ELSE statement .

    END             reduce using rule 106 (conditional_statement -> if_statement ELSE statement .)
    SEMICOLON       reduce using rule 106 (conditional_statement -> if_statement ELSE statement .)


state 178

    (42) procedure_declaration -> type PROCEDURE procedure_heading . procedure_body
    (65) procedure_body -> . statement
    (66) statement -> . unconditional_statement
    (67) statement -> . conditional_statement
    (68) statement -> . for_statement
    (69) unconditional_statement -> . basic_statement
    (70) unconditional_statement -> . compound_statement
    (71) unconditional_statement -> . block
    (105) conditional_statement -> . if_statement
    (106) conditional_statement -> . if_statement ELSE statement
    (107) conditional_statement -> . if_clause for_statement
    (108) conditional_statement -> . label COLON conditional_statement
    (111) for_statement -> . for_clause statement
    (112) for_statement -> . label COLON for_statement
    (72) basic_statement -> . unlabelled_basic_statement
    (73) basic_statement -> . label COLON basic_statement
    (8) compound_statement -> . unlabelled_compound
    (9) compound_statement -> . label COLON compound_statement
    (3) block -> . unlabelled_block
    (4) block -> . TLABEL COLON block
    (109) if_statement -> . if_clause unconditional_statement
    (110) if_clause -> . IF boolean_expression THEN
    (74) label -> . IDENTIFIER
    (75) label -> . unsigned_integer
    (113) for_clause -> . FOR variable ASSIGNMENT for_list DO
    (76) unlabelled_basic_statement -> .
    (77) unlabelled_basic_statement -> . assignment_statement
    (78) unlabelled_basic_statement -> . go_to_statement
    (79) unlabelled_basic_statement -> . procedure_statement
    (10) unlabelled_compound -> . BEGIN compound_tail
    (5) unlabelled_block -> . block_head SEMICOLON compound_tail
    (147) unsigned_integer -> . DIGIT
    (148) unsigned_integer -> . unsigned_integer DIGIT
    (80) assignment_statement -> . left_part_list arithmetic_expression
    (81) assignment_statement -> . left_part_list boolean_expression
    (86) go_to_statement -> . GOTO designational_expression
    (93) procedure_statement -> . procedure_identifier actual_parameter_part
    (6) block_head -> . BEGIN declaration
    (7) block_head -> . block_head SEMICOLON declaration
    (82) left_part_list -> . left_part
    (83) left_part_list -> . left_part_list left_part
    (44) procedure_identifier -> . IDENTIFIER
    (84) left_part -> . variable ASSIGNMENT
    (85) left_part -> . procedure_identifier ASSIGNMENT
    (173) variable -> . simple_variable
    (174) variable -> . subscripted_variable
    (175) simple_variable -> . variable_identifier
    (177) subscripted_variable -> . array_identifier LBBRACKET subscript_list RBBRACKET
    (176) variable_identifier -> . IDENTIFIER
    (31) array_identifier -> . IDENTIFIER

    TLABEL          shift and go to state 4
    IF              shift and go to state 45
    IDENTIFIER      shift and go to state 47
    FOR             shift and go to state 37
    SEMICOLON       reduce using rule 76 (unlabelled_basic_statement -> .)
    BEGIN           shift and go to state 1
    DIGIT           shift and go to state 6
    GOTO            shift and go to state 20

    subscripted_variable           shift and go to state 13
    block                          shift and go to state 54
    unlabelled_compound            shift and go to state 2
    array_identifier               shift and go to state 14
    if_clause                      shift and go to state 16
    block_head                     shift and go to state 10
    conditional_statement          shift and go to state 25
    left_part                      shift and go to state 34
    left_part_list                 shift and go to state 40
    compound_statement             shift and go to state 22
    assignment_statement           shift and go to state 23
    procedure_statement            shift and go to state 24
    label                          shift and go to state 19
    statement                      shift and go to state 214
    if_statement                   shift and go to state 30
    basic_statement                shift and go to state 33
    for_statement                  shift and go to state 35
    go_to_statement                shift and go to state 38
    variable_identifier            shift and go to state 41
    variable                       shift and go to state 43
    unconditional_statement        shift and go to state 28
    unlabelled_block               shift and go to state 5
    procedure_identifier           shift and go to state 21
    simple_variable                shift and go to state 49
    unlabelled_basic_statement     shift and go to state 50
    for_clause                     shift and go to state 52
    procedure_body                 shift and go to state 235
    unsigned_integer               shift and go to state 9

state 179

    (29) array_segment -> array_identifier LBBRACKET . bound_pair_list RBBRACKET
    (32) bound_pair_list -> . bound_pair
    (33) bound_pair_list -> . bound_pair_list COMMA bound_pair
    (34) bound_pair -> . lower_bound COLON upper_bound
    (36) lower_bound -> . arithmetic_expression
    (122) arithmetic_expression -> . simple_arithmetic_expression
    (123) arithmetic_expression -> . if_clause simple_arithmetic_expression ELSE arithmetic_expression
    (124) simple_arithmetic_expression -> . term
    (125) simple_arithmetic_expression -> . adding_operator term
    (126) simple_arithmetic_expression -> . simple_arithmetic_expression adding_operator term
    (110) if_clause -> . IF boolean_expression THEN
    (129) term -> . factor
    (130) term -> . term multiplying_operator factor
    (127) adding_operator -> . PLUS
    (128) adding_operator -> . MINUS
    (134) factor -> . primary
    (135) factor -> . factor
    (136) factor -> . factor POWER primary
    (137) primary -> . unsigned_number
    (138) primary -> . variable
    (139) primary -> . function_designator
    (140) primary -> . LCBRACKET arithmetic_expression RCBRACKET
    (141) unsigned_number -> . decimal_number
    (142) unsigned_number -> . exponential_part
    (143) unsigned_number -> . decimal_number exponential_part
    (173) variable -> . simple_variable
    (174) variable -> . subscripted_variable
    (172) function_designator -> . procedure_identifier actual_parameter_part
    (144) decimal_number -> . unsigned_integer
    (145) decimal_number -> . decimal_fraction
    (146) decimal_number -> . unsigned_integer decimal_fraction
    (150) exponential_part -> . EREAL integer
    (175) simple_variable -> . variable_identifier
    (177) subscripted_variable -> . array_identifier LBBRACKET subscript_list RBBRACKET
    (44) procedure_identifier -> . IDENTIFIER
    (147) unsigned_integer -> . DIGIT
    (148) unsigned_integer -> . unsigned_integer DIGIT
    (149) decimal_fraction -> . DOT unsigned_integer
    (176) variable_identifier -> . IDENTIFIER
    (31) array_identifier -> . IDENTIFIER

    IF              shift and go to state 45
    PLUS            shift and go to state 102
    MINUS           shift and go to state 94
    LCBRACKET       shift and go to state 145
    EREAL           shift and go to state 115
    IDENTIFIER      shift and go to state 106
    DIGIT           shift and go to state 6
    DOT             shift and go to state 95

    subscripted_variable           shift and go to state 13
    primary                        shift and go to state 98
    if_clause                      shift and go to state 144
    unsigned_number                shift and go to state 105
    decimal_fraction               shift and go to state 103
    factor                         shift and go to state 104
    simple_arithmetic_expression   shift and go to state 147
    arithmetic_expression          shift and go to state 236
    lower_bound                    shift and go to state 237
    decimal_number                 shift and go to state 112
    variable_identifier            shift and go to state 41
    function_designator            shift and go to state 149
    array_identifier               shift and go to state 14
    variable                       shift and go to state 150
    bound_pair_list                shift and go to state 238
    exponential_part               shift and go to state 92
    term                           shift and go to state 113
    procedure_identifier           shift and go to state 125
    simple_variable                shift and go to state 49
    bound_pair                     shift and go to state 239
    adding_operator                shift and go to state 117
    unsigned_integer               shift and go to state 120

state 180

    (30) array_segment -> array_identifier COMMA . array_segment
    (29) array_segment -> . array_identifier LBBRACKET bound_pair_list RBBRACKET
    (30) array_segment -> . array_identifier COMMA array_segment
    (31) array_identifier -> . IDENTIFIER

    IDENTIFIER      shift and go to state 83

    array_segment                  shift and go to state 240
    array_identifier               shift and go to state 82

state 181

    (28) array_list -> array_list COMMA . array_segment
    (29) array_segment -> . array_identifier LBBRACKET bound_pair_list RBBRACKET
    (30) array_segment -> . array_identifier COMMA array_segment
    (31) array_identifier -> . IDENTIFIER

    IDENTIFIER      shift and go to state 83

    array_segment                  shift and go to state 241
    array_identifier               shift and go to state 82

state 182

    (113) for_clause -> FOR variable ASSIGNMENT . for_list DO
    (114) for_list -> . for_list_element
    (115) for_list -> . for_list COMMA for_list_element
    (116) for_list_element -> . arithmetic_expression
    (117) for_list_element -> . arithmetic_expression STEP arithmetic_expression UNTIL arithmetic_expression
    (118) for_list_element -> . arithmetic_expression WHILE boolean_expression
    (122) arithmetic_expression -> . simple_arithmetic_expression
    (123) arithmetic_expression -> . if_clause simple_arithmetic_expression ELSE arithmetic_expression
    (124) simple_arithmetic_expression -> . term
    (125) simple_arithmetic_expression -> . adding_operator term
    (126) simple_arithmetic_expression -> . simple_arithmetic_expression adding_operator term
    (110) if_clause -> . IF boolean_expression THEN
    (129) term -> . factor
    (130) term -> . term multiplying_operator factor
    (127) adding_operator -> . PLUS
    (128) adding_operator -> . MINUS
    (134) factor -> . primary
    (135) factor -> . factor
    (136) factor -> . factor POWER primary
    (137) primary -> . unsigned_number
    (138) primary -> . variable
    (139) primary -> . function_designator
    (140) primary -> . LCBRACKET arithmetic_expression RCBRACKET
    (141) unsigned_number -> . decimal_number
    (142) unsigned_number -> . exponential_part
    (143) unsigned_number -> . decimal_number exponential_part
    (173) variable -> . simple_variable
    (174) variable -> . subscripted_variable
    (172) function_designator -> . procedure_identifier actual_parameter_part
    (144) decimal_number -> . unsigned_integer
    (145) decimal_number -> . decimal_fraction
    (146) decimal_number -> . unsigned_integer decimal_fraction
    (150) exponential_part -> . EREAL integer
    (175) simple_variable -> . variable_identifier
    (177) subscripted_variable -> . array_identifier LBBRACKET subscript_list RBBRACKET
    (44) procedure_identifier -> . IDENTIFIER
    (147) unsigned_integer -> . DIGIT
    (148) unsigned_integer -> . unsigned_integer DIGIT
    (149) decimal_fraction -> . DOT unsigned_integer
    (176) variable_identifier -> . IDENTIFIER
    (31) array_identifier -> . IDENTIFIER

    IF              shift and go to state 45
    PLUS            shift and go to state 102
    MINUS           shift and go to state 94
    LCBRACKET       shift and go to state 145
    EREAL           shift and go to state 115
    IDENTIFIER      shift and go to state 106
    DIGIT           shift and go to state 6
    DOT             shift and go to state 95

    subscripted_variable           shift and go to state 13
    for_list_element               shift and go to state 242
    if_clause                      shift and go to state 144
    for_list                       shift and go to state 243
    unsigned_number                shift and go to state 105
    decimal_fraction               shift and go to state 103
    factor                         shift and go to state 104
    simple_arithmetic_expression   shift and go to state 147
    arithmetic_expression          shift and go to state 244
    decimal_number                 shift and go to state 112
    primary                        shift and go to state 98
    variable_identifier            shift and go to state 41
    function_designator            shift and go to state 149
    array_identifier               shift and go to state 14
    variable                       shift and go to state 150
    exponential_part               shift and go to state 92
    term                           shift and go to state 113
    procedure_identifier           shift and go to state 125
    simple_variable                shift and go to state 49
    adding_operator                shift and go to state 117
    unsigned_integer               shift and go to state 120

state 183

    (172) function_designator -> procedure_identifier actual_parameter_part .

    AND             reduce using rule 172 (function_designator -> procedure_identifier actual_parameter_part .)
    OR              reduce using rule 172 (function_designator -> procedure_identifier actual_parameter_part .)
    IMPL            reduce using rule 172 (function_designator -> procedure_identifier actual_parameter_part .)
    ELSE            reduce using rule 172 (function_designator -> procedure_identifier actual_parameter_part .)
    EQUIV           reduce using rule 172 (function_designator -> procedure_identifier actual_parameter_part .)
    POWER           reduce using rule 172 (function_designator -> procedure_identifier actual_parameter_part .)
    TIMES           reduce using rule 172 (function_designator -> procedure_identifier actual_parameter_part .)
    DIV             reduce using rule 172 (function_designator -> procedure_identifier actual_parameter_part .)
    MOD             reduce using rule 172 (function_designator -> procedure_identifier actual_parameter_part .)
    LESS            reduce using rule 172 (function_designator -> procedure_identifier actual_parameter_part .)
    NOTGREATER      reduce using rule 172 (function_designator -> procedure_identifier actual_parameter_part .)
    EQUAL           reduce using rule 172 (function_designator -> procedure_identifier actual_parameter_part .)
    NOTLESS         reduce using rule 172 (function_designator -> procedure_identifier actual_parameter_part .)
    GREATER         reduce using rule 172 (function_designator -> procedure_identifier actual_parameter_part .)
    NOTEQUAL        reduce using rule 172 (function_designator -> procedure_identifier actual_parameter_part .)
    PLUS            reduce using rule 172 (function_designator -> procedure_identifier actual_parameter_part .)
    MINUS           reduce using rule 172 (function_designator -> procedure_identifier actual_parameter_part .)
    END             reduce using rule 172 (function_designator -> procedure_identifier actual_parameter_part .)
    SEMICOLON       reduce using rule 172 (function_designator -> procedure_identifier actual_parameter_part .)
    THEN            reduce using rule 172 (function_designator -> procedure_identifier actual_parameter_part .)
    RCBRACKET       reduce using rule 172 (function_designator -> procedure_identifier actual_parameter_part .)
    COMMA           reduce using rule 172 (function_designator -> procedure_identifier actual_parameter_part .)
    DO              reduce using rule 172 (function_designator -> procedure_identifier actual_parameter_part .)
    STEP            reduce using rule 172 (function_designator -> procedure_identifier actual_parameter_part .)
    WHILE           reduce using rule 172 (function_designator -> procedure_identifier actual_parameter_part .)
    RBBRACKET       reduce using rule 172 (function_designator -> procedure_identifier actual_parameter_part .)
    COLON           reduce using rule 172 (function_designator -> procedure_identifier actual_parameter_part .)
    UNTIL           reduce using rule 172 (function_designator -> procedure_identifier actual_parameter_part .)


state 184

    (161) boolean_term -> boolean_term OR . boolean_factor
    (162) boolean_factor -> . boolean_secondary
    (163) boolean_factor -> . boolean_factor AND boolean_secondary
    (164) boolean_secondary -> . boolean_primary
    (165) boolean_secondary -> . NOT boolean_primary
    (166) boolean_primary -> . logical_value
    (167) boolean_primary -> . variable
    (168) boolean_primary -> . function_designator
    (169) boolean_primary -> . relation
    (170) boolean_primary -> . LCBRACKET boolean_expression RCBRACKET
    (184) logical_value -> . TRUE
    (185) logical_value -> . FALSE
    (173) variable -> . simple_variable
    (174) variable -> . subscripted_variable
    (172) function_designator -> . procedure_identifier actual_parameter_part
    (171) relation -> . simple_arithmetic_expression relational_operator simple_arithmetic_expression
    (175) simple_variable -> . variable_identifier
    (177) subscripted_variable -> . array_identifier LBBRACKET subscript_list RBBRACKET
    (44) procedure_identifier -> . IDENTIFIER
    (124) simple_arithmetic_expression -> . term
    (125) simple_arithmetic_expression -> . adding_operator term
    (126) simple_arithmetic_expression -> . simple_arithmetic_expression adding_operator term
    (176) variable_identifier -> . IDENTIFIER
    (31) array_identifier -> . IDENTIFIER
    (129) term -> . factor
    (130) term -> . term multiplying_operator factor
    (127) adding_operator -> . PLUS
    (128) adding_operator -> . MINUS
    (134) factor -> . primary
    (135) factor -> . factor
    (136) factor -> . factor POWER primary
    (137) primary -> . unsigned_number
    (138) primary -> . variable
    (139) primary -> . function_designator
    (140) primary -> . LCBRACKET arithmetic_expression RCBRACKET
    (141) unsigned_number -> . decimal_number
    (142) unsigned_number -> . exponential_part
    (143) unsigned_number -> . decimal_number exponential_part
    (144) decimal_number -> . unsigned_integer
    (145) decimal_number -> . decimal_fraction
    (146) decimal_number -> . unsigned_integer decimal_fraction
    (150) exponential_part -> . EREAL integer
    (147) unsigned_integer -> . DIGIT
    (148) unsigned_integer -> . unsigned_integer DIGIT
    (149) decimal_fraction -> . DOT unsigned_integer

    NOT             shift and go to state 118
    LCBRACKET       shift and go to state 127
    TRUE            shift and go to state 93
    FALSE           shift and go to state 100
    IDENTIFIER      shift and go to state 106
    PLUS            shift and go to state 102
    MINUS           shift and go to state 94
    EREAL           shift and go to state 115
    DIGIT           shift and go to state 6
    DOT             shift and go to state 95

    subscripted_variable           shift and go to state 13
    function_designator            shift and go to state 128
    boolean_factor                 shift and go to state 245
    relation                       shift and go to state 91
    boolean_secondary              shift and go to state 101
    unsigned_number                shift and go to state 105
    decimal_fraction               shift and go to state 103
    factor                         shift and go to state 104
    simple_arithmetic_expression   shift and go to state 131
    boolean_primary                shift and go to state 99
    logical_value                  shift and go to state 109
    decimal_number                 shift and go to state 112
    primary                        shift and go to state 98
    variable_identifier            shift and go to state 41
    array_identifier               shift and go to state 14
    variable                       shift and go to state 129
    exponential_part               shift and go to state 92
    term                           shift and go to state 113
    procedure_identifier           shift and go to state 125
    simple_variable                shift and go to state 49
    adding_operator                shift and go to state 117
    unsigned_integer               shift and go to state 120

state 185

    (123) arithmetic_expression -> if_clause simple_arithmetic_expression . ELSE arithmetic_expression
    (126) simple_arithmetic_expression -> simple_arithmetic_expression . adding_operator term
    (171) relation -> simple_arithmetic_expression . relational_operator simple_arithmetic_expression
    (127) adding_operator -> . PLUS
    (128) adding_operator -> . MINUS
    (186) relational_operator -> . LESS
    (187) relational_operator -> . NOTGREATER
    (188) relational_operator -> . EQUAL
    (189) relational_operator -> . NOTLESS
    (190) relational_operator -> . GREATER
    (191) relational_operator -> . NOTEQUAL

    ELSE            shift and go to state 246
    PLUS            shift and go to state 102
    MINUS           shift and go to state 94
    LESS            shift and go to state 193
    NOTGREATER      shift and go to state 198
    EQUAL           shift and go to state 194
    NOTLESS         shift and go to state 197
    GREATER         shift and go to state 196
    NOTEQUAL        shift and go to state 191

    relational_operator            shift and go to state 192
    adding_operator                shift and go to state 195

state 186

    (155) boolean_expression -> if_clause simple_boolean . ELSE boolean_expression
    (157) simple_boolean -> simple_boolean . EQUIV implication

    ELSE            shift and go to state 247
    EQUIV           shift and go to state 189


state 187

    (163) boolean_factor -> boolean_factor AND . boolean_secondary
    (164) boolean_secondary -> . boolean_primary
    (165) boolean_secondary -> . NOT boolean_primary
    (166) boolean_primary -> . logical_value
    (167) boolean_primary -> . variable
    (168) boolean_primary -> . function_designator
    (169) boolean_primary -> . relation
    (170) boolean_primary -> . LCBRACKET boolean_expression RCBRACKET
    (184) logical_value -> . TRUE
    (185) logical_value -> . FALSE
    (173) variable -> . simple_variable
    (174) variable -> . subscripted_variable
    (172) function_designator -> . procedure_identifier actual_parameter_part
    (171) relation -> . simple_arithmetic_expression relational_operator simple_arithmetic_expression
    (175) simple_variable -> . variable_identifier
    (177) subscripted_variable -> . array_identifier LBBRACKET subscript_list RBBRACKET
    (44) procedure_identifier -> . IDENTIFIER
    (124) simple_arithmetic_expression -> . term
    (125) simple_arithmetic_expression -> . adding_operator term
    (126) simple_arithmetic_expression -> . simple_arithmetic_expression adding_operator term
    (176) variable_identifier -> . IDENTIFIER
    (31) array_identifier -> . IDENTIFIER
    (129) term -> . factor
    (130) term -> . term multiplying_operator factor
    (127) adding_operator -> . PLUS
    (128) adding_operator -> . MINUS
    (134) factor -> . primary
    (135) factor -> . factor
    (136) factor -> . factor POWER primary
    (137) primary -> . unsigned_number
    (138) primary -> . variable
    (139) primary -> . function_designator
    (140) primary -> . LCBRACKET arithmetic_expression RCBRACKET
    (141) unsigned_number -> . decimal_number
    (142) unsigned_number -> . exponential_part
    (143) unsigned_number -> . decimal_number exponential_part
    (144) decimal_number -> . unsigned_integer
    (145) decimal_number -> . decimal_fraction
    (146) decimal_number -> . unsigned_integer decimal_fraction
    (150) exponential_part -> . EREAL integer
    (147) unsigned_integer -> . DIGIT
    (148) unsigned_integer -> . unsigned_integer DIGIT
    (149) decimal_fraction -> . DOT unsigned_integer

    NOT             shift and go to state 118
    LCBRACKET       shift and go to state 127
    TRUE            shift and go to state 93
    FALSE           shift and go to state 100
    IDENTIFIER      shift and go to state 106
    PLUS            shift and go to state 102
    MINUS           shift and go to state 94
    EREAL           shift and go to state 115
    DIGIT           shift and go to state 6
    DOT             shift and go to state 95

    subscripted_variable           shift and go to state 13
    primary                        shift and go to state 98
    function_designator            shift and go to state 128
    relation                       shift and go to state 91
    boolean_secondary              shift and go to state 248
    unsigned_number                shift and go to state 105
    decimal_fraction               shift and go to state 103
    factor                         shift and go to state 104
    simple_arithmetic_expression   shift and go to state 131
    boolean_primary                shift and go to state 99
    logical_value                  shift and go to state 109
    decimal_number                 shift and go to state 112
    variable_identifier            shift and go to state 41
    array_identifier               shift and go to state 14
    variable                       shift and go to state 129
    exponential_part               shift and go to state 92
    term                           shift and go to state 113
    procedure_identifier           shift and go to state 125
    simple_variable                shift and go to state 49
    adding_operator                shift and go to state 117
    unsigned_integer               shift and go to state 120

state 188

    (149) decimal_fraction -> DOT unsigned_integer .
    (148) unsigned_integer -> unsigned_integer . DIGIT

    EREAL           reduce using rule 149 (decimal_fraction -> DOT unsigned_integer .)
    POWER           reduce using rule 149 (decimal_fraction -> DOT unsigned_integer .)
    TIMES           reduce using rule 149 (decimal_fraction -> DOT unsigned_integer .)
    DIV             reduce using rule 149 (decimal_fraction -> DOT unsigned_integer .)
    MOD             reduce using rule 149 (decimal_fraction -> DOT unsigned_integer .)
    PLUS            reduce using rule 149 (decimal_fraction -> DOT unsigned_integer .)
    MINUS           reduce using rule 149 (decimal_fraction -> DOT unsigned_integer .)
    LESS            reduce using rule 149 (decimal_fraction -> DOT unsigned_integer .)
    NOTGREATER      reduce using rule 149 (decimal_fraction -> DOT unsigned_integer .)
    EQUAL           reduce using rule 149 (decimal_fraction -> DOT unsigned_integer .)
    NOTLESS         reduce using rule 149 (decimal_fraction -> DOT unsigned_integer .)
    GREATER         reduce using rule 149 (decimal_fraction -> DOT unsigned_integer .)
    NOTEQUAL        reduce using rule 149 (decimal_fraction -> DOT unsigned_integer .)
    RCBRACKET       reduce using rule 149 (decimal_fraction -> DOT unsigned_integer .)
    RBBRACKET       reduce using rule 149 (decimal_fraction -> DOT unsigned_integer .)
    END             reduce using rule 149 (decimal_fraction -> DOT unsigned_integer .)
    SEMICOLON       reduce using rule 149 (decimal_fraction -> DOT unsigned_integer .)
    ELSE            reduce using rule 149 (decimal_fraction -> DOT unsigned_integer .)
    COMMA           reduce using rule 149 (decimal_fraction -> DOT unsigned_integer .)
    COLON           reduce using rule 149 (decimal_fraction -> DOT unsigned_integer .)
    STEP            reduce using rule 149 (decimal_fraction -> DOT unsigned_integer .)
    WHILE           reduce using rule 149 (decimal_fraction -> DOT unsigned_integer .)
    DO              reduce using rule 149 (decimal_fraction -> DOT unsigned_integer .)
    AND             reduce using rule 149 (decimal_fraction -> DOT unsigned_integer .)
    OR              reduce using rule 149 (decimal_fraction -> DOT unsigned_integer .)
    IMPL            reduce using rule 149 (decimal_fraction -> DOT unsigned_integer .)
    EQUIV           reduce using rule 149 (decimal_fraction -> DOT unsigned_integer .)
    THEN            reduce using rule 149 (decimal_fraction -> DOT unsigned_integer .)
    UNTIL           reduce using rule 149 (decimal_fraction -> DOT unsigned_integer .)
    DIGIT           shift and go to state 57


state 189

    (157) simple_boolean -> simple_boolean EQUIV . implication
    (158) implication -> . boolean_term
    (159) implication -> . implication IMPL boolean_term
    (160) boolean_term -> . boolean_factor
    (161) boolean_term -> . boolean_term OR boolean_factor
    (162) boolean_factor -> . boolean_secondary
    (163) boolean_factor -> . boolean_factor AND boolean_secondary
    (164) boolean_secondary -> . boolean_primary
    (165) boolean_secondary -> . NOT boolean_primary
    (166) boolean_primary -> . logical_value
    (167) boolean_primary -> . variable
    (168) boolean_primary -> . function_designator
    (169) boolean_primary -> . relation
    (170) boolean_primary -> . LCBRACKET boolean_expression RCBRACKET
    (184) logical_value -> . TRUE
    (185) logical_value -> . FALSE
    (173) variable -> . simple_variable
    (174) variable -> . subscripted_variable
    (172) function_designator -> . procedure_identifier actual_parameter_part
    (171) relation -> . simple_arithmetic_expression relational_operator simple_arithmetic_expression
    (175) simple_variable -> . variable_identifier
    (177) subscripted_variable -> . array_identifier LBBRACKET subscript_list RBBRACKET
    (44) procedure_identifier -> . IDENTIFIER
    (124) simple_arithmetic_expression -> . term
    (125) simple_arithmetic_expression -> . adding_operator term
    (126) simple_arithmetic_expression -> . simple_arithmetic_expression adding_operator term
    (176) variable_identifier -> . IDENTIFIER
    (31) array_identifier -> . IDENTIFIER
    (129) term -> . factor
    (130) term -> . term multiplying_operator factor
    (127) adding_operator -> . PLUS
    (128) adding_operator -> . MINUS
    (134) factor -> . primary
    (135) factor -> . factor
    (136) factor -> . factor POWER primary
    (137) primary -> . unsigned_number
    (138) primary -> . variable
    (139) primary -> . function_designator
    (140) primary -> . LCBRACKET arithmetic_expression RCBRACKET
    (141) unsigned_number -> . decimal_number
    (142) unsigned_number -> . exponential_part
    (143) unsigned_number -> . decimal_number exponential_part
    (144) decimal_number -> . unsigned_integer
    (145) decimal_number -> . decimal_fraction
    (146) decimal_number -> . unsigned_integer decimal_fraction
    (150) exponential_part -> . EREAL integer
    (147) unsigned_integer -> . DIGIT
    (148) unsigned_integer -> . unsigned_integer DIGIT
    (149) decimal_fraction -> . DOT unsigned_integer

    NOT             shift and go to state 118
    LCBRACKET       shift and go to state 127
    TRUE            shift and go to state 93
    FALSE           shift and go to state 100
    IDENTIFIER      shift and go to state 106
    PLUS            shift and go to state 102
    MINUS           shift and go to state 94
    EREAL           shift and go to state 115
    DIGIT           shift and go to state 6
    DOT             shift and go to state 95

    subscripted_variable           shift and go to state 13
    boolean_term                   shift and go to state 88
    function_designator            shift and go to state 128
    boolean_factor                 shift and go to state 90
    relation                       shift and go to state 91
    boolean_secondary              shift and go to state 101
    unsigned_number                shift and go to state 105
    decimal_fraction               shift and go to state 103
    factor                         shift and go to state 104
    simple_arithmetic_expression   shift and go to state 131
    boolean_primary                shift and go to state 99
    logical_value                  shift and go to state 109
    decimal_number                 shift and go to state 112
    primary                        shift and go to state 98
    variable_identifier            shift and go to state 41
    array_identifier               shift and go to state 14
    variable                       shift and go to state 129
    exponential_part               shift and go to state 92
    term                           shift and go to state 113
    procedure_identifier           shift and go to state 125
    simple_variable                shift and go to state 49
    adding_operator                shift and go to state 117
    implication                    shift and go to state 249
    unsigned_integer               shift and go to state 120

state 190

    (136) factor -> factor POWER . primary
    (137) primary -> . unsigned_number
    (138) primary -> . variable
    (139) primary -> . function_designator
    (140) primary -> . LCBRACKET arithmetic_expression RCBRACKET
    (141) unsigned_number -> . decimal_number
    (142) unsigned_number -> . exponential_part
    (143) unsigned_number -> . decimal_number exponential_part
    (173) variable -> . simple_variable
    (174) variable -> . subscripted_variable
    (172) function_designator -> . procedure_identifier actual_parameter_part
    (144) decimal_number -> . unsigned_integer
    (145) decimal_number -> . decimal_fraction
    (146) decimal_number -> . unsigned_integer decimal_fraction
    (150) exponential_part -> . EREAL integer
    (175) simple_variable -> . variable_identifier
    (177) subscripted_variable -> . array_identifier LBBRACKET subscript_list RBBRACKET
    (44) procedure_identifier -> . IDENTIFIER
    (147) unsigned_integer -> . DIGIT
    (148) unsigned_integer -> . unsigned_integer DIGIT
    (149) decimal_fraction -> . DOT unsigned_integer
    (176) variable_identifier -> . IDENTIFIER
    (31) array_identifier -> . IDENTIFIER

    LCBRACKET       shift and go to state 145
    EREAL           shift and go to state 115
    IDENTIFIER      shift and go to state 106
    DIGIT           shift and go to state 6
    DOT             shift and go to state 95

    procedure_identifier           shift and go to state 125
    array_identifier               shift and go to state 14
    subscripted_variable           shift and go to state 13
    primary                        shift and go to state 250
    function_designator            shift and go to state 149
    decimal_number                 shift and go to state 112
    variable_identifier            shift and go to state 41
    unsigned_number                shift and go to state 105
    simple_variable                shift and go to state 49
    decimal_fraction               shift and go to state 103
    variable                       shift and go to state 150
    unsigned_integer               shift and go to state 120
    exponential_part               shift and go to state 92

state 191

    (191) relational_operator -> NOTEQUAL .

    PLUS            reduce using rule 191 (relational_operator -> NOTEQUAL .)
    MINUS           reduce using rule 191 (relational_operator -> NOTEQUAL .)
    LCBRACKET       reduce using rule 191 (relational_operator -> NOTEQUAL .)
    EREAL           reduce using rule 191 (relational_operator -> NOTEQUAL .)
    IDENTIFIER      reduce using rule 191 (relational_operator -> NOTEQUAL .)
    DIGIT           reduce using rule 191 (relational_operator -> NOTEQUAL .)
    DOT             reduce using rule 191 (relational_operator -> NOTEQUAL .)


state 192

    (171) relation -> simple_arithmetic_expression relational_operator . simple_arithmetic_expression
    (124) simple_arithmetic_expression -> . term
    (125) simple_arithmetic_expression -> . adding_operator term
    (126) simple_arithmetic_expression -> . simple_arithmetic_expression adding_operator term
    (129) term -> . factor
    (130) term -> . term multiplying_operator factor
    (127) adding_operator -> . PLUS
    (128) adding_operator -> . MINUS
    (134) factor -> . primary
    (135) factor -> . factor
    (136) factor -> . factor POWER primary
    (137) primary -> . unsigned_number
    (138) primary -> . variable
    (139) primary -> . function_designator
    (140) primary -> . LCBRACKET arithmetic_expression RCBRACKET
    (141) unsigned_number -> . decimal_number
    (142) unsigned_number -> . exponential_part
    (143) unsigned_number -> . decimal_number exponential_part
    (173) variable -> . simple_variable
    (174) variable -> . subscripted_variable
    (172) function_designator -> . procedure_identifier actual_parameter_part
    (144) decimal_number -> . unsigned_integer
    (145) decimal_number -> . decimal_fraction
    (146) decimal_number -> . unsigned_integer decimal_fraction
    (150) exponential_part -> . EREAL integer
    (175) simple_variable -> . variable_identifier
    (177) subscripted_variable -> . array_identifier LBBRACKET subscript_list RBBRACKET
    (44) procedure_identifier -> . IDENTIFIER
    (147) unsigned_integer -> . DIGIT
    (148) unsigned_integer -> . unsigned_integer DIGIT
    (149) decimal_fraction -> . DOT unsigned_integer
    (176) variable_identifier -> . IDENTIFIER
    (31) array_identifier -> . IDENTIFIER

    PLUS            shift and go to state 102
    MINUS           shift and go to state 94
    LCBRACKET       shift and go to state 145
    EREAL           shift and go to state 115
    IDENTIFIER      shift and go to state 106
    DIGIT           shift and go to state 6
    DOT             shift and go to state 95

    subscripted_variable           shift and go to state 13
    primary                        shift and go to state 98
    function_designator            shift and go to state 149
    unsigned_number                shift and go to state 105
    decimal_fraction               shift and go to state 103
    factor                         shift and go to state 104
    simple_arithmetic_expression   shift and go to state 251
    decimal_number                 shift and go to state 112
    variable_identifier            shift and go to state 41
    array_identifier               shift and go to state 14
    variable                       shift and go to state 150
    exponential_part               shift and go to state 92
    term                           shift and go to state 113
    procedure_identifier           shift and go to state 125
    simple_variable                shift and go to state 49
    adding_operator                shift and go to state 117
    unsigned_integer               shift and go to state 120

state 193

    (186) relational_operator -> LESS .

    PLUS            reduce using rule 186 (relational_operator -> LESS .)
    MINUS           reduce using rule 186 (relational_operator -> LESS .)
    LCBRACKET       reduce using rule 186 (relational_operator -> LESS .)
    EREAL           reduce using rule 186 (relational_operator -> LESS .)
    IDENTIFIER      reduce using rule 186 (relational_operator -> LESS .)
    DIGIT           reduce using rule 186 (relational_operator -> LESS .)
    DOT             reduce using rule 186 (relational_operator -> LESS .)


state 194

    (188) relational_operator -> EQUAL .

    PLUS            reduce using rule 188 (relational_operator -> EQUAL .)
    MINUS           reduce using rule 188 (relational_operator -> EQUAL .)
    LCBRACKET       reduce using rule 188 (relational_operator -> EQUAL .)
    EREAL           reduce using rule 188 (relational_operator -> EQUAL .)
    IDENTIFIER      reduce using rule 188 (relational_operator -> EQUAL .)
    DIGIT           reduce using rule 188 (relational_operator -> EQUAL .)
    DOT             reduce using rule 188 (relational_operator -> EQUAL .)


state 195

    (126) simple_arithmetic_expression -> simple_arithmetic_expression adding_operator . term
    (129) term -> . factor
    (130) term -> . term multiplying_operator factor
    (134) factor -> . primary
    (135) factor -> . factor
    (136) factor -> . factor POWER primary
    (137) primary -> . unsigned_number
    (138) primary -> . variable
    (139) primary -> . function_designator
    (140) primary -> . LCBRACKET arithmetic_expression RCBRACKET
    (141) unsigned_number -> . decimal_number
    (142) unsigned_number -> . exponential_part
    (143) unsigned_number -> . decimal_number exponential_part
    (173) variable -> . simple_variable
    (174) variable -> . subscripted_variable
    (172) function_designator -> . procedure_identifier actual_parameter_part
    (144) decimal_number -> . unsigned_integer
    (145) decimal_number -> . decimal_fraction
    (146) decimal_number -> . unsigned_integer decimal_fraction
    (150) exponential_part -> . EREAL integer
    (175) simple_variable -> . variable_identifier
    (177) subscripted_variable -> . array_identifier LBBRACKET subscript_list RBBRACKET
    (44) procedure_identifier -> . IDENTIFIER
    (147) unsigned_integer -> . DIGIT
    (148) unsigned_integer -> . unsigned_integer DIGIT
    (149) decimal_fraction -> . DOT unsigned_integer
    (176) variable_identifier -> . IDENTIFIER
    (31) array_identifier -> . IDENTIFIER

    LCBRACKET       shift and go to state 145
    EREAL           shift and go to state 115
    IDENTIFIER      shift and go to state 106
    DIGIT           shift and go to state 6
    DOT             shift and go to state 95

    subscripted_variable           shift and go to state 13
    primary                        shift and go to state 98
    function_designator            shift and go to state 149
    unsigned_number                shift and go to state 105
    decimal_fraction               shift and go to state 103
    factor                         shift and go to state 104
    decimal_number                 shift and go to state 112
    variable_identifier            shift and go to state 41
    array_identifier               shift and go to state 14
    variable                       shift and go to state 150
    exponential_part               shift and go to state 92
    term                           shift and go to state 252
    procedure_identifier           shift and go to state 125
    simple_variable                shift and go to state 49
    unsigned_integer               shift and go to state 120

state 196

    (190) relational_operator -> GREATER .

    PLUS            reduce using rule 190 (relational_operator -> GREATER .)
    MINUS           reduce using rule 190 (relational_operator -> GREATER .)
    LCBRACKET       reduce using rule 190 (relational_operator -> GREATER .)
    EREAL           reduce using rule 190 (relational_operator -> GREATER .)
    IDENTIFIER      reduce using rule 190 (relational_operator -> GREATER .)
    DIGIT           reduce using rule 190 (relational_operator -> GREATER .)
    DOT             reduce using rule 190 (relational_operator -> GREATER .)


state 197

    (189) relational_operator -> NOTLESS .

    PLUS            reduce using rule 189 (relational_operator -> NOTLESS .)
    MINUS           reduce using rule 189 (relational_operator -> NOTLESS .)
    LCBRACKET       reduce using rule 189 (relational_operator -> NOTLESS .)
    EREAL           reduce using rule 189 (relational_operator -> NOTLESS .)
    IDENTIFIER      reduce using rule 189 (relational_operator -> NOTLESS .)
    DIGIT           reduce using rule 189 (relational_operator -> NOTLESS .)
    DOT             reduce using rule 189 (relational_operator -> NOTLESS .)


state 198

    (187) relational_operator -> NOTGREATER .

    PLUS            reduce using rule 187 (relational_operator -> NOTGREATER .)
    MINUS           reduce using rule 187 (relational_operator -> NOTGREATER .)
    LCBRACKET       reduce using rule 187 (relational_operator -> NOTGREATER .)
    EREAL           reduce using rule 187 (relational_operator -> NOTGREATER .)
    IDENTIFIER      reduce using rule 187 (relational_operator -> NOTGREATER .)
    DIGIT           reduce using rule 187 (relational_operator -> NOTGREATER .)
    DOT             reduce using rule 187 (relational_operator -> NOTGREATER .)


state 199

    (143) unsigned_number -> decimal_number exponential_part .

    POWER           reduce using rule 143 (unsigned_number -> decimal_number exponential_part .)
    TIMES           reduce using rule 143 (unsigned_number -> decimal_number exponential_part .)
    DIV             reduce using rule 143 (unsigned_number -> decimal_number exponential_part .)
    MOD             reduce using rule 143 (unsigned_number -> decimal_number exponential_part .)
    PLUS            reduce using rule 143 (unsigned_number -> decimal_number exponential_part .)
    MINUS           reduce using rule 143 (unsigned_number -> decimal_number exponential_part .)
    LESS            reduce using rule 143 (unsigned_number -> decimal_number exponential_part .)
    NOTGREATER      reduce using rule 143 (unsigned_number -> decimal_number exponential_part .)
    EQUAL           reduce using rule 143 (unsigned_number -> decimal_number exponential_part .)
    NOTLESS         reduce using rule 143 (unsigned_number -> decimal_number exponential_part .)
    GREATER         reduce using rule 143 (unsigned_number -> decimal_number exponential_part .)
    NOTEQUAL        reduce using rule 143 (unsigned_number -> decimal_number exponential_part .)
    RCBRACKET       reduce using rule 143 (unsigned_number -> decimal_number exponential_part .)
    COMMA           reduce using rule 143 (unsigned_number -> decimal_number exponential_part .)
    COLON           reduce using rule 143 (unsigned_number -> decimal_number exponential_part .)
    END             reduce using rule 143 (unsigned_number -> decimal_number exponential_part .)
    SEMICOLON       reduce using rule 143 (unsigned_number -> decimal_number exponential_part .)
    ELSE            reduce using rule 143 (unsigned_number -> decimal_number exponential_part .)
    RBBRACKET       reduce using rule 143 (unsigned_number -> decimal_number exponential_part .)
    STEP            reduce using rule 143 (unsigned_number -> decimal_number exponential_part .)
    WHILE           reduce using rule 143 (unsigned_number -> decimal_number exponential_part .)
    DO              reduce using rule 143 (unsigned_number -> decimal_number exponential_part .)
    AND             reduce using rule 143 (unsigned_number -> decimal_number exponential_part .)
    OR              reduce using rule 143 (unsigned_number -> decimal_number exponential_part .)
    IMPL            reduce using rule 143 (unsigned_number -> decimal_number exponential_part .)
    EQUIV           reduce using rule 143 (unsigned_number -> decimal_number exponential_part .)
    THEN            reduce using rule 143 (unsigned_number -> decimal_number exponential_part .)
    UNTIL           reduce using rule 143 (unsigned_number -> decimal_number exponential_part .)


state 200

    (131) multiplying_operator -> TIMES .

    LCBRACKET       reduce using rule 131 (multiplying_operator -> TIMES .)
    EREAL           reduce using rule 131 (multiplying_operator -> TIMES .)
    IDENTIFIER      reduce using rule 131 (multiplying_operator -> TIMES .)
    DIGIT           reduce using rule 131 (multiplying_operator -> TIMES .)
    DOT             reduce using rule 131 (multiplying_operator -> TIMES .)


state 201

    (132) multiplying_operator -> DIV .

    LCBRACKET       reduce using rule 132 (multiplying_operator -> DIV .)
    EREAL           reduce using rule 132 (multiplying_operator -> DIV .)
    IDENTIFIER      reduce using rule 132 (multiplying_operator -> DIV .)
    DIGIT           reduce using rule 132 (multiplying_operator -> DIV .)
    DOT             reduce using rule 132 (multiplying_operator -> DIV .)


state 202

    (130) term -> term multiplying_operator . factor
    (134) factor -> . primary
    (135) factor -> . factor
    (136) factor -> . factor POWER primary
    (137) primary -> . unsigned_number
    (138) primary -> . variable
    (139) primary -> . function_designator
    (140) primary -> . LCBRACKET arithmetic_expression RCBRACKET
    (141) unsigned_number -> . decimal_number
    (142) unsigned_number -> . exponential_part
    (143) unsigned_number -> . decimal_number exponential_part
    (173) variable -> . simple_variable
    (174) variable -> . subscripted_variable
    (172) function_designator -> . procedure_identifier actual_parameter_part
    (144) decimal_number -> . unsigned_integer
    (145) decimal_number -> . decimal_fraction
    (146) decimal_number -> . unsigned_integer decimal_fraction
    (150) exponential_part -> . EREAL integer
    (175) simple_variable -> . variable_identifier
    (177) subscripted_variable -> . array_identifier LBBRACKET subscript_list RBBRACKET
    (44) procedure_identifier -> . IDENTIFIER
    (147) unsigned_integer -> . DIGIT
    (148) unsigned_integer -> . unsigned_integer DIGIT
    (149) decimal_fraction -> . DOT unsigned_integer
    (176) variable_identifier -> . IDENTIFIER
    (31) array_identifier -> . IDENTIFIER

    LCBRACKET       shift and go to state 145
    EREAL           shift and go to state 115
    IDENTIFIER      shift and go to state 106
    DIGIT           shift and go to state 6
    DOT             shift and go to state 95

    procedure_identifier           shift and go to state 125
    array_identifier               shift and go to state 14
    subscripted_variable           shift and go to state 13
    primary                        shift and go to state 98
    function_designator            shift and go to state 149
    decimal_number                 shift and go to state 112
    variable_identifier            shift and go to state 41
    unsigned_number                shift and go to state 105
    simple_variable                shift and go to state 49
    decimal_fraction               shift and go to state 103
    factor                         shift and go to state 253
    variable                       shift and go to state 150
    unsigned_integer               shift and go to state 120
    exponential_part               shift and go to state 92

state 203

    (133) multiplying_operator -> MOD .

    LCBRACKET       reduce using rule 133 (multiplying_operator -> MOD .)
    EREAL           reduce using rule 133 (multiplying_operator -> MOD .)
    IDENTIFIER      reduce using rule 133 (multiplying_operator -> MOD .)
    DIGIT           reduce using rule 133 (multiplying_operator -> MOD .)
    DOT             reduce using rule 133 (multiplying_operator -> MOD .)


state 204

    (152) integer -> PLUS . unsigned_integer
    (147) unsigned_integer -> . DIGIT
    (148) unsigned_integer -> . unsigned_integer DIGIT

    DIGIT           shift and go to state 6

    unsigned_integer               shift and go to state 254

state 205

    (150) exponential_part -> EREAL integer .

    POWER           reduce using rule 150 (exponential_part -> EREAL integer .)
    TIMES           reduce using rule 150 (exponential_part -> EREAL integer .)
    DIV             reduce using rule 150 (exponential_part -> EREAL integer .)
    MOD             reduce using rule 150 (exponential_part -> EREAL integer .)
    PLUS            reduce using rule 150 (exponential_part -> EREAL integer .)
    MINUS           reduce using rule 150 (exponential_part -> EREAL integer .)
    LESS            reduce using rule 150 (exponential_part -> EREAL integer .)
    NOTGREATER      reduce using rule 150 (exponential_part -> EREAL integer .)
    EQUAL           reduce using rule 150 (exponential_part -> EREAL integer .)
    NOTLESS         reduce using rule 150 (exponential_part -> EREAL integer .)
    GREATER         reduce using rule 150 (exponential_part -> EREAL integer .)
    NOTEQUAL        reduce using rule 150 (exponential_part -> EREAL integer .)
    END             reduce using rule 150 (exponential_part -> EREAL integer .)
    SEMICOLON       reduce using rule 150 (exponential_part -> EREAL integer .)
    ELSE            reduce using rule 150 (exponential_part -> EREAL integer .)
    RBBRACKET       reduce using rule 150 (exponential_part -> EREAL integer .)
    COMMA           reduce using rule 150 (exponential_part -> EREAL integer .)
    RCBRACKET       reduce using rule 150 (exponential_part -> EREAL integer .)
    COLON           reduce using rule 150 (exponential_part -> EREAL integer .)
    STEP            reduce using rule 150 (exponential_part -> EREAL integer .)
    WHILE           reduce using rule 150 (exponential_part -> EREAL integer .)
    DO              reduce using rule 150 (exponential_part -> EREAL integer .)
    AND             reduce using rule 150 (exponential_part -> EREAL integer .)
    OR              reduce using rule 150 (exponential_part -> EREAL integer .)
    IMPL            reduce using rule 150 (exponential_part -> EREAL integer .)
    EQUIV           reduce using rule 150 (exponential_part -> EREAL integer .)
    THEN            reduce using rule 150 (exponential_part -> EREAL integer .)
    UNTIL           reduce using rule 150 (exponential_part -> EREAL integer .)


state 206

    (153) integer -> MINUS . unsigned_integer
    (147) unsigned_integer -> . DIGIT
    (148) unsigned_integer -> . unsigned_integer DIGIT

    DIGIT           shift and go to state 6

    unsigned_integer               shift and go to state 255

state 207

    (151) integer -> unsigned_integer .
    (148) unsigned_integer -> unsigned_integer . DIGIT

    POWER           reduce using rule 151 (integer -> unsigned_integer .)
    TIMES           reduce using rule 151 (integer -> unsigned_integer .)
    DIV             reduce using rule 151 (integer -> unsigned_integer .)
    MOD             reduce using rule 151 (integer -> unsigned_integer .)
    PLUS            reduce using rule 151 (integer -> unsigned_integer .)
    MINUS           reduce using rule 151 (integer -> unsigned_integer .)
    LESS            reduce using rule 151 (integer -> unsigned_integer .)
    NOTGREATER      reduce using rule 151 (integer -> unsigned_integer .)
    EQUAL           reduce using rule 151 (integer -> unsigned_integer .)
    NOTLESS         reduce using rule 151 (integer -> unsigned_integer .)
    GREATER         reduce using rule 151 (integer -> unsigned_integer .)
    NOTEQUAL        reduce using rule 151 (integer -> unsigned_integer .)
    END             reduce using rule 151 (integer -> unsigned_integer .)
    SEMICOLON       reduce using rule 151 (integer -> unsigned_integer .)
    ELSE            reduce using rule 151 (integer -> unsigned_integer .)
    RBBRACKET       reduce using rule 151 (integer -> unsigned_integer .)
    COMMA           reduce using rule 151 (integer -> unsigned_integer .)
    RCBRACKET       reduce using rule 151 (integer -> unsigned_integer .)
    COLON           reduce using rule 151 (integer -> unsigned_integer .)
    STEP            reduce using rule 151 (integer -> unsigned_integer .)
    WHILE           reduce using rule 151 (integer -> unsigned_integer .)
    DO              reduce using rule 151 (integer -> unsigned_integer .)
    AND             reduce using rule 151 (integer -> unsigned_integer .)
    OR              reduce using rule 151 (integer -> unsigned_integer .)
    IMPL            reduce using rule 151 (integer -> unsigned_integer .)
    EQUIV           reduce using rule 151 (integer -> unsigned_integer .)
    THEN            reduce using rule 151 (integer -> unsigned_integer .)
    UNTIL           reduce using rule 151 (integer -> unsigned_integer .)
    DIGIT           shift and go to state 57


state 208

    (140) primary -> LCBRACKET arithmetic_expression . RCBRACKET

    RCBRACKET       shift and go to state 256


state 209

    (170) boolean_primary -> LCBRACKET boolean_expression . RCBRACKET

    RCBRACKET       shift and go to state 257


state 210

    (125) simple_arithmetic_expression -> adding_operator term .
    (130) term -> term . multiplying_operator factor
    (131) multiplying_operator -> . TIMES
    (132) multiplying_operator -> . DIV
    (133) multiplying_operator -> . MOD

    PLUS            reduce using rule 125 (simple_arithmetic_expression -> adding_operator term .)
    MINUS           reduce using rule 125 (simple_arithmetic_expression -> adding_operator term .)
    LESS            reduce using rule 125 (simple_arithmetic_expression -> adding_operator term .)
    NOTGREATER      reduce using rule 125 (simple_arithmetic_expression -> adding_operator term .)
    EQUAL           reduce using rule 125 (simple_arithmetic_expression -> adding_operator term .)
    NOTLESS         reduce using rule 125 (simple_arithmetic_expression -> adding_operator term .)
    GREATER         reduce using rule 125 (simple_arithmetic_expression -> adding_operator term .)
    NOTEQUAL        reduce using rule 125 (simple_arithmetic_expression -> adding_operator term .)
    RCBRACKET       reduce using rule 125 (simple_arithmetic_expression -> adding_operator term .)
    RBBRACKET       reduce using rule 125 (simple_arithmetic_expression -> adding_operator term .)
    COMMA           reduce using rule 125 (simple_arithmetic_expression -> adding_operator term .)
    ELSE            reduce using rule 125 (simple_arithmetic_expression -> adding_operator term .)
    END             reduce using rule 125 (simple_arithmetic_expression -> adding_operator term .)
    SEMICOLON       reduce using rule 125 (simple_arithmetic_expression -> adding_operator term .)
    AND             reduce using rule 125 (simple_arithmetic_expression -> adding_operator term .)
    OR              reduce using rule 125 (simple_arithmetic_expression -> adding_operator term .)
    IMPL            reduce using rule 125 (simple_arithmetic_expression -> adding_operator term .)
    EQUIV           reduce using rule 125 (simple_arithmetic_expression -> adding_operator term .)
    THEN            reduce using rule 125 (simple_arithmetic_expression -> adding_operator term .)
    DO              reduce using rule 125 (simple_arithmetic_expression -> adding_operator term .)
    STEP            reduce using rule 125 (simple_arithmetic_expression -> adding_operator term .)
    WHILE           reduce using rule 125 (simple_arithmetic_expression -> adding_operator term .)
    COLON           reduce using rule 125 (simple_arithmetic_expression -> adding_operator term .)
    UNTIL           reduce using rule 125 (simple_arithmetic_expression -> adding_operator term .)
    TIMES           shift and go to state 200
    DIV             shift and go to state 201
    MOD             shift and go to state 203

    multiplying_operator           shift and go to state 202

state 211

    (165) boolean_secondary -> NOT boolean_primary .

    AND             reduce using rule 165 (boolean_secondary -> NOT boolean_primary .)
    OR              reduce using rule 165 (boolean_secondary -> NOT boolean_primary .)
    IMPL            reduce using rule 165 (boolean_secondary -> NOT boolean_primary .)
    ELSE            reduce using rule 165 (boolean_secondary -> NOT boolean_primary .)
    EQUIV           reduce using rule 165 (boolean_secondary -> NOT boolean_primary .)
    DO              reduce using rule 165 (boolean_secondary -> NOT boolean_primary .)
    COMMA           reduce using rule 165 (boolean_secondary -> NOT boolean_primary .)
    RCBRACKET       reduce using rule 165 (boolean_secondary -> NOT boolean_primary .)
    END             reduce using rule 165 (boolean_secondary -> NOT boolean_primary .)
    SEMICOLON       reduce using rule 165 (boolean_secondary -> NOT boolean_primary .)
    THEN            reduce using rule 165 (boolean_secondary -> NOT boolean_primary .)


state 212

    (159) implication -> implication IMPL . boolean_term
    (160) boolean_term -> . boolean_factor
    (161) boolean_term -> . boolean_term OR boolean_factor
    (162) boolean_factor -> . boolean_secondary
    (163) boolean_factor -> . boolean_factor AND boolean_secondary
    (164) boolean_secondary -> . boolean_primary
    (165) boolean_secondary -> . NOT boolean_primary
    (166) boolean_primary -> . logical_value
    (167) boolean_primary -> . variable
    (168) boolean_primary -> . function_designator
    (169) boolean_primary -> . relation
    (170) boolean_primary -> . LCBRACKET boolean_expression RCBRACKET
    (184) logical_value -> . TRUE
    (185) logical_value -> . FALSE
    (173) variable -> . simple_variable
    (174) variable -> . subscripted_variable
    (172) function_designator -> . procedure_identifier actual_parameter_part
    (171) relation -> . simple_arithmetic_expression relational_operator simple_arithmetic_expression
    (175) simple_variable -> . variable_identifier
    (177) subscripted_variable -> . array_identifier LBBRACKET subscript_list RBBRACKET
    (44) procedure_identifier -> . IDENTIFIER
    (124) simple_arithmetic_expression -> . term
    (125) simple_arithmetic_expression -> . adding_operator term
    (126) simple_arithmetic_expression -> . simple_arithmetic_expression adding_operator term
    (176) variable_identifier -> . IDENTIFIER
    (31) array_identifier -> . IDENTIFIER
    (129) term -> . factor
    (130) term -> . term multiplying_operator factor
    (127) adding_operator -> . PLUS
    (128) adding_operator -> . MINUS
    (134) factor -> . primary
    (135) factor -> . factor
    (136) factor -> . factor POWER primary
    (137) primary -> . unsigned_number
    (138) primary -> . variable
    (139) primary -> . function_designator
    (140) primary -> . LCBRACKET arithmetic_expression RCBRACKET
    (141) unsigned_number -> . decimal_number
    (142) unsigned_number -> . exponential_part
    (143) unsigned_number -> . decimal_number exponential_part
    (144) decimal_number -> . unsigned_integer
    (145) decimal_number -> . decimal_fraction
    (146) decimal_number -> . unsigned_integer decimal_fraction
    (150) exponential_part -> . EREAL integer
    (147) unsigned_integer -> . DIGIT
    (148) unsigned_integer -> . unsigned_integer DIGIT
    (149) decimal_fraction -> . DOT unsigned_integer

    NOT             shift and go to state 118
    LCBRACKET       shift and go to state 127
    TRUE            shift and go to state 93
    FALSE           shift and go to state 100
    IDENTIFIER      shift and go to state 106
    PLUS            shift and go to state 102
    MINUS           shift and go to state 94
    EREAL           shift and go to state 115
    DIGIT           shift and go to state 6
    DOT             shift and go to state 95

    subscripted_variable           shift and go to state 13
    boolean_term                   shift and go to state 258
    function_designator            shift and go to state 128
    boolean_factor                 shift and go to state 90
    relation                       shift and go to state 91
    boolean_secondary              shift and go to state 101
    unsigned_number                shift and go to state 105
    decimal_fraction               shift and go to state 103
    factor                         shift and go to state 104
    simple_arithmetic_expression   shift and go to state 131
    boolean_primary                shift and go to state 99
    logical_value                  shift and go to state 109
    decimal_number                 shift and go to state 112
    primary                        shift and go to state 98
    variable_identifier            shift and go to state 41
    array_identifier               shift and go to state 14
    variable                       shift and go to state 129
    exponential_part               shift and go to state 92
    term                           shift and go to state 113
    procedure_identifier           shift and go to state 125
    simple_variable                shift and go to state 49
    adding_operator                shift and go to state 117
    unsigned_integer               shift and go to state 120

state 213

    (146) decimal_number -> unsigned_integer decimal_fraction .

    EREAL           reduce using rule 146 (decimal_number -> unsigned_integer decimal_fraction .)
    POWER           reduce using rule 146 (decimal_number -> unsigned_integer decimal_fraction .)
    TIMES           reduce using rule 146 (decimal_number -> unsigned_integer decimal_fraction .)
    DIV             reduce using rule 146 (decimal_number -> unsigned_integer decimal_fraction .)
    MOD             reduce using rule 146 (decimal_number -> unsigned_integer decimal_fraction .)
    LESS            reduce using rule 146 (decimal_number -> unsigned_integer decimal_fraction .)
    NOTGREATER      reduce using rule 146 (decimal_number -> unsigned_integer decimal_fraction .)
    EQUAL           reduce using rule 146 (decimal_number -> unsigned_integer decimal_fraction .)
    NOTLESS         reduce using rule 146 (decimal_number -> unsigned_integer decimal_fraction .)
    GREATER         reduce using rule 146 (decimal_number -> unsigned_integer decimal_fraction .)
    NOTEQUAL        reduce using rule 146 (decimal_number -> unsigned_integer decimal_fraction .)
    PLUS            reduce using rule 146 (decimal_number -> unsigned_integer decimal_fraction .)
    MINUS           reduce using rule 146 (decimal_number -> unsigned_integer decimal_fraction .)
    END             reduce using rule 146 (decimal_number -> unsigned_integer decimal_fraction .)
    SEMICOLON       reduce using rule 146 (decimal_number -> unsigned_integer decimal_fraction .)
    ELSE            reduce using rule 146 (decimal_number -> unsigned_integer decimal_fraction .)
    RBBRACKET       reduce using rule 146 (decimal_number -> unsigned_integer decimal_fraction .)
    COMMA           reduce using rule 146 (decimal_number -> unsigned_integer decimal_fraction .)
    RCBRACKET       reduce using rule 146 (decimal_number -> unsigned_integer decimal_fraction .)
    COLON           reduce using rule 146 (decimal_number -> unsigned_integer decimal_fraction .)
    STEP            reduce using rule 146 (decimal_number -> unsigned_integer decimal_fraction .)
    WHILE           reduce using rule 146 (decimal_number -> unsigned_integer decimal_fraction .)
    DO              reduce using rule 146 (decimal_number -> unsigned_integer decimal_fraction .)
    AND             reduce using rule 146 (decimal_number -> unsigned_integer decimal_fraction .)
    OR              reduce using rule 146 (decimal_number -> unsigned_integer decimal_fraction .)
    IMPL            reduce using rule 146 (decimal_number -> unsigned_integer decimal_fraction .)
    EQUIV           reduce using rule 146 (decimal_number -> unsigned_integer decimal_fraction .)
    THEN            reduce using rule 146 (decimal_number -> unsigned_integer decimal_fraction .)
    UNTIL           reduce using rule 146 (decimal_number -> unsigned_integer decimal_fraction .)


state 214

    (65) procedure_body -> statement .

    SEMICOLON       reduce using rule 65 (procedure_body -> statement .)


state 215

    (41) procedure_declaration -> PROCEDURE procedure_heading procedure_body .

    SEMICOLON       reduce using rule 41 (procedure_declaration -> PROCEDURE procedure_heading procedure_body .)


state 216

    (43) procedure_heading -> procedure_identifier formal_parameter_part . SEMICOLON value_part specification_part

    SEMICOLON       shift and go to state 259


state 217

    (46) formal_parameter_part -> LCBRACKET . formal_parameter_list RCBRACKET
    (47) formal_parameter_list -> . formal_parameter
    (48) formal_parameter_list -> . formal_parameter_list parameter_delimiter formal_parameter
    (49) formal_parameter -> . IDENTIFIER

    IDENTIFIER      shift and go to state 262

    formal_parameter_list          shift and go to state 260
    formal_parameter               shift and go to state 261

state 218

    (155) boolean_expression -> if_clause . simple_boolean ELSE boolean_expression
    (123) arithmetic_expression -> if_clause . simple_arithmetic_expression ELSE arithmetic_expression
    (156) simple_boolean -> . implication
    (157) simple_boolean -> . simple_boolean EQUIV implication
    (124) simple_arithmetic_expression -> . term
    (125) simple_arithmetic_expression -> . adding_operator term
    (126) simple_arithmetic_expression -> . simple_arithmetic_expression adding_operator term
    (158) implication -> . boolean_term
    (159) implication -> . implication IMPL boolean_term
    (129) term -> . factor
    (130) term -> . term multiplying_operator factor
    (127) adding_operator -> . PLUS
    (128) adding_operator -> . MINUS
    (160) boolean_term -> . boolean_factor
    (161) boolean_term -> . boolean_term OR boolean_factor
    (134) factor -> . primary
    (135) factor -> . factor
    (136) factor -> . factor POWER primary
    (162) boolean_factor -> . boolean_secondary
    (163) boolean_factor -> . boolean_factor AND boolean_secondary
    (137) primary -> . unsigned_number
    (138) primary -> . variable
    (139) primary -> . function_designator
    (140) primary -> . LCBRACKET arithmetic_expression RCBRACKET
    (164) boolean_secondary -> . boolean_primary
    (165) boolean_secondary -> . NOT boolean_primary
    (141) unsigned_number -> . decimal_number
    (142) unsigned_number -> . exponential_part
    (143) unsigned_number -> . decimal_number exponential_part
    (173) variable -> . simple_variable
    (174) variable -> . subscripted_variable
    (172) function_designator -> . procedure_identifier actual_parameter_part
    (166) boolean_primary -> . logical_value
    (167) boolean_primary -> . variable
    (168) boolean_primary -> . function_designator
    (169) boolean_primary -> . relation
    (170) boolean_primary -> . LCBRACKET boolean_expression RCBRACKET
    (144) decimal_number -> . unsigned_integer
    (145) decimal_number -> . decimal_fraction
    (146) decimal_number -> . unsigned_integer decimal_fraction
    (150) exponential_part -> . EREAL integer
    (175) simple_variable -> . variable_identifier
    (177) subscripted_variable -> . array_identifier LBBRACKET subscript_list RBBRACKET
    (44) procedure_identifier -> . IDENTIFIER
    (184) logical_value -> . TRUE
    (185) logical_value -> . FALSE
    (171) relation -> . simple_arithmetic_expression relational_operator simple_arithmetic_expression
    (147) unsigned_integer -> . DIGIT
    (148) unsigned_integer -> . unsigned_integer DIGIT
    (149) decimal_fraction -> . DOT unsigned_integer
    (176) variable_identifier -> . IDENTIFIER
    (31) array_identifier -> . IDENTIFIER

    PLUS            shift and go to state 102
    MINUS           shift and go to state 94
    LCBRACKET       shift and go to state 116
    NOT             shift and go to state 118
    EREAL           shift and go to state 115
    IDENTIFIER      shift and go to state 106
    TRUE            shift and go to state 93
    FALSE           shift and go to state 100
    DIGIT           shift and go to state 6
    DOT             shift and go to state 95

    boolean_primary                shift and go to state 99
    procedure_identifier           shift and go to state 125
    boolean_term                   shift and go to state 88
    boolean_factor                 shift and go to state 90
    relation                       shift and go to state 91
    simple_boolean                 shift and go to state 186
    boolean_secondary              shift and go to state 101
    unsigned_number                shift and go to state 105
    decimal_fraction               shift and go to state 103
    factor                         shift and go to state 104
    simple_arithmetic_expression   shift and go to state 185
    logical_value                  shift and go to state 109
    decimal_number                 shift and go to state 112
    primary                        shift and go to state 98
    variable_identifier            shift and go to state 41
    function_designator            shift and go to state 110
    array_identifier               shift and go to state 14
    variable                       shift and go to state 161
    exponential_part               shift and go to state 92
    term                           shift and go to state 113
    subscripted_variable           shift and go to state 13
    simple_variable                shift and go to state 49
    adding_operator                shift and go to state 117
    implication                    shift and go to state 119
    unsigned_integer               shift and go to state 120

state 219

    (110) if_clause -> IF boolean_expression THEN .

    NOT             reduce using rule 110 (if_clause -> IF boolean_expression THEN .)
    LCBRACKET       reduce using rule 110 (if_clause -> IF boolean_expression THEN .)
    TRUE            reduce using rule 110 (if_clause -> IF boolean_expression THEN .)
    FALSE           reduce using rule 110 (if_clause -> IF boolean_expression THEN .)
    IDENTIFIER      reduce using rule 110 (if_clause -> IF boolean_expression THEN .)
    PLUS            reduce using rule 110 (if_clause -> IF boolean_expression THEN .)
    MINUS           reduce using rule 110 (if_clause -> IF boolean_expression THEN .)
    EREAL           reduce using rule 110 (if_clause -> IF boolean_expression THEN .)
    DIGIT           reduce using rule 110 (if_clause -> IF boolean_expression THEN .)
    DOT             reduce using rule 110 (if_clause -> IF boolean_expression THEN .)
    FOR             reduce using rule 110 (if_clause -> IF boolean_expression THEN .)
    TLABEL          reduce using rule 110 (if_clause -> IF boolean_expression THEN .)
    BEGIN           reduce using rule 110 (if_clause -> IF boolean_expression THEN .)
    GOTO            reduce using rule 110 (if_clause -> IF boolean_expression THEN .)
    ELSE            reduce using rule 110 (if_clause -> IF boolean_expression THEN .)
    END             reduce using rule 110 (if_clause -> IF boolean_expression THEN .)
    SEMICOLON       reduce using rule 110 (if_clause -> IF boolean_expression THEN .)


state 220

    (24) type_list -> simple_variable COMMA . type_list
    (23) type_list -> . simple_variable
    (24) type_list -> . simple_variable COMMA type_list
    (175) simple_variable -> . variable_identifier
    (176) variable_identifier -> . IDENTIFIER

    IDENTIFIER      shift and go to state 135

    variable_identifier            shift and go to state 41
    type_list                      shift and go to state 263
    simple_variable                shift and go to state 133

state 221

    (26) array_declaration -> local_or_own_type TARRAY array_list .
    (28) array_list -> array_list . COMMA array_segment

    SEMICOLON       reduce using rule 26 (array_declaration -> local_or_own_type TARRAY array_list .)
    COMMA           shift and go to state 181


state 222

    (123) arithmetic_expression -> if_clause simple_arithmetic_expression . ELSE arithmetic_expression
    (126) simple_arithmetic_expression -> simple_arithmetic_expression . adding_operator term
    (127) adding_operator -> . PLUS
    (128) adding_operator -> . MINUS

    ELSE            shift and go to state 246
    PLUS            shift and go to state 102
    MINUS           shift and go to state 94

    adding_operator                shift and go to state 195

state 223

    (177) subscripted_variable -> array_identifier LBBRACKET subscript_list RBBRACKET .

    POWER           reduce using rule 177 (subscripted_variable -> array_identifier LBBRACKET subscript_list RBBRACKET .)
    TIMES           reduce using rule 177 (subscripted_variable -> array_identifier LBBRACKET subscript_list RBBRACKET .)
    DIV             reduce using rule 177 (subscripted_variable -> array_identifier LBBRACKET subscript_list RBBRACKET .)
    MOD             reduce using rule 177 (subscripted_variable -> array_identifier LBBRACKET subscript_list RBBRACKET .)
    ELSE            reduce using rule 177 (subscripted_variable -> array_identifier LBBRACKET subscript_list RBBRACKET .)
    PLUS            reduce using rule 177 (subscripted_variable -> array_identifier LBBRACKET subscript_list RBBRACKET .)
    MINUS           reduce using rule 177 (subscripted_variable -> array_identifier LBBRACKET subscript_list RBBRACKET .)
    ASSIGNMENT      reduce using rule 177 (subscripted_variable -> array_identifier LBBRACKET subscript_list RBBRACKET .)
    LESS            reduce using rule 177 (subscripted_variable -> array_identifier LBBRACKET subscript_list RBBRACKET .)
    NOTGREATER      reduce using rule 177 (subscripted_variable -> array_identifier LBBRACKET subscript_list RBBRACKET .)
    EQUAL           reduce using rule 177 (subscripted_variable -> array_identifier LBBRACKET subscript_list RBBRACKET .)
    NOTLESS         reduce using rule 177 (subscripted_variable -> array_identifier LBBRACKET subscript_list RBBRACKET .)
    GREATER         reduce using rule 177 (subscripted_variable -> array_identifier LBBRACKET subscript_list RBBRACKET .)
    NOTEQUAL        reduce using rule 177 (subscripted_variable -> array_identifier LBBRACKET subscript_list RBBRACKET .)
    AND             reduce using rule 177 (subscripted_variable -> array_identifier LBBRACKET subscript_list RBBRACKET .)
    OR              reduce using rule 177 (subscripted_variable -> array_identifier LBBRACKET subscript_list RBBRACKET .)
    IMPL            reduce using rule 177 (subscripted_variable -> array_identifier LBBRACKET subscript_list RBBRACKET .)
    EQUIV           reduce using rule 177 (subscripted_variable -> array_identifier LBBRACKET subscript_list RBBRACKET .)
    DO              reduce using rule 177 (subscripted_variable -> array_identifier LBBRACKET subscript_list RBBRACKET .)
    COMMA           reduce using rule 177 (subscripted_variable -> array_identifier LBBRACKET subscript_list RBBRACKET .)
    RCBRACKET       reduce using rule 177 (subscripted_variable -> array_identifier LBBRACKET subscript_list RBBRACKET .)
    END             reduce using rule 177 (subscripted_variable -> array_identifier LBBRACKET subscript_list RBBRACKET .)
    SEMICOLON       reduce using rule 177 (subscripted_variable -> array_identifier LBBRACKET subscript_list RBBRACKET .)
    THEN            reduce using rule 177 (subscripted_variable -> array_identifier LBBRACKET subscript_list RBBRACKET .)
    COLON           reduce using rule 177 (subscripted_variable -> array_identifier LBBRACKET subscript_list RBBRACKET .)
    RBBRACKET       reduce using rule 177 (subscripted_variable -> array_identifier LBBRACKET subscript_list RBBRACKET .)
    STEP            reduce using rule 177 (subscripted_variable -> array_identifier LBBRACKET subscript_list RBBRACKET .)
    WHILE           reduce using rule 177 (subscripted_variable -> array_identifier LBBRACKET subscript_list RBBRACKET .)
    UNTIL           reduce using rule 177 (subscripted_variable -> array_identifier LBBRACKET subscript_list RBBRACKET .)


state 224

    (179) subscript_list -> subscript_list COMMA . subscript_expression
    (180) subscript_expression -> . arithmetic_expression
    (122) arithmetic_expression -> . simple_arithmetic_expression
    (123) arithmetic_expression -> . if_clause simple_arithmetic_expression ELSE arithmetic_expression
    (124) simple_arithmetic_expression -> . term
    (125) simple_arithmetic_expression -> . adding_operator term
    (126) simple_arithmetic_expression -> . simple_arithmetic_expression adding_operator term
    (110) if_clause -> . IF boolean_expression THEN
    (129) term -> . factor
    (130) term -> . term multiplying_operator factor
    (127) adding_operator -> . PLUS
    (128) adding_operator -> . MINUS
    (134) factor -> . primary
    (135) factor -> . factor
    (136) factor -> . factor POWER primary
    (137) primary -> . unsigned_number
    (138) primary -> . variable
    (139) primary -> . function_designator
    (140) primary -> . LCBRACKET arithmetic_expression RCBRACKET
    (141) unsigned_number -> . decimal_number
    (142) unsigned_number -> . exponential_part
    (143) unsigned_number -> . decimal_number exponential_part
    (173) variable -> . simple_variable
    (174) variable -> . subscripted_variable
    (172) function_designator -> . procedure_identifier actual_parameter_part
    (144) decimal_number -> . unsigned_integer
    (145) decimal_number -> . decimal_fraction
    (146) decimal_number -> . unsigned_integer decimal_fraction
    (150) exponential_part -> . EREAL integer
    (175) simple_variable -> . variable_identifier
    (177) subscripted_variable -> . array_identifier LBBRACKET subscript_list RBBRACKET
    (44) procedure_identifier -> . IDENTIFIER
    (147) unsigned_integer -> . DIGIT
    (148) unsigned_integer -> . unsigned_integer DIGIT
    (149) decimal_fraction -> . DOT unsigned_integer
    (176) variable_identifier -> . IDENTIFIER
    (31) array_identifier -> . IDENTIFIER

    IF              shift and go to state 45
    PLUS            shift and go to state 102
    MINUS           shift and go to state 94
    LCBRACKET       shift and go to state 145
    EREAL           shift and go to state 115
    IDENTIFIER      shift and go to state 106
    DIGIT           shift and go to state 6
    DOT             shift and go to state 95

    subscripted_variable           shift and go to state 13
    primary                        shift and go to state 98
    if_clause                      shift and go to state 144
    subscript_expression           shift and go to state 264
    decimal_fraction               shift and go to state 103
    factor                         shift and go to state 104
    unsigned_number                shift and go to state 105
    simple_arithmetic_expression   shift and go to state 147
    arithmetic_expression          shift and go to state 148
    decimal_number                 shift and go to state 112
    variable_identifier            shift and go to state 41
    function_designator            shift and go to state 149
    array_identifier               shift and go to state 14
    variable                       shift and go to state 150
    exponential_part               shift and go to state 92
    term                           shift and go to state 113
    procedure_identifier           shift and go to state 125
    simple_variable                shift and go to state 49
    adding_operator                shift and go to state 117
    unsigned_integer               shift and go to state 120

state 225

    (88) designational_expression -> if_clause simple_designational_expression ELSE . designational_expression
    (87) designational_expression -> . simple_designational_expression
    (88) designational_expression -> . if_clause simple_designational_expression ELSE designational_expression
    (89) simple_designational_expression -> . label
    (90) simple_designational_expression -> . switch_designator
    (91) simple_designational_expression -> . LCBRACKET designational_expression RCBRACKET
    (110) if_clause -> . IF boolean_expression THEN
    (74) label -> . IDENTIFIER
    (75) label -> . unsigned_integer
    (92) switch_designator -> . switch_identifier LBBRACKET subscript_expression RBBRACKET
    (147) unsigned_integer -> . DIGIT
    (148) unsigned_integer -> . unsigned_integer DIGIT
    (38) switch_identifier -> . IDENTIFIER

    LCBRACKET       shift and go to state 69
    IF              shift and go to state 45
    IDENTIFIER      shift and go to state 70
    DIGIT           shift and go to state 6

    designational_expression       shift and go to state 265
    simple_designational_expression shift and go to state 71
    switch_designator              shift and go to state 65
    if_clause                      shift and go to state 66
    label                          shift and go to state 67
    switch_identifier              shift and go to state 68
    unsigned_integer               shift and go to state 9

state 226

    (92) switch_designator -> switch_identifier LBBRACKET subscript_expression . RBBRACKET

    RBBRACKET       shift and go to state 266


state 227

    (91) simple_designational_expression -> LCBRACKET designational_expression RCBRACKET .

    ELSE            reduce using rule 91 (simple_designational_expression -> LCBRACKET designational_expression RCBRACKET .)
    END             reduce using rule 91 (simple_designational_expression -> LCBRACKET designational_expression RCBRACKET .)
    SEMICOLON       reduce using rule 91 (simple_designational_expression -> LCBRACKET designational_expression RCBRACKET .)
    RCBRACKET       reduce using rule 91 (simple_designational_expression -> LCBRACKET designational_expression RCBRACKET .)
    COMMA           reduce using rule 91 (simple_designational_expression -> LCBRACKET designational_expression RCBRACKET .)


state 228

    (95) actual_parameter_part -> LCBRACKET actual_parameter_list RCBRACKET .
    (99) parameter_delimiter -> RCBRACKET . letter_string COLON LCBRACKET
    (182) letter_string -> . LETTER
    (183) letter_string -> . letter_string LETTER

    POWER           reduce using rule 95 (actual_parameter_part -> LCBRACKET actual_parameter_list RCBRACKET .)
    TIMES           reduce using rule 95 (actual_parameter_part -> LCBRACKET actual_parameter_list RCBRACKET .)
    DIV             reduce using rule 95 (actual_parameter_part -> LCBRACKET actual_parameter_list RCBRACKET .)
    MOD             reduce using rule 95 (actual_parameter_part -> LCBRACKET actual_parameter_list RCBRACKET .)
    PLUS            reduce using rule 95 (actual_parameter_part -> LCBRACKET actual_parameter_list RCBRACKET .)
    MINUS           reduce using rule 95 (actual_parameter_part -> LCBRACKET actual_parameter_list RCBRACKET .)
    LESS            reduce using rule 95 (actual_parameter_part -> LCBRACKET actual_parameter_list RCBRACKET .)
    NOTGREATER      reduce using rule 95 (actual_parameter_part -> LCBRACKET actual_parameter_list RCBRACKET .)
    EQUAL           reduce using rule 95 (actual_parameter_part -> LCBRACKET actual_parameter_list RCBRACKET .)
    NOTLESS         reduce using rule 95 (actual_parameter_part -> LCBRACKET actual_parameter_list RCBRACKET .)
    GREATER         reduce using rule 95 (actual_parameter_part -> LCBRACKET actual_parameter_list RCBRACKET .)
    NOTEQUAL        reduce using rule 95 (actual_parameter_part -> LCBRACKET actual_parameter_list RCBRACKET .)
    RCBRACKET       reduce using rule 95 (actual_parameter_part -> LCBRACKET actual_parameter_list RCBRACKET .)
    COMMA           reduce using rule 95 (actual_parameter_part -> LCBRACKET actual_parameter_list RCBRACKET .)
    AND             reduce using rule 95 (actual_parameter_part -> LCBRACKET actual_parameter_list RCBRACKET .)
    OR              reduce using rule 95 (actual_parameter_part -> LCBRACKET actual_parameter_list RCBRACKET .)
    IMPL            reduce using rule 95 (actual_parameter_part -> LCBRACKET actual_parameter_list RCBRACKET .)
    EQUIV           reduce using rule 95 (actual_parameter_part -> LCBRACKET actual_parameter_list RCBRACKET .)
    END             reduce using rule 95 (actual_parameter_part -> LCBRACKET actual_parameter_list RCBRACKET .)
    SEMICOLON       reduce using rule 95 (actual_parameter_part -> LCBRACKET actual_parameter_list RCBRACKET .)
    ELSE            reduce using rule 95 (actual_parameter_part -> LCBRACKET actual_parameter_list RCBRACKET .)
    THEN            reduce using rule 95 (actual_parameter_part -> LCBRACKET actual_parameter_list RCBRACKET .)
    RBBRACKET       reduce using rule 95 (actual_parameter_part -> LCBRACKET actual_parameter_list RCBRACKET .)
    COLON           reduce using rule 95 (actual_parameter_part -> LCBRACKET actual_parameter_list RCBRACKET .)
    STEP            reduce using rule 95 (actual_parameter_part -> LCBRACKET actual_parameter_list RCBRACKET .)
    WHILE           reduce using rule 95 (actual_parameter_part -> LCBRACKET actual_parameter_list RCBRACKET .)
    DO              reduce using rule 95 (actual_parameter_part -> LCBRACKET actual_parameter_list RCBRACKET .)
    UNTIL           reduce using rule 95 (actual_parameter_part -> LCBRACKET actual_parameter_list RCBRACKET .)
    LETTER          shift and go to state 268

    letter_string                  shift and go to state 267

state 229

    (97) actual_parameter_list -> actual_parameter_list parameter_delimiter . actual_parameter
    (100) actual_parameter -> . string
    (101) actual_parameter -> . expression
    (102) actual_parameter -> . array_identifier
    (103) actual_parameter -> . switch_identifier
    (104) actual_parameter -> . procedure_identifier
    (181) string -> . STRING
    (119) expression -> . arithmetic_expression
    (120) expression -> . boolean_expression
    (121) expression -> . designational_expression
    (31) array_identifier -> . IDENTIFIER
    (38) switch_identifier -> . IDENTIFIER
    (44) procedure_identifier -> . IDENTIFIER
    (122) arithmetic_expression -> . simple_arithmetic_expression
    (123) arithmetic_expression -> . if_clause simple_arithmetic_expression ELSE arithmetic_expression
    (154) boolean_expression -> . simple_boolean
    (155) boolean_expression -> . if_clause simple_boolean ELSE boolean_expression
    (87) designational_expression -> . simple_designational_expression
    (88) designational_expression -> . if_clause simple_designational_expression ELSE designational_expression
    (124) simple_arithmetic_expression -> . term
    (125) simple_arithmetic_expression -> . adding_operator term
    (126) simple_arithmetic_expression -> . simple_arithmetic_expression adding_operator term
    (110) if_clause -> . IF boolean_expression THEN
    (156) simple_boolean -> . implication
    (157) simple_boolean -> . simple_boolean EQUIV implication
    (89) simple_designational_expression -> . label
    (90) simple_designational_expression -> . switch_designator
    (91) simple_designational_expression -> . LCBRACKET designational_expression RCBRACKET
    (129) term -> . factor
    (130) term -> . term multiplying_operator factor
    (127) adding_operator -> . PLUS
    (128) adding_operator -> . MINUS
    (158) implication -> . boolean_term
    (159) implication -> . implication IMPL boolean_term
    (74) label -> . IDENTIFIER
    (75) label -> . unsigned_integer
    (92) switch_designator -> . switch_identifier LBBRACKET subscript_expression RBBRACKET
    (134) factor -> . primary
    (135) factor -> . factor
    (136) factor -> . factor POWER primary
    (160) boolean_term -> . boolean_factor
    (161) boolean_term -> . boolean_term OR boolean_factor
    (147) unsigned_integer -> . DIGIT
    (148) unsigned_integer -> . unsigned_integer DIGIT
    (137) primary -> . unsigned_number
    (138) primary -> . variable
    (139) primary -> . function_designator
    (140) primary -> . LCBRACKET arithmetic_expression RCBRACKET
    (162) boolean_factor -> . boolean_secondary
    (163) boolean_factor -> . boolean_factor AND boolean_secondary
    (141) unsigned_number -> . decimal_number
    (142) unsigned_number -> . exponential_part
    (143) unsigned_number -> . decimal_number exponential_part
    (173) variable -> . simple_variable
    (174) variable -> . subscripted_variable
    (172) function_designator -> . procedure_identifier actual_parameter_part
    (164) boolean_secondary -> . boolean_primary
    (165) boolean_secondary -> . NOT boolean_primary
    (144) decimal_number -> . unsigned_integer
    (145) decimal_number -> . decimal_fraction
    (146) decimal_number -> . unsigned_integer decimal_fraction
    (150) exponential_part -> . EREAL integer
    (175) simple_variable -> . variable_identifier
    (177) subscripted_variable -> . array_identifier LBBRACKET subscript_list RBBRACKET
    (166) boolean_primary -> . logical_value
    (167) boolean_primary -> . variable
    (168) boolean_primary -> . function_designator
    (169) boolean_primary -> . relation
    (170) boolean_primary -> . LCBRACKET boolean_expression RCBRACKET
    (149) decimal_fraction -> . DOT unsigned_integer
    (176) variable_identifier -> . IDENTIFIER
    (184) logical_value -> . TRUE
    (185) logical_value -> . FALSE
    (171) relation -> . simple_arithmetic_expression relational_operator simple_arithmetic_expression

    STRING          shift and go to state 164
    IDENTIFIER      shift and go to state 165
    IF              shift and go to state 45
    LCBRACKET       shift and go to state 169
    PLUS            shift and go to state 102
    MINUS           shift and go to state 94
    DIGIT           shift and go to state 6
    NOT             shift and go to state 118
    EREAL           shift and go to state 115
    DOT             shift and go to state 95
    TRUE            shift and go to state 93
    FALSE           shift and go to state 100

    boolean_primary                shift and go to state 99
    subscripted_variable           shift and go to state 13
    boolean_term                   shift and go to state 88
    if_clause                      shift and go to state 160
    variable                       shift and go to state 161
    relation                       shift and go to state 91
    simple_designational_expression shift and go to state 71
    simple_boolean                 shift and go to state 97
    boolean_secondary              shift and go to state 101
    label                          shift and go to state 67
    actual_parameter               shift and go to state 269
    switch_identifier              shift and go to state 163
    unsigned_number                shift and go to state 105
    decimal_fraction               shift and go to state 103
    simple_arithmetic_expression   shift and go to state 107
    arithmetic_expression          shift and go to state 166
    string                         shift and go to state 167
    logical_value                  shift and go to state 109
    factor                         shift and go to state 104
    decimal_number                 shift and go to state 112
    primary                        shift and go to state 98
    variable_identifier            shift and go to state 41
    function_designator            shift and go to state 110
    array_identifier               shift and go to state 168
    boolean_factor                 shift and go to state 90
    exponential_part               shift and go to state 92
    term                           shift and go to state 113
    designational_expression       shift and go to state 170
    boolean_expression             shift and go to state 171
    procedure_identifier           shift and go to state 172
    simple_variable                shift and go to state 49
    switch_designator              shift and go to state 65
    adding_operator                shift and go to state 117
    implication                    shift and go to state 119
    expression                     shift and go to state 173
    unsigned_integer               shift and go to state 174

state 230

    (98) parameter_delimiter -> COMMA .

    STRING          reduce using rule 98 (parameter_delimiter -> COMMA .)
    IDENTIFIER      reduce using rule 98 (parameter_delimiter -> COMMA .)
    IF              reduce using rule 98 (parameter_delimiter -> COMMA .)
    LCBRACKET       reduce using rule 98 (parameter_delimiter -> COMMA .)
    PLUS            reduce using rule 98 (parameter_delimiter -> COMMA .)
    MINUS           reduce using rule 98 (parameter_delimiter -> COMMA .)
    DIGIT           reduce using rule 98 (parameter_delimiter -> COMMA .)
    NOT             reduce using rule 98 (parameter_delimiter -> COMMA .)
    EREAL           reduce using rule 98 (parameter_delimiter -> COMMA .)
    DOT             reduce using rule 98 (parameter_delimiter -> COMMA .)
    TRUE            reduce using rule 98 (parameter_delimiter -> COMMA .)
    FALSE           reduce using rule 98 (parameter_delimiter -> COMMA .)


state 231

    (74) label -> IDENTIFIER .
    (38) switch_identifier -> IDENTIFIER .
    (44) procedure_identifier -> IDENTIFIER .
    (176) variable_identifier -> IDENTIFIER .
    (31) array_identifier -> IDENTIFIER .

  ! reduce/reduce conflict for RCBRACKET resolved using rule 44 (procedure_identifier -> IDENTIFIER .)
  ! reduce/reduce conflict for ELSE resolved using rule 44 (procedure_identifier -> IDENTIFIER .)
  ! reduce/reduce conflict for POWER resolved using rule 44 (procedure_identifier -> IDENTIFIER .)
  ! reduce/reduce conflict for TIMES resolved using rule 44 (procedure_identifier -> IDENTIFIER .)
  ! reduce/reduce conflict for DIV resolved using rule 44 (procedure_identifier -> IDENTIFIER .)
  ! reduce/reduce conflict for MOD resolved using rule 44 (procedure_identifier -> IDENTIFIER .)
  ! reduce/reduce conflict for ELSE resolved using rule 44 (procedure_identifier -> IDENTIFIER .)
  ! reduce/reduce conflict for PLUS resolved using rule 44 (procedure_identifier -> IDENTIFIER .)
  ! reduce/reduce conflict for MINUS resolved using rule 44 (procedure_identifier -> IDENTIFIER .)
  ! reduce/reduce conflict for LESS resolved using rule 44 (procedure_identifier -> IDENTIFIER .)
  ! reduce/reduce conflict for NOTGREATER resolved using rule 44 (procedure_identifier -> IDENTIFIER .)
  ! reduce/reduce conflict for EQUAL resolved using rule 44 (procedure_identifier -> IDENTIFIER .)
  ! reduce/reduce conflict for NOTLESS resolved using rule 44 (procedure_identifier -> IDENTIFIER .)
  ! reduce/reduce conflict for GREATER resolved using rule 44 (procedure_identifier -> IDENTIFIER .)
  ! reduce/reduce conflict for NOTEQUAL resolved using rule 44 (procedure_identifier -> IDENTIFIER .)
  ! reduce/reduce conflict for AND resolved using rule 44 (procedure_identifier -> IDENTIFIER .)
  ! reduce/reduce conflict for OR resolved using rule 44 (procedure_identifier -> IDENTIFIER .)
  ! reduce/reduce conflict for IMPL resolved using rule 44 (procedure_identifier -> IDENTIFIER .)
  ! reduce/reduce conflict for EQUIV resolved using rule 44 (procedure_identifier -> IDENTIFIER .)
  ! reduce/reduce conflict for RCBRACKET resolved using rule 44 (procedure_identifier -> IDENTIFIER .)
  ! reduce/reduce conflict for LBBRACKET resolved using rule 31 (array_identifier -> IDENTIFIER .)
    LCBRACKET       reduce using rule 44 (procedure_identifier -> IDENTIFIER .)
    POWER           reduce using rule 44 (procedure_identifier -> IDENTIFIER .)
    TIMES           reduce using rule 44 (procedure_identifier -> IDENTIFIER .)
    DIV             reduce using rule 44 (procedure_identifier -> IDENTIFIER .)
    MOD             reduce using rule 44 (procedure_identifier -> IDENTIFIER .)
    PLUS            reduce using rule 44 (procedure_identifier -> IDENTIFIER .)
    MINUS           reduce using rule 44 (procedure_identifier -> IDENTIFIER .)
    LESS            reduce using rule 44 (procedure_identifier -> IDENTIFIER .)
    NOTGREATER      reduce using rule 44 (procedure_identifier -> IDENTIFIER .)
    EQUAL           reduce using rule 44 (procedure_identifier -> IDENTIFIER .)
    NOTLESS         reduce using rule 44 (procedure_identifier -> IDENTIFIER .)
    GREATER         reduce using rule 44 (procedure_identifier -> IDENTIFIER .)
    NOTEQUAL        reduce using rule 44 (procedure_identifier -> IDENTIFIER .)
    RCBRACKET       reduce using rule 44 (procedure_identifier -> IDENTIFIER .)
    AND             reduce using rule 44 (procedure_identifier -> IDENTIFIER .)
    OR              reduce using rule 44 (procedure_identifier -> IDENTIFIER .)
    IMPL            reduce using rule 44 (procedure_identifier -> IDENTIFIER .)
    EQUIV           reduce using rule 44 (procedure_identifier -> IDENTIFIER .)
    ELSE            reduce using rule 44 (procedure_identifier -> IDENTIFIER .)
    LBBRACKET       reduce using rule 31 (array_identifier -> IDENTIFIER .)

  ! ELSE            [ reduce using rule 74 (label -> IDENTIFIER .) ]
  ! RCBRACKET       [ reduce using rule 74 (label -> IDENTIFIER .) ]
  ! LBBRACKET       [ reduce using rule 38 (switch_identifier -> IDENTIFIER .) ]
  ! POWER           [ reduce using rule 176 (variable_identifier -> IDENTIFIER .) ]
  ! TIMES           [ reduce using rule 176 (variable_identifier -> IDENTIFIER .) ]
  ! DIV             [ reduce using rule 176 (variable_identifier -> IDENTIFIER .) ]
  ! MOD             [ reduce using rule 176 (variable_identifier -> IDENTIFIER .) ]
  ! ELSE            [ reduce using rule 176 (variable_identifier -> IDENTIFIER .) ]
  ! PLUS            [ reduce using rule 176 (variable_identifier -> IDENTIFIER .) ]
  ! MINUS           [ reduce using rule 176 (variable_identifier -> IDENTIFIER .) ]
  ! LESS            [ reduce using rule 176 (variable_identifier -> IDENTIFIER .) ]
  ! NOTGREATER      [ reduce using rule 176 (variable_identifier -> IDENTIFIER .) ]
  ! EQUAL           [ reduce using rule 176 (variable_identifier -> IDENTIFIER .) ]
  ! NOTLESS         [ reduce using rule 176 (variable_identifier -> IDENTIFIER .) ]
  ! GREATER         [ reduce using rule 176 (variable_identifier -> IDENTIFIER .) ]
  ! NOTEQUAL        [ reduce using rule 176 (variable_identifier -> IDENTIFIER .) ]
  ! AND             [ reduce using rule 176 (variable_identifier -> IDENTIFIER .) ]
  ! OR              [ reduce using rule 176 (variable_identifier -> IDENTIFIER .) ]
  ! IMPL            [ reduce using rule 176 (variable_identifier -> IDENTIFIER .) ]
  ! EQUIV           [ reduce using rule 176 (variable_identifier -> IDENTIFIER .) ]
  ! RCBRACKET       [ reduce using rule 176 (variable_identifier -> IDENTIFIER .) ]


state 232

    (88) designational_expression -> if_clause . simple_designational_expression ELSE designational_expression
    (123) arithmetic_expression -> if_clause . simple_arithmetic_expression ELSE arithmetic_expression
    (155) boolean_expression -> if_clause . simple_boolean ELSE boolean_expression
    (89) simple_designational_expression -> . label
    (90) simple_designational_expression -> . switch_designator
    (91) simple_designational_expression -> . LCBRACKET designational_expression RCBRACKET
    (124) simple_arithmetic_expression -> . term
    (125) simple_arithmetic_expression -> . adding_operator term
    (126) simple_arithmetic_expression -> . simple_arithmetic_expression adding_operator term
    (156) simple_boolean -> . implication
    (157) simple_boolean -> . simple_boolean EQUIV implication
    (74) label -> . IDENTIFIER
    (75) label -> . unsigned_integer
    (92) switch_designator -> . switch_identifier LBBRACKET subscript_expression RBBRACKET
    (129) term -> . factor
    (130) term -> . term multiplying_operator factor
    (127) adding_operator -> . PLUS
    (128) adding_operator -> . MINUS
    (158) implication -> . boolean_term
    (159) implication -> . implication IMPL boolean_term
    (147) unsigned_integer -> . DIGIT
    (148) unsigned_integer -> . unsigned_integer DIGIT
    (38) switch_identifier -> . IDENTIFIER
    (134) factor -> . primary
    (135) factor -> . factor
    (136) factor -> . factor POWER primary
    (160) boolean_term -> . boolean_factor
    (161) boolean_term -> . boolean_term OR boolean_factor
    (137) primary -> . unsigned_number
    (138) primary -> . variable
    (139) primary -> . function_designator
    (140) primary -> . LCBRACKET arithmetic_expression RCBRACKET
    (162) boolean_factor -> . boolean_secondary
    (163) boolean_factor -> . boolean_factor AND boolean_secondary
    (141) unsigned_number -> . decimal_number
    (142) unsigned_number -> . exponential_part
    (143) unsigned_number -> . decimal_number exponential_part
    (173) variable -> . simple_variable
    (174) variable -> . subscripted_variable
    (172) function_designator -> . procedure_identifier actual_parameter_part
    (164) boolean_secondary -> . boolean_primary
    (165) boolean_secondary -> . NOT boolean_primary
    (144) decimal_number -> . unsigned_integer
    (145) decimal_number -> . decimal_fraction
    (146) decimal_number -> . unsigned_integer decimal_fraction
    (150) exponential_part -> . EREAL integer
    (175) simple_variable -> . variable_identifier
    (177) subscripted_variable -> . array_identifier LBBRACKET subscript_list RBBRACKET
    (44) procedure_identifier -> . IDENTIFIER
    (166) boolean_primary -> . logical_value
    (167) boolean_primary -> . variable
    (168) boolean_primary -> . function_designator
    (169) boolean_primary -> . relation
    (170) boolean_primary -> . LCBRACKET boolean_expression RCBRACKET
    (149) decimal_fraction -> . DOT unsigned_integer
    (176) variable_identifier -> . IDENTIFIER
    (31) array_identifier -> . IDENTIFIER
    (184) logical_value -> . TRUE
    (185) logical_value -> . FALSE
    (171) relation -> . simple_arithmetic_expression relational_operator simple_arithmetic_expression

    LCBRACKET       shift and go to state 169
    IDENTIFIER      shift and go to state 231
    PLUS            shift and go to state 102
    MINUS           shift and go to state 94
    DIGIT           shift and go to state 6
    NOT             shift and go to state 118
    EREAL           shift and go to state 115
    DOT             shift and go to state 95
    TRUE            shift and go to state 93
    FALSE           shift and go to state 100

    boolean_primary                shift and go to state 99
    procedure_identifier           shift and go to state 125
    primary                        shift and go to state 98
    boolean_factor                 shift and go to state 90
    relation                       shift and go to state 91
    simple_boolean                 shift and go to state 186
    boolean_secondary              shift and go to state 101
    label                          shift and go to state 67
    decimal_fraction               shift and go to state 103
    factor                         shift and go to state 104
    unsigned_number                shift and go to state 105
    simple_arithmetic_expression   shift and go to state 185
    simple_designational_expression shift and go to state 156
    logical_value                  shift and go to state 109
    switch_identifier              shift and go to state 68
    decimal_number                 shift and go to state 112
    boolean_term                   shift and go to state 88
    variable_identifier            shift and go to state 41
    function_designator            shift and go to state 110
    array_identifier               shift and go to state 14
    variable                       shift and go to state 161
    exponential_part               shift and go to state 92
    term                           shift and go to state 113
    switch_designator              shift and go to state 65
    subscripted_variable           shift and go to state 13
    simple_variable                shift and go to state 49
    adding_operator                shift and go to state 117
    implication                    shift and go to state 119
    unsigned_integer               shift and go to state 174

state 233

    (37) switch_declaration -> SWITCH switch_identifier ASSIGNMENT switch_list .
    (40) switch_list -> switch_list . COMMA designational_expression

    SEMICOLON       reduce using rule 37 (switch_declaration -> SWITCH switch_identifier ASSIGNMENT switch_list .)
    COMMA           shift and go to state 270


state 234

    (39) switch_list -> designational_expression .

    COMMA           reduce using rule 39 (switch_list -> designational_expression .)
    SEMICOLON       reduce using rule 39 (switch_list -> designational_expression .)


state 235

    (42) procedure_declaration -> type PROCEDURE procedure_heading procedure_body .

    SEMICOLON       reduce using rule 42 (procedure_declaration -> type PROCEDURE procedure_heading procedure_body .)


state 236

    (36) lower_bound -> arithmetic_expression .

    COLON           reduce using rule 36 (lower_bound -> arithmetic_expression .)


state 237

    (34) bound_pair -> lower_bound . COLON upper_bound

    COLON           shift and go to state 271


state 238

    (29) array_segment -> array_identifier LBBRACKET bound_pair_list . RBBRACKET
    (33) bound_pair_list -> bound_pair_list . COMMA bound_pair

    RBBRACKET       shift and go to state 272
    COMMA           shift and go to state 273


state 239

    (32) bound_pair_list -> bound_pair .

    RBBRACKET       reduce using rule 32 (bound_pair_list -> bound_pair .)
    COMMA           reduce using rule 32 (bound_pair_list -> bound_pair .)


state 240

    (30) array_segment -> array_identifier COMMA array_segment .

    COMMA           reduce using rule 30 (array_segment -> array_identifier COMMA array_segment .)
    SEMICOLON       reduce using rule 30 (array_segment -> array_identifier COMMA array_segment .)


state 241

    (28) array_list -> array_list COMMA array_segment .

    COMMA           reduce using rule 28 (array_list -> array_list COMMA array_segment .)
    SEMICOLON       reduce using rule 28 (array_list -> array_list COMMA array_segment .)


state 242

    (114) for_list -> for_list_element .

    DO              reduce using rule 114 (for_list -> for_list_element .)
    COMMA           reduce using rule 114 (for_list -> for_list_element .)


state 243

    (113) for_clause -> FOR variable ASSIGNMENT for_list . DO
    (115) for_list -> for_list . COMMA for_list_element

    DO              shift and go to state 274
    COMMA           shift and go to state 275


state 244

    (116) for_list_element -> arithmetic_expression .
    (117) for_list_element -> arithmetic_expression . STEP arithmetic_expression UNTIL arithmetic_expression
    (118) for_list_element -> arithmetic_expression . WHILE boolean_expression

    DO              reduce using rule 116 (for_list_element -> arithmetic_expression .)
    COMMA           reduce using rule 116 (for_list_element -> arithmetic_expression .)
    STEP            shift and go to state 276
    WHILE           shift and go to state 277


state 245

    (161) boolean_term -> boolean_term OR boolean_factor .
    (163) boolean_factor -> boolean_factor . AND boolean_secondary

    OR              reduce using rule 161 (boolean_term -> boolean_term OR boolean_factor .)
    IMPL            reduce using rule 161 (boolean_term -> boolean_term OR boolean_factor .)
    ELSE            reduce using rule 161 (boolean_term -> boolean_term OR boolean_factor .)
    EQUIV           reduce using rule 161 (boolean_term -> boolean_term OR boolean_factor .)
    RCBRACKET       reduce using rule 161 (boolean_term -> boolean_term OR boolean_factor .)
    END             reduce using rule 161 (boolean_term -> boolean_term OR boolean_factor .)
    SEMICOLON       reduce using rule 161 (boolean_term -> boolean_term OR boolean_factor .)
    THEN            reduce using rule 161 (boolean_term -> boolean_term OR boolean_factor .)
    COMMA           reduce using rule 161 (boolean_term -> boolean_term OR boolean_factor .)
    DO              reduce using rule 161 (boolean_term -> boolean_term OR boolean_factor .)
    AND             shift and go to state 187


state 246

    (123) arithmetic_expression -> if_clause simple_arithmetic_expression ELSE . arithmetic_expression
    (122) arithmetic_expression -> . simple_arithmetic_expression
    (123) arithmetic_expression -> . if_clause simple_arithmetic_expression ELSE arithmetic_expression
    (124) simple_arithmetic_expression -> . term
    (125) simple_arithmetic_expression -> . adding_operator term
    (126) simple_arithmetic_expression -> . simple_arithmetic_expression adding_operator term
    (110) if_clause -> . IF boolean_expression THEN
    (129) term -> . factor
    (130) term -> . term multiplying_operator factor
    (127) adding_operator -> . PLUS
    (128) adding_operator -> . MINUS
    (134) factor -> . primary
    (135) factor -> . factor
    (136) factor -> . factor POWER primary
    (137) primary -> . unsigned_number
    (138) primary -> . variable
    (139) primary -> . function_designator
    (140) primary -> . LCBRACKET arithmetic_expression RCBRACKET
    (141) unsigned_number -> . decimal_number
    (142) unsigned_number -> . exponential_part
    (143) unsigned_number -> . decimal_number exponential_part
    (173) variable -> . simple_variable
    (174) variable -> . subscripted_variable
    (172) function_designator -> . procedure_identifier actual_parameter_part
    (144) decimal_number -> . unsigned_integer
    (145) decimal_number -> . decimal_fraction
    (146) decimal_number -> . unsigned_integer decimal_fraction
    (150) exponential_part -> . EREAL integer
    (175) simple_variable -> . variable_identifier
    (177) subscripted_variable -> . array_identifier LBBRACKET subscript_list RBBRACKET
    (44) procedure_identifier -> . IDENTIFIER
    (147) unsigned_integer -> . DIGIT
    (148) unsigned_integer -> . unsigned_integer DIGIT
    (149) decimal_fraction -> . DOT unsigned_integer
    (176) variable_identifier -> . IDENTIFIER
    (31) array_identifier -> . IDENTIFIER

    IF              shift and go to state 45
    PLUS            shift and go to state 102
    MINUS           shift and go to state 94
    LCBRACKET       shift and go to state 145
    EREAL           shift and go to state 115
    IDENTIFIER      shift and go to state 106
    DIGIT           shift and go to state 6
    DOT             shift and go to state 95

    subscripted_variable           shift and go to state 13
    primary                        shift and go to state 98
    if_clause                      shift and go to state 144
    unsigned_number                shift and go to state 105
    decimal_fraction               shift and go to state 103
    factor                         shift and go to state 104
    simple_arithmetic_expression   shift and go to state 147
    arithmetic_expression          shift and go to state 278
    decimal_number                 shift and go to state 112
    variable_identifier            shift and go to state 41
    function_designator            shift and go to state 149
    array_identifier               shift and go to state 14
    variable                       shift and go to state 150
    exponential_part               shift and go to state 92
    term                           shift and go to state 113
    procedure_identifier           shift and go to state 125
    simple_variable                shift and go to state 49
    adding_operator                shift and go to state 117
    unsigned_integer               shift and go to state 120

state 247

    (155) boolean_expression -> if_clause simple_boolean ELSE . boolean_expression
    (154) boolean_expression -> . simple_boolean
    (155) boolean_expression -> . if_clause simple_boolean ELSE boolean_expression
    (156) simple_boolean -> . implication
    (157) simple_boolean -> . simple_boolean EQUIV implication
    (110) if_clause -> . IF boolean_expression THEN
    (158) implication -> . boolean_term
    (159) implication -> . implication IMPL boolean_term
    (160) boolean_term -> . boolean_factor
    (161) boolean_term -> . boolean_term OR boolean_factor
    (162) boolean_factor -> . boolean_secondary
    (163) boolean_factor -> . boolean_factor AND boolean_secondary
    (164) boolean_secondary -> . boolean_primary
    (165) boolean_secondary -> . NOT boolean_primary
    (166) boolean_primary -> . logical_value
    (167) boolean_primary -> . variable
    (168) boolean_primary -> . function_designator
    (169) boolean_primary -> . relation
    (170) boolean_primary -> . LCBRACKET boolean_expression RCBRACKET
    (184) logical_value -> . TRUE
    (185) logical_value -> . FALSE
    (173) variable -> . simple_variable
    (174) variable -> . subscripted_variable
    (172) function_designator -> . procedure_identifier actual_parameter_part
    (171) relation -> . simple_arithmetic_expression relational_operator simple_arithmetic_expression
    (175) simple_variable -> . variable_identifier
    (177) subscripted_variable -> . array_identifier LBBRACKET subscript_list RBBRACKET
    (44) procedure_identifier -> . IDENTIFIER
    (124) simple_arithmetic_expression -> . term
    (125) simple_arithmetic_expression -> . adding_operator term
    (126) simple_arithmetic_expression -> . simple_arithmetic_expression adding_operator term
    (176) variable_identifier -> . IDENTIFIER
    (31) array_identifier -> . IDENTIFIER
    (129) term -> . factor
    (130) term -> . term multiplying_operator factor
    (127) adding_operator -> . PLUS
    (128) adding_operator -> . MINUS
    (134) factor -> . primary
    (135) factor -> . factor
    (136) factor -> . factor POWER primary
    (137) primary -> . unsigned_number
    (138) primary -> . variable
    (139) primary -> . function_designator
    (140) primary -> . LCBRACKET arithmetic_expression RCBRACKET
    (141) unsigned_number -> . decimal_number
    (142) unsigned_number -> . exponential_part
    (143) unsigned_number -> . decimal_number exponential_part
    (144) decimal_number -> . unsigned_integer
    (145) decimal_number -> . decimal_fraction
    (146) decimal_number -> . unsigned_integer decimal_fraction
    (150) exponential_part -> . EREAL integer
    (147) unsigned_integer -> . DIGIT
    (148) unsigned_integer -> . unsigned_integer DIGIT
    (149) decimal_fraction -> . DOT unsigned_integer

    IF              shift and go to state 45
    NOT             shift and go to state 118
    LCBRACKET       shift and go to state 127
    TRUE            shift and go to state 93
    FALSE           shift and go to state 100
    IDENTIFIER      shift and go to state 106
    PLUS            shift and go to state 102
    MINUS           shift and go to state 94
    EREAL           shift and go to state 115
    DIGIT           shift and go to state 6
    DOT             shift and go to state 95

    subscripted_variable           shift and go to state 13
    boolean_term                   shift and go to state 88
    if_clause                      shift and go to state 126
    boolean_factor                 shift and go to state 90
    relation                       shift and go to state 91
    simple_boolean                 shift and go to state 97
    boolean_secondary              shift and go to state 101
    unsigned_number                shift and go to state 105
    decimal_fraction               shift and go to state 103
    factor                         shift and go to state 104
    simple_arithmetic_expression   shift and go to state 131
    boolean_primary                shift and go to state 99
    logical_value                  shift and go to state 109
    decimal_number                 shift and go to state 112
    primary                        shift and go to state 98
    variable_identifier            shift and go to state 41
    function_designator            shift and go to state 128
    array_identifier               shift and go to state 14
    variable                       shift and go to state 129
    exponential_part               shift and go to state 92
    term                           shift and go to state 113
    boolean_expression             shift and go to state 279
    procedure_identifier           shift and go to state 125
    simple_variable                shift and go to state 49
    adding_operator                shift and go to state 117
    implication                    shift and go to state 119
    unsigned_integer               shift and go to state 120

state 248

    (163) boolean_factor -> boolean_factor AND boolean_secondary .

    AND             reduce using rule 163 (boolean_factor -> boolean_factor AND boolean_secondary .)
    OR              reduce using rule 163 (boolean_factor -> boolean_factor AND boolean_secondary .)
    IMPL            reduce using rule 163 (boolean_factor -> boolean_factor AND boolean_secondary .)
    ELSE            reduce using rule 163 (boolean_factor -> boolean_factor AND boolean_secondary .)
    EQUIV           reduce using rule 163 (boolean_factor -> boolean_factor AND boolean_secondary .)
    END             reduce using rule 163 (boolean_factor -> boolean_factor AND boolean_secondary .)
    SEMICOLON       reduce using rule 163 (boolean_factor -> boolean_factor AND boolean_secondary .)
    RCBRACKET       reduce using rule 163 (boolean_factor -> boolean_factor AND boolean_secondary .)
    THEN            reduce using rule 163 (boolean_factor -> boolean_factor AND boolean_secondary .)
    COMMA           reduce using rule 163 (boolean_factor -> boolean_factor AND boolean_secondary .)
    DO              reduce using rule 163 (boolean_factor -> boolean_factor AND boolean_secondary .)


state 249

    (157) simple_boolean -> simple_boolean EQUIV implication .
    (159) implication -> implication . IMPL boolean_term

    EQUIV           reduce using rule 157 (simple_boolean -> simple_boolean EQUIV implication .)
    RCBRACKET       reduce using rule 157 (simple_boolean -> simple_boolean EQUIV implication .)
    COMMA           reduce using rule 157 (simple_boolean -> simple_boolean EQUIV implication .)
    THEN            reduce using rule 157 (simple_boolean -> simple_boolean EQUIV implication .)
    ELSE            reduce using rule 157 (simple_boolean -> simple_boolean EQUIV implication .)
    DO              reduce using rule 157 (simple_boolean -> simple_boolean EQUIV implication .)
    END             reduce using rule 157 (simple_boolean -> simple_boolean EQUIV implication .)
    SEMICOLON       reduce using rule 157 (simple_boolean -> simple_boolean EQUIV implication .)
    IMPL            shift and go to state 212


state 250

    (136) factor -> factor POWER primary .

    POWER           reduce using rule 136 (factor -> factor POWER primary .)
    TIMES           reduce using rule 136 (factor -> factor POWER primary .)
    DIV             reduce using rule 136 (factor -> factor POWER primary .)
    MOD             reduce using rule 136 (factor -> factor POWER primary .)
    PLUS            reduce using rule 136 (factor -> factor POWER primary .)
    MINUS           reduce using rule 136 (factor -> factor POWER primary .)
    STEP            reduce using rule 136 (factor -> factor POWER primary .)
    WHILE           reduce using rule 136 (factor -> factor POWER primary .)
    DO              reduce using rule 136 (factor -> factor POWER primary .)
    COMMA           reduce using rule 136 (factor -> factor POWER primary .)
    UNTIL           reduce using rule 136 (factor -> factor POWER primary .)
    LESS            reduce using rule 136 (factor -> factor POWER primary .)
    NOTGREATER      reduce using rule 136 (factor -> factor POWER primary .)
    EQUAL           reduce using rule 136 (factor -> factor POWER primary .)
    NOTLESS         reduce using rule 136 (factor -> factor POWER primary .)
    GREATER         reduce using rule 136 (factor -> factor POWER primary .)
    NOTEQUAL        reduce using rule 136 (factor -> factor POWER primary .)
    RCBRACKET       reduce using rule 136 (factor -> factor POWER primary .)
    COLON           reduce using rule 136 (factor -> factor POWER primary .)
    AND             reduce using rule 136 (factor -> factor POWER primary .)
    OR              reduce using rule 136 (factor -> factor POWER primary .)
    IMPL            reduce using rule 136 (factor -> factor POWER primary .)
    EQUIV           reduce using rule 136 (factor -> factor POWER primary .)
    END             reduce using rule 136 (factor -> factor POWER primary .)
    SEMICOLON       reduce using rule 136 (factor -> factor POWER primary .)
    ELSE            reduce using rule 136 (factor -> factor POWER primary .)
    THEN            reduce using rule 136 (factor -> factor POWER primary .)
    RBBRACKET       reduce using rule 136 (factor -> factor POWER primary .)


state 251

    (171) relation -> simple_arithmetic_expression relational_operator simple_arithmetic_expression .
    (126) simple_arithmetic_expression -> simple_arithmetic_expression . adding_operator term
    (127) adding_operator -> . PLUS
    (128) adding_operator -> . MINUS

    AND             reduce using rule 171 (relation -> simple_arithmetic_expression relational_operator simple_arithmetic_expression .)
    OR              reduce using rule 171 (relation -> simple_arithmetic_expression relational_operator simple_arithmetic_expression .)
    IMPL            reduce using rule 171 (relation -> simple_arithmetic_expression relational_operator simple_arithmetic_expression .)
    EQUIV           reduce using rule 171 (relation -> simple_arithmetic_expression relational_operator simple_arithmetic_expression .)
    END             reduce using rule 171 (relation -> simple_arithmetic_expression relational_operator simple_arithmetic_expression .)
    SEMICOLON       reduce using rule 171 (relation -> simple_arithmetic_expression relational_operator simple_arithmetic_expression .)
    ELSE            reduce using rule 171 (relation -> simple_arithmetic_expression relational_operator simple_arithmetic_expression .)
    THEN            reduce using rule 171 (relation -> simple_arithmetic_expression relational_operator simple_arithmetic_expression .)
    RCBRACKET       reduce using rule 171 (relation -> simple_arithmetic_expression relational_operator simple_arithmetic_expression .)
    COMMA           reduce using rule 171 (relation -> simple_arithmetic_expression relational_operator simple_arithmetic_expression .)
    DO              reduce using rule 171 (relation -> simple_arithmetic_expression relational_operator simple_arithmetic_expression .)
    PLUS            shift and go to state 102
    MINUS           shift and go to state 94

    adding_operator                shift and go to state 195

state 252

    (126) simple_arithmetic_expression -> simple_arithmetic_expression adding_operator term .
    (130) term -> term . multiplying_operator factor
    (131) multiplying_operator -> . TIMES
    (132) multiplying_operator -> . DIV
    (133) multiplying_operator -> . MOD

    PLUS            reduce using rule 126 (simple_arithmetic_expression -> simple_arithmetic_expression adding_operator term .)
    MINUS           reduce using rule 126 (simple_arithmetic_expression -> simple_arithmetic_expression adding_operator term .)
    LESS            reduce using rule 126 (simple_arithmetic_expression -> simple_arithmetic_expression adding_operator term .)
    NOTGREATER      reduce using rule 126 (simple_arithmetic_expression -> simple_arithmetic_expression adding_operator term .)
    EQUAL           reduce using rule 126 (simple_arithmetic_expression -> simple_arithmetic_expression adding_operator term .)
    NOTLESS         reduce using rule 126 (simple_arithmetic_expression -> simple_arithmetic_expression adding_operator term .)
    GREATER         reduce using rule 126 (simple_arithmetic_expression -> simple_arithmetic_expression adding_operator term .)
    NOTEQUAL        reduce using rule 126 (simple_arithmetic_expression -> simple_arithmetic_expression adding_operator term .)
    RCBRACKET       reduce using rule 126 (simple_arithmetic_expression -> simple_arithmetic_expression adding_operator term .)
    RBBRACKET       reduce using rule 126 (simple_arithmetic_expression -> simple_arithmetic_expression adding_operator term .)
    COMMA           reduce using rule 126 (simple_arithmetic_expression -> simple_arithmetic_expression adding_operator term .)
    ELSE            reduce using rule 126 (simple_arithmetic_expression -> simple_arithmetic_expression adding_operator term .)
    END             reduce using rule 126 (simple_arithmetic_expression -> simple_arithmetic_expression adding_operator term .)
    SEMICOLON       reduce using rule 126 (simple_arithmetic_expression -> simple_arithmetic_expression adding_operator term .)
    AND             reduce using rule 126 (simple_arithmetic_expression -> simple_arithmetic_expression adding_operator term .)
    OR              reduce using rule 126 (simple_arithmetic_expression -> simple_arithmetic_expression adding_operator term .)
    IMPL            reduce using rule 126 (simple_arithmetic_expression -> simple_arithmetic_expression adding_operator term .)
    EQUIV           reduce using rule 126 (simple_arithmetic_expression -> simple_arithmetic_expression adding_operator term .)
    THEN            reduce using rule 126 (simple_arithmetic_expression -> simple_arithmetic_expression adding_operator term .)
    DO              reduce using rule 126 (simple_arithmetic_expression -> simple_arithmetic_expression adding_operator term .)
    STEP            reduce using rule 126 (simple_arithmetic_expression -> simple_arithmetic_expression adding_operator term .)
    WHILE           reduce using rule 126 (simple_arithmetic_expression -> simple_arithmetic_expression adding_operator term .)
    COLON           reduce using rule 126 (simple_arithmetic_expression -> simple_arithmetic_expression adding_operator term .)
    UNTIL           reduce using rule 126 (simple_arithmetic_expression -> simple_arithmetic_expression adding_operator term .)
    TIMES           shift and go to state 200
    DIV             shift and go to state 201
    MOD             shift and go to state 203

    multiplying_operator           shift and go to state 202

state 253

    (130) term -> term multiplying_operator factor .
    (135) factor -> factor .
    (136) factor -> factor . POWER primary

  ! reduce/reduce conflict for TIMES resolved using rule 130 (term -> term multiplying_operator factor .)
  ! reduce/reduce conflict for DIV resolved using rule 130 (term -> term multiplying_operator factor .)
  ! reduce/reduce conflict for MOD resolved using rule 130 (term -> term multiplying_operator factor .)
  ! reduce/reduce conflict for PLUS resolved using rule 130 (term -> term multiplying_operator factor .)
  ! reduce/reduce conflict for MINUS resolved using rule 130 (term -> term multiplying_operator factor .)
  ! reduce/reduce conflict for LESS resolved using rule 130 (term -> term multiplying_operator factor .)
  ! reduce/reduce conflict for NOTGREATER resolved using rule 130 (term -> term multiplying_operator factor .)
  ! reduce/reduce conflict for EQUAL resolved using rule 130 (term -> term multiplying_operator factor .)
  ! reduce/reduce conflict for NOTLESS resolved using rule 130 (term -> term multiplying_operator factor .)
  ! reduce/reduce conflict for GREATER resolved using rule 130 (term -> term multiplying_operator factor .)
  ! reduce/reduce conflict for NOTEQUAL resolved using rule 130 (term -> term multiplying_operator factor .)
  ! reduce/reduce conflict for END resolved using rule 130 (term -> term multiplying_operator factor .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 130 (term -> term multiplying_operator factor .)
  ! reduce/reduce conflict for ELSE resolved using rule 130 (term -> term multiplying_operator factor .)
  ! reduce/reduce conflict for RBBRACKET resolved using rule 130 (term -> term multiplying_operator factor .)
  ! reduce/reduce conflict for COMMA resolved using rule 130 (term -> term multiplying_operator factor .)
  ! reduce/reduce conflict for RCBRACKET resolved using rule 130 (term -> term multiplying_operator factor .)
  ! reduce/reduce conflict for COLON resolved using rule 130 (term -> term multiplying_operator factor .)
  ! reduce/reduce conflict for STEP resolved using rule 130 (term -> term multiplying_operator factor .)
  ! reduce/reduce conflict for WHILE resolved using rule 130 (term -> term multiplying_operator factor .)
  ! reduce/reduce conflict for DO resolved using rule 130 (term -> term multiplying_operator factor .)
  ! reduce/reduce conflict for AND resolved using rule 130 (term -> term multiplying_operator factor .)
  ! reduce/reduce conflict for OR resolved using rule 130 (term -> term multiplying_operator factor .)
  ! reduce/reduce conflict for IMPL resolved using rule 130 (term -> term multiplying_operator factor .)
  ! reduce/reduce conflict for EQUIV resolved using rule 130 (term -> term multiplying_operator factor .)
  ! reduce/reduce conflict for THEN resolved using rule 130 (term -> term multiplying_operator factor .)
  ! reduce/reduce conflict for UNTIL resolved using rule 130 (term -> term multiplying_operator factor .)
  ! shift/reduce conflict for POWER resolved as shift
    TIMES           reduce using rule 130 (term -> term multiplying_operator factor .)
    DIV             reduce using rule 130 (term -> term multiplying_operator factor .)
    MOD             reduce using rule 130 (term -> term multiplying_operator factor .)
    ELSE            reduce using rule 130 (term -> term multiplying_operator factor .)
    PLUS            reduce using rule 130 (term -> term multiplying_operator factor .)
    MINUS           reduce using rule 130 (term -> term multiplying_operator factor .)
    LESS            reduce using rule 130 (term -> term multiplying_operator factor .)
    NOTGREATER      reduce using rule 130 (term -> term multiplying_operator factor .)
    EQUAL           reduce using rule 130 (term -> term multiplying_operator factor .)
    NOTLESS         reduce using rule 130 (term -> term multiplying_operator factor .)
    GREATER         reduce using rule 130 (term -> term multiplying_operator factor .)
    NOTEQUAL        reduce using rule 130 (term -> term multiplying_operator factor .)
    RCBRACKET       reduce using rule 130 (term -> term multiplying_operator factor .)
    END             reduce using rule 130 (term -> term multiplying_operator factor .)
    SEMICOLON       reduce using rule 130 (term -> term multiplying_operator factor .)
    RBBRACKET       reduce using rule 130 (term -> term multiplying_operator factor .)
    COMMA           reduce using rule 130 (term -> term multiplying_operator factor .)
    COLON           reduce using rule 130 (term -> term multiplying_operator factor .)
    STEP            reduce using rule 130 (term -> term multiplying_operator factor .)
    WHILE           reduce using rule 130 (term -> term multiplying_operator factor .)
    DO              reduce using rule 130 (term -> term multiplying_operator factor .)
    AND             reduce using rule 130 (term -> term multiplying_operator factor .)
    OR              reduce using rule 130 (term -> term multiplying_operator factor .)
    IMPL            reduce using rule 130 (term -> term multiplying_operator factor .)
    EQUIV           reduce using rule 130 (term -> term multiplying_operator factor .)
    THEN            reduce using rule 130 (term -> term multiplying_operator factor .)
    UNTIL           reduce using rule 130 (term -> term multiplying_operator factor .)
    POWER           shift and go to state 190

  ! POWER           [ reduce using rule 135 (factor -> factor .) ]
  ! TIMES           [ reduce using rule 135 (factor -> factor .) ]
  ! DIV             [ reduce using rule 135 (factor -> factor .) ]
  ! MOD             [ reduce using rule 135 (factor -> factor .) ]
  ! PLUS            [ reduce using rule 135 (factor -> factor .) ]
  ! MINUS           [ reduce using rule 135 (factor -> factor .) ]
  ! LESS            [ reduce using rule 135 (factor -> factor .) ]
  ! NOTGREATER      [ reduce using rule 135 (factor -> factor .) ]
  ! EQUAL           [ reduce using rule 135 (factor -> factor .) ]
  ! NOTLESS         [ reduce using rule 135 (factor -> factor .) ]
  ! GREATER         [ reduce using rule 135 (factor -> factor .) ]
  ! NOTEQUAL        [ reduce using rule 135 (factor -> factor .) ]
  ! END             [ reduce using rule 135 (factor -> factor .) ]
  ! SEMICOLON       [ reduce using rule 135 (factor -> factor .) ]
  ! ELSE            [ reduce using rule 135 (factor -> factor .) ]
  ! RBBRACKET       [ reduce using rule 135 (factor -> factor .) ]
  ! COMMA           [ reduce using rule 135 (factor -> factor .) ]
  ! RCBRACKET       [ reduce using rule 135 (factor -> factor .) ]
  ! COLON           [ reduce using rule 135 (factor -> factor .) ]
  ! STEP            [ reduce using rule 135 (factor -> factor .) ]
  ! WHILE           [ reduce using rule 135 (factor -> factor .) ]
  ! DO              [ reduce using rule 135 (factor -> factor .) ]
  ! AND             [ reduce using rule 135 (factor -> factor .) ]
  ! OR              [ reduce using rule 135 (factor -> factor .) ]
  ! IMPL            [ reduce using rule 135 (factor -> factor .) ]
  ! EQUIV           [ reduce using rule 135 (factor -> factor .) ]
  ! THEN            [ reduce using rule 135 (factor -> factor .) ]
  ! UNTIL           [ reduce using rule 135 (factor -> factor .) ]


state 254

    (152) integer -> PLUS unsigned_integer .
    (148) unsigned_integer -> unsigned_integer . DIGIT

    POWER           reduce using rule 152 (integer -> PLUS unsigned_integer .)
    TIMES           reduce using rule 152 (integer -> PLUS unsigned_integer .)
    DIV             reduce using rule 152 (integer -> PLUS unsigned_integer .)
    MOD             reduce using rule 152 (integer -> PLUS unsigned_integer .)
    PLUS            reduce using rule 152 (integer -> PLUS unsigned_integer .)
    MINUS           reduce using rule 152 (integer -> PLUS unsigned_integer .)
    LESS            reduce using rule 152 (integer -> PLUS unsigned_integer .)
    NOTGREATER      reduce using rule 152 (integer -> PLUS unsigned_integer .)
    EQUAL           reduce using rule 152 (integer -> PLUS unsigned_integer .)
    NOTLESS         reduce using rule 152 (integer -> PLUS unsigned_integer .)
    GREATER         reduce using rule 152 (integer -> PLUS unsigned_integer .)
    NOTEQUAL        reduce using rule 152 (integer -> PLUS unsigned_integer .)
    END             reduce using rule 152 (integer -> PLUS unsigned_integer .)
    SEMICOLON       reduce using rule 152 (integer -> PLUS unsigned_integer .)
    ELSE            reduce using rule 152 (integer -> PLUS unsigned_integer .)
    RBBRACKET       reduce using rule 152 (integer -> PLUS unsigned_integer .)
    COMMA           reduce using rule 152 (integer -> PLUS unsigned_integer .)
    RCBRACKET       reduce using rule 152 (integer -> PLUS unsigned_integer .)
    COLON           reduce using rule 152 (integer -> PLUS unsigned_integer .)
    STEP            reduce using rule 152 (integer -> PLUS unsigned_integer .)
    WHILE           reduce using rule 152 (integer -> PLUS unsigned_integer .)
    DO              reduce using rule 152 (integer -> PLUS unsigned_integer .)
    AND             reduce using rule 152 (integer -> PLUS unsigned_integer .)
    OR              reduce using rule 152 (integer -> PLUS unsigned_integer .)
    IMPL            reduce using rule 152 (integer -> PLUS unsigned_integer .)
    EQUIV           reduce using rule 152 (integer -> PLUS unsigned_integer .)
    THEN            reduce using rule 152 (integer -> PLUS unsigned_integer .)
    UNTIL           reduce using rule 152 (integer -> PLUS unsigned_integer .)
    DIGIT           shift and go to state 57


state 255

    (153) integer -> MINUS unsigned_integer .
    (148) unsigned_integer -> unsigned_integer . DIGIT

    POWER           reduce using rule 153 (integer -> MINUS unsigned_integer .)
    TIMES           reduce using rule 153 (integer -> MINUS unsigned_integer .)
    DIV             reduce using rule 153 (integer -> MINUS unsigned_integer .)
    MOD             reduce using rule 153 (integer -> MINUS unsigned_integer .)
    PLUS            reduce using rule 153 (integer -> MINUS unsigned_integer .)
    MINUS           reduce using rule 153 (integer -> MINUS unsigned_integer .)
    LESS            reduce using rule 153 (integer -> MINUS unsigned_integer .)
    NOTGREATER      reduce using rule 153 (integer -> MINUS unsigned_integer .)
    EQUAL           reduce using rule 153 (integer -> MINUS unsigned_integer .)
    NOTLESS         reduce using rule 153 (integer -> MINUS unsigned_integer .)
    GREATER         reduce using rule 153 (integer -> MINUS unsigned_integer .)
    NOTEQUAL        reduce using rule 153 (integer -> MINUS unsigned_integer .)
    END             reduce using rule 153 (integer -> MINUS unsigned_integer .)
    SEMICOLON       reduce using rule 153 (integer -> MINUS unsigned_integer .)
    ELSE            reduce using rule 153 (integer -> MINUS unsigned_integer .)
    RBBRACKET       reduce using rule 153 (integer -> MINUS unsigned_integer .)
    COMMA           reduce using rule 153 (integer -> MINUS unsigned_integer .)
    RCBRACKET       reduce using rule 153 (integer -> MINUS unsigned_integer .)
    COLON           reduce using rule 153 (integer -> MINUS unsigned_integer .)
    STEP            reduce using rule 153 (integer -> MINUS unsigned_integer .)
    WHILE           reduce using rule 153 (integer -> MINUS unsigned_integer .)
    DO              reduce using rule 153 (integer -> MINUS unsigned_integer .)
    AND             reduce using rule 153 (integer -> MINUS unsigned_integer .)
    OR              reduce using rule 153 (integer -> MINUS unsigned_integer .)
    IMPL            reduce using rule 153 (integer -> MINUS unsigned_integer .)
    EQUIV           reduce using rule 153 (integer -> MINUS unsigned_integer .)
    THEN            reduce using rule 153 (integer -> MINUS unsigned_integer .)
    UNTIL           reduce using rule 153 (integer -> MINUS unsigned_integer .)
    DIGIT           shift and go to state 57


state 256

    (140) primary -> LCBRACKET arithmetic_expression RCBRACKET .

    POWER           reduce using rule 140 (primary -> LCBRACKET arithmetic_expression RCBRACKET .)
    TIMES           reduce using rule 140 (primary -> LCBRACKET arithmetic_expression RCBRACKET .)
    DIV             reduce using rule 140 (primary -> LCBRACKET arithmetic_expression RCBRACKET .)
    MOD             reduce using rule 140 (primary -> LCBRACKET arithmetic_expression RCBRACKET .)
    PLUS            reduce using rule 140 (primary -> LCBRACKET arithmetic_expression RCBRACKET .)
    MINUS           reduce using rule 140 (primary -> LCBRACKET arithmetic_expression RCBRACKET .)
    LESS            reduce using rule 140 (primary -> LCBRACKET arithmetic_expression RCBRACKET .)
    NOTGREATER      reduce using rule 140 (primary -> LCBRACKET arithmetic_expression RCBRACKET .)
    EQUAL           reduce using rule 140 (primary -> LCBRACKET arithmetic_expression RCBRACKET .)
    NOTLESS         reduce using rule 140 (primary -> LCBRACKET arithmetic_expression RCBRACKET .)
    GREATER         reduce using rule 140 (primary -> LCBRACKET arithmetic_expression RCBRACKET .)
    NOTEQUAL        reduce using rule 140 (primary -> LCBRACKET arithmetic_expression RCBRACKET .)
    RCBRACKET       reduce using rule 140 (primary -> LCBRACKET arithmetic_expression RCBRACKET .)
    ELSE            reduce using rule 140 (primary -> LCBRACKET arithmetic_expression RCBRACKET .)
    STEP            reduce using rule 140 (primary -> LCBRACKET arithmetic_expression RCBRACKET .)
    WHILE           reduce using rule 140 (primary -> LCBRACKET arithmetic_expression RCBRACKET .)
    DO              reduce using rule 140 (primary -> LCBRACKET arithmetic_expression RCBRACKET .)
    COMMA           reduce using rule 140 (primary -> LCBRACKET arithmetic_expression RCBRACKET .)
    COLON           reduce using rule 140 (primary -> LCBRACKET arithmetic_expression RCBRACKET .)
    END             reduce using rule 140 (primary -> LCBRACKET arithmetic_expression RCBRACKET .)
    SEMICOLON       reduce using rule 140 (primary -> LCBRACKET arithmetic_expression RCBRACKET .)
    RBBRACKET       reduce using rule 140 (primary -> LCBRACKET arithmetic_expression RCBRACKET .)
    UNTIL           reduce using rule 140 (primary -> LCBRACKET arithmetic_expression RCBRACKET .)
    AND             reduce using rule 140 (primary -> LCBRACKET arithmetic_expression RCBRACKET .)
    OR              reduce using rule 140 (primary -> LCBRACKET arithmetic_expression RCBRACKET .)
    IMPL            reduce using rule 140 (primary -> LCBRACKET arithmetic_expression RCBRACKET .)
    EQUIV           reduce using rule 140 (primary -> LCBRACKET arithmetic_expression RCBRACKET .)
    THEN            reduce using rule 140 (primary -> LCBRACKET arithmetic_expression RCBRACKET .)


state 257

    (170) boolean_primary -> LCBRACKET boolean_expression RCBRACKET .

    AND             reduce using rule 170 (boolean_primary -> LCBRACKET boolean_expression RCBRACKET .)
    OR              reduce using rule 170 (boolean_primary -> LCBRACKET boolean_expression RCBRACKET .)
    IMPL            reduce using rule 170 (boolean_primary -> LCBRACKET boolean_expression RCBRACKET .)
    EQUIV           reduce using rule 170 (boolean_primary -> LCBRACKET boolean_expression RCBRACKET .)
    END             reduce using rule 170 (boolean_primary -> LCBRACKET boolean_expression RCBRACKET .)
    SEMICOLON       reduce using rule 170 (boolean_primary -> LCBRACKET boolean_expression RCBRACKET .)
    ELSE            reduce using rule 170 (boolean_primary -> LCBRACKET boolean_expression RCBRACKET .)
    THEN            reduce using rule 170 (boolean_primary -> LCBRACKET boolean_expression RCBRACKET .)
    RCBRACKET       reduce using rule 170 (boolean_primary -> LCBRACKET boolean_expression RCBRACKET .)
    COMMA           reduce using rule 170 (boolean_primary -> LCBRACKET boolean_expression RCBRACKET .)
    DO              reduce using rule 170 (boolean_primary -> LCBRACKET boolean_expression RCBRACKET .)


state 258

    (159) implication -> implication IMPL boolean_term .
    (161) boolean_term -> boolean_term . OR boolean_factor

    IMPL            reduce using rule 159 (implication -> implication IMPL boolean_term .)
    EQUIV           reduce using rule 159 (implication -> implication IMPL boolean_term .)
    END             reduce using rule 159 (implication -> implication IMPL boolean_term .)
    SEMICOLON       reduce using rule 159 (implication -> implication IMPL boolean_term .)
    ELSE            reduce using rule 159 (implication -> implication IMPL boolean_term .)
    THEN            reduce using rule 159 (implication -> implication IMPL boolean_term .)
    RCBRACKET       reduce using rule 159 (implication -> implication IMPL boolean_term .)
    COMMA           reduce using rule 159 (implication -> implication IMPL boolean_term .)
    DO              reduce using rule 159 (implication -> implication IMPL boolean_term .)
    OR              shift and go to state 184


state 259

    (43) procedure_heading -> procedure_identifier formal_parameter_part SEMICOLON . value_part specification_part
    (50) value_part -> .
    (51) value_part -> . TVALUE identifier_list SEMICOLON

    TSTRING         reduce using rule 50 (value_part -> .)
    TARRAY          reduce using rule 50 (value_part -> .)
    TLABEL          reduce using rule 50 (value_part -> .)
    SWITCH          reduce using rule 50 (value_part -> .)
    PROCEDURE       reduce using rule 50 (value_part -> .)
    TREAL           reduce using rule 50 (value_part -> .)
    TINTEGER        reduce using rule 50 (value_part -> .)
    TBOOLEAN        reduce using rule 50 (value_part -> .)
    IF              reduce using rule 50 (value_part -> .)
    IDENTIFIER      reduce using rule 50 (value_part -> .)
    FOR             reduce using rule 50 (value_part -> .)
    BEGIN           reduce using rule 50 (value_part -> .)
    DIGIT           reduce using rule 50 (value_part -> .)
    GOTO            reduce using rule 50 (value_part -> .)
    SEMICOLON       reduce using rule 50 (value_part -> .)
    TVALUE          shift and go to state 280

    value_part                     shift and go to state 281

state 260

    (46) formal_parameter_part -> LCBRACKET formal_parameter_list . RCBRACKET
    (48) formal_parameter_list -> formal_parameter_list . parameter_delimiter formal_parameter
    (98) parameter_delimiter -> . COMMA
    (99) parameter_delimiter -> . RCBRACKET letter_string COLON LCBRACKET

    RCBRACKET       shift and go to state 282
    COMMA           shift and go to state 230

    parameter_delimiter            shift and go to state 283

state 261

    (47) formal_parameter_list -> formal_parameter .

    RCBRACKET       reduce using rule 47 (formal_parameter_list -> formal_parameter .)
    COMMA           reduce using rule 47 (formal_parameter_list -> formal_parameter .)


state 262

    (49) formal_parameter -> IDENTIFIER .

    RCBRACKET       reduce using rule 49 (formal_parameter -> IDENTIFIER .)
    COMMA           reduce using rule 49 (formal_parameter -> IDENTIFIER .)


state 263

    (24) type_list -> simple_variable COMMA type_list .

    SEMICOLON       reduce using rule 24 (type_list -> simple_variable COMMA type_list .)


state 264

    (179) subscript_list -> subscript_list COMMA subscript_expression .

    RBBRACKET       reduce using rule 179 (subscript_list -> subscript_list COMMA subscript_expression .)
    COMMA           reduce using rule 179 (subscript_list -> subscript_list COMMA subscript_expression .)


state 265

    (88) designational_expression -> if_clause simple_designational_expression ELSE designational_expression .

    RCBRACKET       reduce using rule 88 (designational_expression -> if_clause simple_designational_expression ELSE designational_expression .)
    END             reduce using rule 88 (designational_expression -> if_clause simple_designational_expression ELSE designational_expression .)
    SEMICOLON       reduce using rule 88 (designational_expression -> if_clause simple_designational_expression ELSE designational_expression .)
    ELSE            reduce using rule 88 (designational_expression -> if_clause simple_designational_expression ELSE designational_expression .)
    COMMA           reduce using rule 88 (designational_expression -> if_clause simple_designational_expression ELSE designational_expression .)


state 266

    (92) switch_designator -> switch_identifier LBBRACKET subscript_expression RBBRACKET .

    COMMA           reduce using rule 92 (switch_designator -> switch_identifier LBBRACKET subscript_expression RBBRACKET .)
    SEMICOLON       reduce using rule 92 (switch_designator -> switch_identifier LBBRACKET subscript_expression RBBRACKET .)
    RCBRACKET       reduce using rule 92 (switch_designator -> switch_identifier LBBRACKET subscript_expression RBBRACKET .)
    ELSE            reduce using rule 92 (switch_designator -> switch_identifier LBBRACKET subscript_expression RBBRACKET .)
    END             reduce using rule 92 (switch_designator -> switch_identifier LBBRACKET subscript_expression RBBRACKET .)


state 267

    (99) parameter_delimiter -> RCBRACKET letter_string . COLON LCBRACKET
    (183) letter_string -> letter_string . LETTER

    COLON           shift and go to state 284
    LETTER          shift and go to state 285


state 268

    (182) letter_string -> LETTER .

    COLON           reduce using rule 182 (letter_string -> LETTER .)
    LETTER          reduce using rule 182 (letter_string -> LETTER .)


state 269

    (97) actual_parameter_list -> actual_parameter_list parameter_delimiter actual_parameter .

    RCBRACKET       reduce using rule 97 (actual_parameter_list -> actual_parameter_list parameter_delimiter actual_parameter .)
    COMMA           reduce using rule 97 (actual_parameter_list -> actual_parameter_list parameter_delimiter actual_parameter .)


state 270

    (40) switch_list -> switch_list COMMA . designational_expression
    (87) designational_expression -> . simple_designational_expression
    (88) designational_expression -> . if_clause simple_designational_expression ELSE designational_expression
    (89) simple_designational_expression -> . label
    (90) simple_designational_expression -> . switch_designator
    (91) simple_designational_expression -> . LCBRACKET designational_expression RCBRACKET
    (110) if_clause -> . IF boolean_expression THEN
    (74) label -> . IDENTIFIER
    (75) label -> . unsigned_integer
    (92) switch_designator -> . switch_identifier LBBRACKET subscript_expression RBBRACKET
    (147) unsigned_integer -> . DIGIT
    (148) unsigned_integer -> . unsigned_integer DIGIT
    (38) switch_identifier -> . IDENTIFIER

    LCBRACKET       shift and go to state 69
    IF              shift and go to state 45
    IDENTIFIER      shift and go to state 70
    DIGIT           shift and go to state 6

    designational_expression       shift and go to state 286
    simple_designational_expression shift and go to state 71
    switch_designator              shift and go to state 65
    if_clause                      shift and go to state 66
    label                          shift and go to state 67
    switch_identifier              shift and go to state 68
    unsigned_integer               shift and go to state 9

state 271

    (34) bound_pair -> lower_bound COLON . upper_bound
    (35) upper_bound -> . arithmetic_expression
    (122) arithmetic_expression -> . simple_arithmetic_expression
    (123) arithmetic_expression -> . if_clause simple_arithmetic_expression ELSE arithmetic_expression
    (124) simple_arithmetic_expression -> . term
    (125) simple_arithmetic_expression -> . adding_operator term
    (126) simple_arithmetic_expression -> . simple_arithmetic_expression adding_operator term
    (110) if_clause -> . IF boolean_expression THEN
    (129) term -> . factor
    (130) term -> . term multiplying_operator factor
    (127) adding_operator -> . PLUS
    (128) adding_operator -> . MINUS
    (134) factor -> . primary
    (135) factor -> . factor
    (136) factor -> . factor POWER primary
    (137) primary -> . unsigned_number
    (138) primary -> . variable
    (139) primary -> . function_designator
    (140) primary -> . LCBRACKET arithmetic_expression RCBRACKET
    (141) unsigned_number -> . decimal_number
    (142) unsigned_number -> . exponential_part
    (143) unsigned_number -> . decimal_number exponential_part
    (173) variable -> . simple_variable
    (174) variable -> . subscripted_variable
    (172) function_designator -> . procedure_identifier actual_parameter_part
    (144) decimal_number -> . unsigned_integer
    (145) decimal_number -> . decimal_fraction
    (146) decimal_number -> . unsigned_integer decimal_fraction
    (150) exponential_part -> . EREAL integer
    (175) simple_variable -> . variable_identifier
    (177) subscripted_variable -> . array_identifier LBBRACKET subscript_list RBBRACKET
    (44) procedure_identifier -> . IDENTIFIER
    (147) unsigned_integer -> . DIGIT
    (148) unsigned_integer -> . unsigned_integer DIGIT
    (149) decimal_fraction -> . DOT unsigned_integer
    (176) variable_identifier -> . IDENTIFIER
    (31) array_identifier -> . IDENTIFIER

    IF              shift and go to state 45
    PLUS            shift and go to state 102
    MINUS           shift and go to state 94
    LCBRACKET       shift and go to state 145
    EREAL           shift and go to state 115
    IDENTIFIER      shift and go to state 106
    DIGIT           shift and go to state 6
    DOT             shift and go to state 95

    subscripted_variable           shift and go to state 13
    primary                        shift and go to state 98
    if_clause                      shift and go to state 144
    unsigned_number                shift and go to state 105
    decimal_fraction               shift and go to state 103
    factor                         shift and go to state 104
    simple_arithmetic_expression   shift and go to state 147
    arithmetic_expression          shift and go to state 287
    decimal_number                 shift and go to state 112
    variable_identifier            shift and go to state 41
    function_designator            shift and go to state 149
    array_identifier               shift and go to state 14
    variable                       shift and go to state 150
    exponential_part               shift and go to state 92
    term                           shift and go to state 113
    upper_bound                    shift and go to state 288
    procedure_identifier           shift and go to state 125
    simple_variable                shift and go to state 49
    adding_operator                shift and go to state 117
    unsigned_integer               shift and go to state 120

state 272

    (29) array_segment -> array_identifier LBBRACKET bound_pair_list RBBRACKET .

    COMMA           reduce using rule 29 (array_segment -> array_identifier LBBRACKET bound_pair_list RBBRACKET .)
    SEMICOLON       reduce using rule 29 (array_segment -> array_identifier LBBRACKET bound_pair_list RBBRACKET .)


state 273

    (33) bound_pair_list -> bound_pair_list COMMA . bound_pair
    (34) bound_pair -> . lower_bound COLON upper_bound
    (36) lower_bound -> . arithmetic_expression
    (122) arithmetic_expression -> . simple_arithmetic_expression
    (123) arithmetic_expression -> . if_clause simple_arithmetic_expression ELSE arithmetic_expression
    (124) simple_arithmetic_expression -> . term
    (125) simple_arithmetic_expression -> . adding_operator term
    (126) simple_arithmetic_expression -> . simple_arithmetic_expression adding_operator term
    (110) if_clause -> . IF boolean_expression THEN
    (129) term -> . factor
    (130) term -> . term multiplying_operator factor
    (127) adding_operator -> . PLUS
    (128) adding_operator -> . MINUS
    (134) factor -> . primary
    (135) factor -> . factor
    (136) factor -> . factor POWER primary
    (137) primary -> . unsigned_number
    (138) primary -> . variable
    (139) primary -> . function_designator
    (140) primary -> . LCBRACKET arithmetic_expression RCBRACKET
    (141) unsigned_number -> . decimal_number
    (142) unsigned_number -> . exponential_part
    (143) unsigned_number -> . decimal_number exponential_part
    (173) variable -> . simple_variable
    (174) variable -> . subscripted_variable
    (172) function_designator -> . procedure_identifier actual_parameter_part
    (144) decimal_number -> . unsigned_integer
    (145) decimal_number -> . decimal_fraction
    (146) decimal_number -> . unsigned_integer decimal_fraction
    (150) exponential_part -> . EREAL integer
    (175) simple_variable -> . variable_identifier
    (177) subscripted_variable -> . array_identifier LBBRACKET subscript_list RBBRACKET
    (44) procedure_identifier -> . IDENTIFIER
    (147) unsigned_integer -> . DIGIT
    (148) unsigned_integer -> . unsigned_integer DIGIT
    (149) decimal_fraction -> . DOT unsigned_integer
    (176) variable_identifier -> . IDENTIFIER
    (31) array_identifier -> . IDENTIFIER

    IF              shift and go to state 45
    PLUS            shift and go to state 102
    MINUS           shift and go to state 94
    LCBRACKET       shift and go to state 145
    EREAL           shift and go to state 115
    IDENTIFIER      shift and go to state 106
    DIGIT           shift and go to state 6
    DOT             shift and go to state 95

    subscripted_variable           shift and go to state 13
    primary                        shift and go to state 98
    if_clause                      shift and go to state 144
    unsigned_number                shift and go to state 105
    decimal_fraction               shift and go to state 103
    factor                         shift and go to state 104
    simple_arithmetic_expression   shift and go to state 147
    arithmetic_expression          shift and go to state 236
    lower_bound                    shift and go to state 237
    decimal_number                 shift and go to state 112
    variable_identifier            shift and go to state 41
    function_designator            shift and go to state 149
    array_identifier               shift and go to state 14
    variable                       shift and go to state 150
    exponential_part               shift and go to state 92
    term                           shift and go to state 113
    procedure_identifier           shift and go to state 125
    simple_variable                shift and go to state 49
    bound_pair                     shift and go to state 289
    adding_operator                shift and go to state 117
    unsigned_integer               shift and go to state 120

state 274

    (113) for_clause -> FOR variable ASSIGNMENT for_list DO .

    TLABEL          reduce using rule 113 (for_clause -> FOR variable ASSIGNMENT for_list DO .)
    IF              reduce using rule 113 (for_clause -> FOR variable ASSIGNMENT for_list DO .)
    IDENTIFIER      reduce using rule 113 (for_clause -> FOR variable ASSIGNMENT for_list DO .)
    FOR             reduce using rule 113 (for_clause -> FOR variable ASSIGNMENT for_list DO .)
    BEGIN           reduce using rule 113 (for_clause -> FOR variable ASSIGNMENT for_list DO .)
    DIGIT           reduce using rule 113 (for_clause -> FOR variable ASSIGNMENT for_list DO .)
    GOTO            reduce using rule 113 (for_clause -> FOR variable ASSIGNMENT for_list DO .)
    END             reduce using rule 113 (for_clause -> FOR variable ASSIGNMENT for_list DO .)
    SEMICOLON       reduce using rule 113 (for_clause -> FOR variable ASSIGNMENT for_list DO .)


state 275

    (115) for_list -> for_list COMMA . for_list_element
    (116) for_list_element -> . arithmetic_expression
    (117) for_list_element -> . arithmetic_expression STEP arithmetic_expression UNTIL arithmetic_expression
    (118) for_list_element -> . arithmetic_expression WHILE boolean_expression
    (122) arithmetic_expression -> . simple_arithmetic_expression
    (123) arithmetic_expression -> . if_clause simple_arithmetic_expression ELSE arithmetic_expression
    (124) simple_arithmetic_expression -> . term
    (125) simple_arithmetic_expression -> . adding_operator term
    (126) simple_arithmetic_expression -> . simple_arithmetic_expression adding_operator term
    (110) if_clause -> . IF boolean_expression THEN
    (129) term -> . factor
    (130) term -> . term multiplying_operator factor
    (127) adding_operator -> . PLUS
    (128) adding_operator -> . MINUS
    (134) factor -> . primary
    (135) factor -> . factor
    (136) factor -> . factor POWER primary
    (137) primary -> . unsigned_number
    (138) primary -> . variable
    (139) primary -> . function_designator
    (140) primary -> . LCBRACKET arithmetic_expression RCBRACKET
    (141) unsigned_number -> . decimal_number
    (142) unsigned_number -> . exponential_part
    (143) unsigned_number -> . decimal_number exponential_part
    (173) variable -> . simple_variable
    (174) variable -> . subscripted_variable
    (172) function_designator -> . procedure_identifier actual_parameter_part
    (144) decimal_number -> . unsigned_integer
    (145) decimal_number -> . decimal_fraction
    (146) decimal_number -> . unsigned_integer decimal_fraction
    (150) exponential_part -> . EREAL integer
    (175) simple_variable -> . variable_identifier
    (177) subscripted_variable -> . array_identifier LBBRACKET subscript_list RBBRACKET
    (44) procedure_identifier -> . IDENTIFIER
    (147) unsigned_integer -> . DIGIT
    (148) unsigned_integer -> . unsigned_integer DIGIT
    (149) decimal_fraction -> . DOT unsigned_integer
    (176) variable_identifier -> . IDENTIFIER
    (31) array_identifier -> . IDENTIFIER

    IF              shift and go to state 45
    PLUS            shift and go to state 102
    MINUS           shift and go to state 94
    LCBRACKET       shift and go to state 145
    EREAL           shift and go to state 115
    IDENTIFIER      shift and go to state 106
    DIGIT           shift and go to state 6
    DOT             shift and go to state 95

    subscripted_variable           shift and go to state 13
    for_list_element               shift and go to state 290
    if_clause                      shift and go to state 144
    unsigned_number                shift and go to state 105
    decimal_fraction               shift and go to state 103
    factor                         shift and go to state 104
    simple_arithmetic_expression   shift and go to state 147
    arithmetic_expression          shift and go to state 244
    decimal_number                 shift and go to state 112
    primary                        shift and go to state 98
    variable_identifier            shift and go to state 41
    function_designator            shift and go to state 149
    array_identifier               shift and go to state 14
    variable                       shift and go to state 150
    exponential_part               shift and go to state 92
    term                           shift and go to state 113
    procedure_identifier           shift and go to state 125
    simple_variable                shift and go to state 49
    adding_operator                shift and go to state 117
    unsigned_integer               shift and go to state 120

state 276

    (117) for_list_element -> arithmetic_expression STEP . arithmetic_expression UNTIL arithmetic_expression
    (122) arithmetic_expression -> . simple_arithmetic_expression
    (123) arithmetic_expression -> . if_clause simple_arithmetic_expression ELSE arithmetic_expression
    (124) simple_arithmetic_expression -> . term
    (125) simple_arithmetic_expression -> . adding_operator term
    (126) simple_arithmetic_expression -> . simple_arithmetic_expression adding_operator term
    (110) if_clause -> . IF boolean_expression THEN
    (129) term -> . factor
    (130) term -> . term multiplying_operator factor
    (127) adding_operator -> . PLUS
    (128) adding_operator -> . MINUS
    (134) factor -> . primary
    (135) factor -> . factor
    (136) factor -> . factor POWER primary
    (137) primary -> . unsigned_number
    (138) primary -> . variable
    (139) primary -> . function_designator
    (140) primary -> . LCBRACKET arithmetic_expression RCBRACKET
    (141) unsigned_number -> . decimal_number
    (142) unsigned_number -> . exponential_part
    (143) unsigned_number -> . decimal_number exponential_part
    (173) variable -> . simple_variable
    (174) variable -> . subscripted_variable
    (172) function_designator -> . procedure_identifier actual_parameter_part
    (144) decimal_number -> . unsigned_integer
    (145) decimal_number -> . decimal_fraction
    (146) decimal_number -> . unsigned_integer decimal_fraction
    (150) exponential_part -> . EREAL integer
    (175) simple_variable -> . variable_identifier
    (177) subscripted_variable -> . array_identifier LBBRACKET subscript_list RBBRACKET
    (44) procedure_identifier -> . IDENTIFIER
    (147) unsigned_integer -> . DIGIT
    (148) unsigned_integer -> . unsigned_integer DIGIT
    (149) decimal_fraction -> . DOT unsigned_integer
    (176) variable_identifier -> . IDENTIFIER
    (31) array_identifier -> . IDENTIFIER

    IF              shift and go to state 45
    PLUS            shift and go to state 102
    MINUS           shift and go to state 94
    LCBRACKET       shift and go to state 145
    EREAL           shift and go to state 115
    IDENTIFIER      shift and go to state 106
    DIGIT           shift and go to state 6
    DOT             shift and go to state 95

    subscripted_variable           shift and go to state 13
    primary                        shift and go to state 98
    if_clause                      shift and go to state 144
    unsigned_number                shift and go to state 105
    decimal_fraction               shift and go to state 103
    factor                         shift and go to state 104
    simple_arithmetic_expression   shift and go to state 147
    arithmetic_expression          shift and go to state 291
    decimal_number                 shift and go to state 112
    variable_identifier            shift and go to state 41
    function_designator            shift and go to state 149
    array_identifier               shift and go to state 14
    variable                       shift and go to state 150
    exponential_part               shift and go to state 92
    term                           shift and go to state 113
    procedure_identifier           shift and go to state 125
    simple_variable                shift and go to state 49
    adding_operator                shift and go to state 117
    unsigned_integer               shift and go to state 120

state 277

    (118) for_list_element -> arithmetic_expression WHILE . boolean_expression
    (154) boolean_expression -> . simple_boolean
    (155) boolean_expression -> . if_clause simple_boolean ELSE boolean_expression
    (156) simple_boolean -> . implication
    (157) simple_boolean -> . simple_boolean EQUIV implication
    (110) if_clause -> . IF boolean_expression THEN
    (158) implication -> . boolean_term
    (159) implication -> . implication IMPL boolean_term
    (160) boolean_term -> . boolean_factor
    (161) boolean_term -> . boolean_term OR boolean_factor
    (162) boolean_factor -> . boolean_secondary
    (163) boolean_factor -> . boolean_factor AND boolean_secondary
    (164) boolean_secondary -> . boolean_primary
    (165) boolean_secondary -> . NOT boolean_primary
    (166) boolean_primary -> . logical_value
    (167) boolean_primary -> . variable
    (168) boolean_primary -> . function_designator
    (169) boolean_primary -> . relation
    (170) boolean_primary -> . LCBRACKET boolean_expression RCBRACKET
    (184) logical_value -> . TRUE
    (185) logical_value -> . FALSE
    (173) variable -> . simple_variable
    (174) variable -> . subscripted_variable
    (172) function_designator -> . procedure_identifier actual_parameter_part
    (171) relation -> . simple_arithmetic_expression relational_operator simple_arithmetic_expression
    (175) simple_variable -> . variable_identifier
    (177) subscripted_variable -> . array_identifier LBBRACKET subscript_list RBBRACKET
    (44) procedure_identifier -> . IDENTIFIER
    (124) simple_arithmetic_expression -> . term
    (125) simple_arithmetic_expression -> . adding_operator term
    (126) simple_arithmetic_expression -> . simple_arithmetic_expression adding_operator term
    (176) variable_identifier -> . IDENTIFIER
    (31) array_identifier -> . IDENTIFIER
    (129) term -> . factor
    (130) term -> . term multiplying_operator factor
    (127) adding_operator -> . PLUS
    (128) adding_operator -> . MINUS
    (134) factor -> . primary
    (135) factor -> . factor
    (136) factor -> . factor POWER primary
    (137) primary -> . unsigned_number
    (138) primary -> . variable
    (139) primary -> . function_designator
    (140) primary -> . LCBRACKET arithmetic_expression RCBRACKET
    (141) unsigned_number -> . decimal_number
    (142) unsigned_number -> . exponential_part
    (143) unsigned_number -> . decimal_number exponential_part
    (144) decimal_number -> . unsigned_integer
    (145) decimal_number -> . decimal_fraction
    (146) decimal_number -> . unsigned_integer decimal_fraction
    (150) exponential_part -> . EREAL integer
    (147) unsigned_integer -> . DIGIT
    (148) unsigned_integer -> . unsigned_integer DIGIT
    (149) decimal_fraction -> . DOT unsigned_integer

    IF              shift and go to state 45
    NOT             shift and go to state 118
    LCBRACKET       shift and go to state 127
    TRUE            shift and go to state 93
    FALSE           shift and go to state 100
    IDENTIFIER      shift and go to state 106
    PLUS            shift and go to state 102
    MINUS           shift and go to state 94
    EREAL           shift and go to state 115
    DIGIT           shift and go to state 6
    DOT             shift and go to state 95

    boolean_primary                shift and go to state 99
    subscripted_variable           shift and go to state 13
    boolean_term                   shift and go to state 88
    if_clause                      shift and go to state 126
    boolean_factor                 shift and go to state 90
    relation                       shift and go to state 91
    simple_boolean                 shift and go to state 97
    boolean_secondary              shift and go to state 101
    unsigned_number                shift and go to state 105
    decimal_fraction               shift and go to state 103
    factor                         shift and go to state 104
    simple_arithmetic_expression   shift and go to state 131
    logical_value                  shift and go to state 109
    decimal_number                 shift and go to state 112
    primary                        shift and go to state 98
    variable_identifier            shift and go to state 41
    function_designator            shift and go to state 128
    array_identifier               shift and go to state 14
    variable                       shift and go to state 129
    exponential_part               shift and go to state 92
    term                           shift and go to state 113
    boolean_expression             shift and go to state 292
    procedure_identifier           shift and go to state 125
    simple_variable                shift and go to state 49
    adding_operator                shift and go to state 117
    implication                    shift and go to state 119
    unsigned_integer               shift and go to state 120

state 278

    (123) arithmetic_expression -> if_clause simple_arithmetic_expression ELSE arithmetic_expression .

    RCBRACKET       reduce using rule 123 (arithmetic_expression -> if_clause simple_arithmetic_expression ELSE arithmetic_expression .)
    COMMA           reduce using rule 123 (arithmetic_expression -> if_clause simple_arithmetic_expression ELSE arithmetic_expression .)
    STEP            reduce using rule 123 (arithmetic_expression -> if_clause simple_arithmetic_expression ELSE arithmetic_expression .)
    WHILE           reduce using rule 123 (arithmetic_expression -> if_clause simple_arithmetic_expression ELSE arithmetic_expression .)
    DO              reduce using rule 123 (arithmetic_expression -> if_clause simple_arithmetic_expression ELSE arithmetic_expression .)
    END             reduce using rule 123 (arithmetic_expression -> if_clause simple_arithmetic_expression ELSE arithmetic_expression .)
    SEMICOLON       reduce using rule 123 (arithmetic_expression -> if_clause simple_arithmetic_expression ELSE arithmetic_expression .)
    ELSE            reduce using rule 123 (arithmetic_expression -> if_clause simple_arithmetic_expression ELSE arithmetic_expression .)
    RBBRACKET       reduce using rule 123 (arithmetic_expression -> if_clause simple_arithmetic_expression ELSE arithmetic_expression .)
    COLON           reduce using rule 123 (arithmetic_expression -> if_clause simple_arithmetic_expression ELSE arithmetic_expression .)
    UNTIL           reduce using rule 123 (arithmetic_expression -> if_clause simple_arithmetic_expression ELSE arithmetic_expression .)


state 279

    (155) boolean_expression -> if_clause simple_boolean ELSE boolean_expression .

    END             reduce using rule 155 (boolean_expression -> if_clause simple_boolean ELSE boolean_expression .)
    SEMICOLON       reduce using rule 155 (boolean_expression -> if_clause simple_boolean ELSE boolean_expression .)
    ELSE            reduce using rule 155 (boolean_expression -> if_clause simple_boolean ELSE boolean_expression .)
    THEN            reduce using rule 155 (boolean_expression -> if_clause simple_boolean ELSE boolean_expression .)
    DO              reduce using rule 155 (boolean_expression -> if_clause simple_boolean ELSE boolean_expression .)
    COMMA           reduce using rule 155 (boolean_expression -> if_clause simple_boolean ELSE boolean_expression .)
    RCBRACKET       reduce using rule 155 (boolean_expression -> if_clause simple_boolean ELSE boolean_expression .)


state 280

    (51) value_part -> TVALUE . identifier_list SEMICOLON
    (63) identifier_list -> . IDENTIFIER
    (64) identifier_list -> . identifier_list COMMA IDENTIFIER

    IDENTIFIER      shift and go to state 293

    identifier_list                shift and go to state 294

state 281

    (43) procedure_heading -> procedure_identifier formal_parameter_part SEMICOLON value_part . specification_part
    (52) specification_part -> .
    (53) specification_part -> . specifier identifier_list SEMICOLON
    (54) specification_part -> . specification_part specifier identifier_list
    (55) specifier -> . TSTRING
    (56) specifier -> . type
    (57) specifier -> . TARRAY
    (58) specifier -> . type TARRAY
    (59) specifier -> . TLABEL
    (60) specifier -> . SWITCH
    (61) specifier -> . PROCEDURE
    (62) specifier -> . type PROCEDURE
    (20) type -> . TREAL
    (21) type -> . TINTEGER
    (22) type -> . TBOOLEAN

  ! shift/reduce conflict for TSTRING resolved as shift
  ! shift/reduce conflict for TARRAY resolved as shift
  ! shift/reduce conflict for TLABEL resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for PROCEDURE resolved as shift
  ! shift/reduce conflict for TREAL resolved as shift
  ! shift/reduce conflict for TINTEGER resolved as shift
  ! shift/reduce conflict for TBOOLEAN resolved as shift
    IF              reduce using rule 52 (specification_part -> .)
    IDENTIFIER      reduce using rule 52 (specification_part -> .)
    FOR             reduce using rule 52 (specification_part -> .)
    BEGIN           reduce using rule 52 (specification_part -> .)
    DIGIT           reduce using rule 52 (specification_part -> .)
    GOTO            reduce using rule 52 (specification_part -> .)
    SEMICOLON       reduce using rule 52 (specification_part -> .)
    TSTRING         shift and go to state 298
    TARRAY          shift and go to state 300
    TLABEL          shift and go to state 296
    SWITCH          shift and go to state 297
    PROCEDURE       shift and go to state 301
    TREAL           shift and go to state 15
    TINTEGER        shift and go to state 18
    TBOOLEAN        shift and go to state 26

  ! TSTRING         [ reduce using rule 52 (specification_part -> .) ]
  ! TARRAY          [ reduce using rule 52 (specification_part -> .) ]
  ! TLABEL          [ reduce using rule 52 (specification_part -> .) ]
  ! SWITCH          [ reduce using rule 52 (specification_part -> .) ]
  ! PROCEDURE       [ reduce using rule 52 (specification_part -> .) ]
  ! TREAL           [ reduce using rule 52 (specification_part -> .) ]
  ! TINTEGER        [ reduce using rule 52 (specification_part -> .) ]
  ! TBOOLEAN        [ reduce using rule 52 (specification_part -> .) ]

    specifier                      shift and go to state 295
    type                           shift and go to state 299
    specification_part             shift and go to state 302

state 282

    (46) formal_parameter_part -> LCBRACKET formal_parameter_list RCBRACKET .
    (99) parameter_delimiter -> RCBRACKET . letter_string COLON LCBRACKET
    (182) letter_string -> . LETTER
    (183) letter_string -> . letter_string LETTER

    SEMICOLON       reduce using rule 46 (formal_parameter_part -> LCBRACKET formal_parameter_list RCBRACKET .)
    LETTER          shift and go to state 268

    letter_string                  shift and go to state 267

state 283

    (48) formal_parameter_list -> formal_parameter_list parameter_delimiter . formal_parameter
    (49) formal_parameter -> . IDENTIFIER

    IDENTIFIER      shift and go to state 262

    formal_parameter               shift and go to state 303

state 284

    (99) parameter_delimiter -> RCBRACKET letter_string COLON . LCBRACKET

    LCBRACKET       shift and go to state 304


state 285

    (183) letter_string -> letter_string LETTER .

    COLON           reduce using rule 183 (letter_string -> letter_string LETTER .)
    LETTER          reduce using rule 183 (letter_string -> letter_string LETTER .)


state 286

    (40) switch_list -> switch_list COMMA designational_expression .

    COMMA           reduce using rule 40 (switch_list -> switch_list COMMA designational_expression .)
    SEMICOLON       reduce using rule 40 (switch_list -> switch_list COMMA designational_expression .)


state 287

    (35) upper_bound -> arithmetic_expression .

    RBBRACKET       reduce using rule 35 (upper_bound -> arithmetic_expression .)
    COMMA           reduce using rule 35 (upper_bound -> arithmetic_expression .)


state 288

    (34) bound_pair -> lower_bound COLON upper_bound .

    RBBRACKET       reduce using rule 34 (bound_pair -> lower_bound COLON upper_bound .)
    COMMA           reduce using rule 34 (bound_pair -> lower_bound COLON upper_bound .)


state 289

    (33) bound_pair_list -> bound_pair_list COMMA bound_pair .

    RBBRACKET       reduce using rule 33 (bound_pair_list -> bound_pair_list COMMA bound_pair .)
    COMMA           reduce using rule 33 (bound_pair_list -> bound_pair_list COMMA bound_pair .)


state 290

    (115) for_list -> for_list COMMA for_list_element .

    DO              reduce using rule 115 (for_list -> for_list COMMA for_list_element .)
    COMMA           reduce using rule 115 (for_list -> for_list COMMA for_list_element .)


state 291

    (117) for_list_element -> arithmetic_expression STEP arithmetic_expression . UNTIL arithmetic_expression

    UNTIL           shift and go to state 305


state 292

    (118) for_list_element -> arithmetic_expression WHILE boolean_expression .

    DO              reduce using rule 118 (for_list_element -> arithmetic_expression WHILE boolean_expression .)
    COMMA           reduce using rule 118 (for_list_element -> arithmetic_expression WHILE boolean_expression .)


state 293

    (63) identifier_list -> IDENTIFIER .

    SEMICOLON       reduce using rule 63 (identifier_list -> IDENTIFIER .)
    COMMA           reduce using rule 63 (identifier_list -> IDENTIFIER .)
    TSTRING         reduce using rule 63 (identifier_list -> IDENTIFIER .)
    TARRAY          reduce using rule 63 (identifier_list -> IDENTIFIER .)
    TLABEL          reduce using rule 63 (identifier_list -> IDENTIFIER .)
    SWITCH          reduce using rule 63 (identifier_list -> IDENTIFIER .)
    PROCEDURE       reduce using rule 63 (identifier_list -> IDENTIFIER .)
    TREAL           reduce using rule 63 (identifier_list -> IDENTIFIER .)
    TINTEGER        reduce using rule 63 (identifier_list -> IDENTIFIER .)
    TBOOLEAN        reduce using rule 63 (identifier_list -> IDENTIFIER .)
    IF              reduce using rule 63 (identifier_list -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 63 (identifier_list -> IDENTIFIER .)
    FOR             reduce using rule 63 (identifier_list -> IDENTIFIER .)
    BEGIN           reduce using rule 63 (identifier_list -> IDENTIFIER .)
    DIGIT           reduce using rule 63 (identifier_list -> IDENTIFIER .)
    GOTO            reduce using rule 63 (identifier_list -> IDENTIFIER .)


state 294

    (51) value_part -> TVALUE identifier_list . SEMICOLON
    (64) identifier_list -> identifier_list . COMMA IDENTIFIER

    SEMICOLON       shift and go to state 307
    COMMA           shift and go to state 306


state 295

    (53) specification_part -> specifier . identifier_list SEMICOLON
    (63) identifier_list -> . IDENTIFIER
    (64) identifier_list -> . identifier_list COMMA IDENTIFIER

    IDENTIFIER      shift and go to state 293

    identifier_list                shift and go to state 308

state 296

    (59) specifier -> TLABEL .

    IDENTIFIER      reduce using rule 59 (specifier -> TLABEL .)


state 297

    (60) specifier -> SWITCH .

    IDENTIFIER      reduce using rule 60 (specifier -> SWITCH .)


state 298

    (55) specifier -> TSTRING .

    IDENTIFIER      reduce using rule 55 (specifier -> TSTRING .)


state 299

    (56) specifier -> type .
    (58) specifier -> type . TARRAY
    (62) specifier -> type . PROCEDURE

    IDENTIFIER      reduce using rule 56 (specifier -> type .)
    TARRAY          shift and go to state 309
    PROCEDURE       shift and go to state 310


state 300

    (57) specifier -> TARRAY .

    IDENTIFIER      reduce using rule 57 (specifier -> TARRAY .)


state 301

    (61) specifier -> PROCEDURE .

    IDENTIFIER      reduce using rule 61 (specifier -> PROCEDURE .)


state 302

    (43) procedure_heading -> procedure_identifier formal_parameter_part SEMICOLON value_part specification_part .
    (54) specification_part -> specification_part . specifier identifier_list
    (55) specifier -> . TSTRING
    (56) specifier -> . type
    (57) specifier -> . TARRAY
    (58) specifier -> . type TARRAY
    (59) specifier -> . TLABEL
    (60) specifier -> . SWITCH
    (61) specifier -> . PROCEDURE
    (62) specifier -> . type PROCEDURE
    (20) type -> . TREAL
    (21) type -> . TINTEGER
    (22) type -> . TBOOLEAN

  ! shift/reduce conflict for TLABEL resolved as shift
    IF              reduce using rule 43 (procedure_heading -> procedure_identifier formal_parameter_part SEMICOLON value_part specification_part .)
    IDENTIFIER      reduce using rule 43 (procedure_heading -> procedure_identifier formal_parameter_part SEMICOLON value_part specification_part .)
    FOR             reduce using rule 43 (procedure_heading -> procedure_identifier formal_parameter_part SEMICOLON value_part specification_part .)
    BEGIN           reduce using rule 43 (procedure_heading -> procedure_identifier formal_parameter_part SEMICOLON value_part specification_part .)
    DIGIT           reduce using rule 43 (procedure_heading -> procedure_identifier formal_parameter_part SEMICOLON value_part specification_part .)
    GOTO            reduce using rule 43 (procedure_heading -> procedure_identifier formal_parameter_part SEMICOLON value_part specification_part .)
    SEMICOLON       reduce using rule 43 (procedure_heading -> procedure_identifier formal_parameter_part SEMICOLON value_part specification_part .)
    TSTRING         shift and go to state 298
    TARRAY          shift and go to state 300
    TLABEL          shift and go to state 296
    SWITCH          shift and go to state 297
    PROCEDURE       shift and go to state 301
    TREAL           shift and go to state 15
    TINTEGER        shift and go to state 18
    TBOOLEAN        shift and go to state 26

  ! TLABEL          [ reduce using rule 43 (procedure_heading -> procedure_identifier formal_parameter_part SEMICOLON value_part specification_part .) ]

    specifier                      shift and go to state 311
    type                           shift and go to state 299

state 303

    (48) formal_parameter_list -> formal_parameter_list parameter_delimiter formal_parameter .

    RCBRACKET       reduce using rule 48 (formal_parameter_list -> formal_parameter_list parameter_delimiter formal_parameter .)
    COMMA           reduce using rule 48 (formal_parameter_list -> formal_parameter_list parameter_delimiter formal_parameter .)


state 304

    (99) parameter_delimiter -> RCBRACKET letter_string COLON LCBRACKET .

    STRING          reduce using rule 99 (parameter_delimiter -> RCBRACKET letter_string COLON LCBRACKET .)
    IDENTIFIER      reduce using rule 99 (parameter_delimiter -> RCBRACKET letter_string COLON LCBRACKET .)
    IF              reduce using rule 99 (parameter_delimiter -> RCBRACKET letter_string COLON LCBRACKET .)
    LCBRACKET       reduce using rule 99 (parameter_delimiter -> RCBRACKET letter_string COLON LCBRACKET .)
    PLUS            reduce using rule 99 (parameter_delimiter -> RCBRACKET letter_string COLON LCBRACKET .)
    MINUS           reduce using rule 99 (parameter_delimiter -> RCBRACKET letter_string COLON LCBRACKET .)
    DIGIT           reduce using rule 99 (parameter_delimiter -> RCBRACKET letter_string COLON LCBRACKET .)
    NOT             reduce using rule 99 (parameter_delimiter -> RCBRACKET letter_string COLON LCBRACKET .)
    EREAL           reduce using rule 99 (parameter_delimiter -> RCBRACKET letter_string COLON LCBRACKET .)
    DOT             reduce using rule 99 (parameter_delimiter -> RCBRACKET letter_string COLON LCBRACKET .)
    TRUE            reduce using rule 99 (parameter_delimiter -> RCBRACKET letter_string COLON LCBRACKET .)
    FALSE           reduce using rule 99 (parameter_delimiter -> RCBRACKET letter_string COLON LCBRACKET .)


state 305

    (117) for_list_element -> arithmetic_expression STEP arithmetic_expression UNTIL . arithmetic_expression
    (122) arithmetic_expression -> . simple_arithmetic_expression
    (123) arithmetic_expression -> . if_clause simple_arithmetic_expression ELSE arithmetic_expression
    (124) simple_arithmetic_expression -> . term
    (125) simple_arithmetic_expression -> . adding_operator term
    (126) simple_arithmetic_expression -> . simple_arithmetic_expression adding_operator term
    (110) if_clause -> . IF boolean_expression THEN
    (129) term -> . factor
    (130) term -> . term multiplying_operator factor
    (127) adding_operator -> . PLUS
    (128) adding_operator -> . MINUS
    (134) factor -> . primary
    (135) factor -> . factor
    (136) factor -> . factor POWER primary
    (137) primary -> . unsigned_number
    (138) primary -> . variable
    (139) primary -> . function_designator
    (140) primary -> . LCBRACKET arithmetic_expression RCBRACKET
    (141) unsigned_number -> . decimal_number
    (142) unsigned_number -> . exponential_part
    (143) unsigned_number -> . decimal_number exponential_part
    (173) variable -> . simple_variable
    (174) variable -> . subscripted_variable
    (172) function_designator -> . procedure_identifier actual_parameter_part
    (144) decimal_number -> . unsigned_integer
    (145) decimal_number -> . decimal_fraction
    (146) decimal_number -> . unsigned_integer decimal_fraction
    (150) exponential_part -> . EREAL integer
    (175) simple_variable -> . variable_identifier
    (177) subscripted_variable -> . array_identifier LBBRACKET subscript_list RBBRACKET
    (44) procedure_identifier -> . IDENTIFIER
    (147) unsigned_integer -> . DIGIT
    (148) unsigned_integer -> . unsigned_integer DIGIT
    (149) decimal_fraction -> . DOT unsigned_integer
    (176) variable_identifier -> . IDENTIFIER
    (31) array_identifier -> . IDENTIFIER

    IF              shift and go to state 45
    PLUS            shift and go to state 102
    MINUS           shift and go to state 94
    LCBRACKET       shift and go to state 145
    EREAL           shift and go to state 115
    IDENTIFIER      shift and go to state 106
    DIGIT           shift and go to state 6
    DOT             shift and go to state 95

    subscripted_variable           shift and go to state 13
    primary                        shift and go to state 98
    if_clause                      shift and go to state 144
    unsigned_number                shift and go to state 105
    decimal_fraction               shift and go to state 103
    factor                         shift and go to state 104
    simple_arithmetic_expression   shift and go to state 147
    arithmetic_expression          shift and go to state 312
    decimal_number                 shift and go to state 112
    variable_identifier            shift and go to state 41
    function_designator            shift and go to state 149
    array_identifier               shift and go to state 14
    variable                       shift and go to state 150
    exponential_part               shift and go to state 92
    term                           shift and go to state 113
    procedure_identifier           shift and go to state 125
    simple_variable                shift and go to state 49
    adding_operator                shift and go to state 117
    unsigned_integer               shift and go to state 120

state 306

    (64) identifier_list -> identifier_list COMMA . IDENTIFIER

    IDENTIFIER      shift and go to state 313


state 307

    (51) value_part -> TVALUE identifier_list SEMICOLON .

    TSTRING         reduce using rule 51 (value_part -> TVALUE identifier_list SEMICOLON .)
    TARRAY          reduce using rule 51 (value_part -> TVALUE identifier_list SEMICOLON .)
    TLABEL          reduce using rule 51 (value_part -> TVALUE identifier_list SEMICOLON .)
    SWITCH          reduce using rule 51 (value_part -> TVALUE identifier_list SEMICOLON .)
    PROCEDURE       reduce using rule 51 (value_part -> TVALUE identifier_list SEMICOLON .)
    TREAL           reduce using rule 51 (value_part -> TVALUE identifier_list SEMICOLON .)
    TINTEGER        reduce using rule 51 (value_part -> TVALUE identifier_list SEMICOLON .)
    TBOOLEAN        reduce using rule 51 (value_part -> TVALUE identifier_list SEMICOLON .)
    IF              reduce using rule 51 (value_part -> TVALUE identifier_list SEMICOLON .)
    IDENTIFIER      reduce using rule 51 (value_part -> TVALUE identifier_list SEMICOLON .)
    FOR             reduce using rule 51 (value_part -> TVALUE identifier_list SEMICOLON .)
    BEGIN           reduce using rule 51 (value_part -> TVALUE identifier_list SEMICOLON .)
    DIGIT           reduce using rule 51 (value_part -> TVALUE identifier_list SEMICOLON .)
    GOTO            reduce using rule 51 (value_part -> TVALUE identifier_list SEMICOLON .)
    SEMICOLON       reduce using rule 51 (value_part -> TVALUE identifier_list SEMICOLON .)


state 308

    (53) specification_part -> specifier identifier_list . SEMICOLON
    (64) identifier_list -> identifier_list . COMMA IDENTIFIER

    SEMICOLON       shift and go to state 314
    COMMA           shift and go to state 306


state 309

    (58) specifier -> type TARRAY .

    IDENTIFIER      reduce using rule 58 (specifier -> type TARRAY .)


state 310

    (62) specifier -> type PROCEDURE .

    IDENTIFIER      reduce using rule 62 (specifier -> type PROCEDURE .)


state 311

    (54) specification_part -> specification_part specifier . identifier_list
    (63) identifier_list -> . IDENTIFIER
    (64) identifier_list -> . identifier_list COMMA IDENTIFIER

    IDENTIFIER      shift and go to state 293

    identifier_list                shift and go to state 315

state 312

    (117) for_list_element -> arithmetic_expression STEP arithmetic_expression UNTIL arithmetic_expression .

    DO              reduce using rule 117 (for_list_element -> arithmetic_expression STEP arithmetic_expression UNTIL arithmetic_expression .)
    COMMA           reduce using rule 117 (for_list_element -> arithmetic_expression STEP arithmetic_expression UNTIL arithmetic_expression .)


state 313

    (64) identifier_list -> identifier_list COMMA IDENTIFIER .

    SEMICOLON       reduce using rule 64 (identifier_list -> identifier_list COMMA IDENTIFIER .)
    COMMA           reduce using rule 64 (identifier_list -> identifier_list COMMA IDENTIFIER .)
    TSTRING         reduce using rule 64 (identifier_list -> identifier_list COMMA IDENTIFIER .)
    TARRAY          reduce using rule 64 (identifier_list -> identifier_list COMMA IDENTIFIER .)
    TLABEL          reduce using rule 64 (identifier_list -> identifier_list COMMA IDENTIFIER .)
    SWITCH          reduce using rule 64 (identifier_list -> identifier_list COMMA IDENTIFIER .)
    PROCEDURE       reduce using rule 64 (identifier_list -> identifier_list COMMA IDENTIFIER .)
    TREAL           reduce using rule 64 (identifier_list -> identifier_list COMMA IDENTIFIER .)
    TINTEGER        reduce using rule 64 (identifier_list -> identifier_list COMMA IDENTIFIER .)
    TBOOLEAN        reduce using rule 64 (identifier_list -> identifier_list COMMA IDENTIFIER .)
    IF              reduce using rule 64 (identifier_list -> identifier_list COMMA IDENTIFIER .)
    IDENTIFIER      reduce using rule 64 (identifier_list -> identifier_list COMMA IDENTIFIER .)
    FOR             reduce using rule 64 (identifier_list -> identifier_list COMMA IDENTIFIER .)
    BEGIN           reduce using rule 64 (identifier_list -> identifier_list COMMA IDENTIFIER .)
    DIGIT           reduce using rule 64 (identifier_list -> identifier_list COMMA IDENTIFIER .)
    GOTO            reduce using rule 64 (identifier_list -> identifier_list COMMA IDENTIFIER .)


state 314

    (53) specification_part -> specifier identifier_list SEMICOLON .

    TSTRING         reduce using rule 53 (specification_part -> specifier identifier_list SEMICOLON .)
    TARRAY          reduce using rule 53 (specification_part -> specifier identifier_list SEMICOLON .)
    TLABEL          reduce using rule 53 (specification_part -> specifier identifier_list SEMICOLON .)
    SWITCH          reduce using rule 53 (specification_part -> specifier identifier_list SEMICOLON .)
    PROCEDURE       reduce using rule 53 (specification_part -> specifier identifier_list SEMICOLON .)
    TREAL           reduce using rule 53 (specification_part -> specifier identifier_list SEMICOLON .)
    TINTEGER        reduce using rule 53 (specification_part -> specifier identifier_list SEMICOLON .)
    TBOOLEAN        reduce using rule 53 (specification_part -> specifier identifier_list SEMICOLON .)
    IF              reduce using rule 53 (specification_part -> specifier identifier_list SEMICOLON .)
    IDENTIFIER      reduce using rule 53 (specification_part -> specifier identifier_list SEMICOLON .)
    FOR             reduce using rule 53 (specification_part -> specifier identifier_list SEMICOLON .)
    BEGIN           reduce using rule 53 (specification_part -> specifier identifier_list SEMICOLON .)
    DIGIT           reduce using rule 53 (specification_part -> specifier identifier_list SEMICOLON .)
    GOTO            reduce using rule 53 (specification_part -> specifier identifier_list SEMICOLON .)
    SEMICOLON       reduce using rule 53 (specification_part -> specifier identifier_list SEMICOLON .)


state 315

    (54) specification_part -> specification_part specifier identifier_list .
    (64) identifier_list -> identifier_list . COMMA IDENTIFIER

    TSTRING         reduce using rule 54 (specification_part -> specification_part specifier identifier_list .)
    TARRAY          reduce using rule 54 (specification_part -> specification_part specifier identifier_list .)
    TLABEL          reduce using rule 54 (specification_part -> specification_part specifier identifier_list .)
    SWITCH          reduce using rule 54 (specification_part -> specification_part specifier identifier_list .)
    PROCEDURE       reduce using rule 54 (specification_part -> specification_part specifier identifier_list .)
    TREAL           reduce using rule 54 (specification_part -> specification_part specifier identifier_list .)
    TINTEGER        reduce using rule 54 (specification_part -> specification_part specifier identifier_list .)
    TBOOLEAN        reduce using rule 54 (specification_part -> specification_part specifier identifier_list .)
    IF              reduce using rule 54 (specification_part -> specification_part specifier identifier_list .)
    IDENTIFIER      reduce using rule 54 (specification_part -> specification_part specifier identifier_list .)
    FOR             reduce using rule 54 (specification_part -> specification_part specifier identifier_list .)
    BEGIN           reduce using rule 54 (specification_part -> specification_part specifier identifier_list .)
    DIGIT           reduce using rule 54 (specification_part -> specification_part specifier identifier_list .)
    GOTO            reduce using rule 54 (specification_part -> specification_part specifier identifier_list .)
    SEMICOLON       reduce using rule 54 (specification_part -> specification_part specifier identifier_list .)
    COMMA           shift and go to state 306

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for POWER in state 104 resolved as shift
WARNING: shift/reduce conflict for POWER in state 253 resolved as shift
WARNING: shift/reduce conflict for TSTRING in state 281 resolved as shift
WARNING: shift/reduce conflict for TARRAY in state 281 resolved as shift
WARNING: shift/reduce conflict for TLABEL in state 281 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 281 resolved as shift
WARNING: shift/reduce conflict for PROCEDURE in state 281 resolved as shift
WARNING: shift/reduce conflict for TREAL in state 281 resolved as shift
WARNING: shift/reduce conflict for TINTEGER in state 281 resolved as shift
WARNING: shift/reduce conflict for TBOOLEAN in state 281 resolved as shift
WARNING: shift/reduce conflict for TLABEL in state 302 resolved as shift
WARNING: reduce/reduce conflict in state 47 resolved using rule (procedure_identifier -> IDENTIFIER)
WARNING: rejected rule (variable_identifier -> IDENTIFIER) in state 47
WARNING: reduce/reduce conflict in state 104 resolved using rule (term -> factor)
WARNING: rejected rule (factor -> factor) in state 104
WARNING: reduce/reduce conflict in state 106 resolved using rule (procedure_identifier -> IDENTIFIER)
WARNING: rejected rule (variable_identifier -> IDENTIFIER) in state 106
WARNING: reduce/reduce conflict in state 110 resolved using rule (primary -> function_designator)
WARNING: rejected rule (boolean_primary -> function_designator) in state 110
WARNING: reduce/reduce conflict in state 111 resolved using rule (primary -> variable)
WARNING: rejected rule (boolean_primary -> variable) in state 111
WARNING: reduce/reduce conflict in state 161 resolved using rule (primary -> variable)
WARNING: rejected rule (boolean_primary -> variable) in state 161
WARNING: reduce/reduce conflict in state 165 resolved using rule (array_identifier -> IDENTIFIER)
WARNING: rejected rule (switch_identifier -> IDENTIFIER) in state 165
WARNING: reduce/reduce conflict in state 165 resolved using rule (array_identifier -> IDENTIFIER)
WARNING: rejected rule (procedure_identifier -> IDENTIFIER) in state 165
WARNING: reduce/reduce conflict in state 165 resolved using rule (array_identifier -> IDENTIFIER)
WARNING: rejected rule (label -> IDENTIFIER) in state 165
WARNING: reduce/reduce conflict in state 165 resolved using rule (procedure_identifier -> IDENTIFIER)
WARNING: rejected rule (variable_identifier -> IDENTIFIER) in state 165
WARNING: reduce/reduce conflict in state 165 resolved using rule (array_identifier -> IDENTIFIER)
WARNING: rejected rule (variable_identifier -> IDENTIFIER) in state 165
WARNING: reduce/reduce conflict in state 172 resolved using rule (actual_parameter_part -> <empty>)
WARNING: rejected rule (actual_parameter -> procedure_identifier) in state 172
WARNING: reduce/reduce conflict in state 174 resolved using rule (label -> unsigned_integer)
WARNING: rejected rule (decimal_number -> unsigned_integer) in state 174
WARNING: reduce/reduce conflict in state 231 resolved using rule (procedure_identifier -> IDENTIFIER)
WARNING: rejected rule (label -> IDENTIFIER) in state 231
WARNING: reduce/reduce conflict in state 231 resolved using rule (procedure_identifier -> IDENTIFIER)
WARNING: rejected rule (variable_identifier -> IDENTIFIER) in state 231
WARNING: reduce/reduce conflict in state 231 resolved using rule (array_identifier -> IDENTIFIER)
WARNING: rejected rule (switch_identifier -> IDENTIFIER) in state 231
WARNING: reduce/reduce conflict in state 253 resolved using rule (term -> term multiplying_operator factor)
WARNING: rejected rule (factor -> factor) in state 253
WARNING: Rule (factor -> factor) is never reduced
WARNING: Rule (actual_parameter -> procedure_identifier) is never reduced
